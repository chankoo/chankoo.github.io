<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>네트워크 on </title>
    <link>https://chankoo.github.io/categories/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/</link>
    <description>Recent content in 네트워크 on </description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright>
    <lastBuildDate>Tue, 05 Dec 2023 20:08:04 +0900</lastBuildDate><atom:link href="https://chankoo.github.io/categories/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>TCP</title>
      <link>https://chankoo.github.io/posts/tcp/</link>
      <pubDate>Tue, 05 Dec 2023 20:08:04 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/tcp/</guid>
      <description>
        
          
            content Transmission Control Protocol. TCP/IP 스택 전송 계층 프로토콜로 소켓 간 신뢰할 수 있는 통신을 보장한다.
프로세스와 프로세스(엄밀히는 소켓과 소켓)를 잇는 논리적인 개념의 point-to-point 통신 reliable: 응용계층에서 받은 데이터의 error와 loss가 없음을 보장 in-order byte stream: 데이터의 순서를 유지 Pipelined : window size 단위로 패킷을 묶어 통신 send &amp;amp; receive buffers: 송신 측과 수신 측 모두 send, receive buffer를 각각 가짐 Full duplex: 통신하는 host 양쪽 모두가 데이터 전송 가능 Connection oriented: handshake를 먼저 수행한 후 통신.
          
          
        
      </description>
    </item>
    
    <item>
      <title>Cache-Control</title>
      <link>https://chankoo.github.io/posts/cache-control/</link>
      <pubDate>Thu, 30 Nov 2023 14:18:34 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/cache-control/</guid>
      <description>
        
          
            content 리소스의 캐시 여부를 지정하는 http 응답/요청 헤더. Cache-Control에 부여한 directive에 따라 캐시 사용 전략이 결정된다. Etag나 bfcache 등이 모두 영향받는다.
refs Cache-Control - HTTP | MDN 프론트엔드 개발자가 알아야 할 ‘캐싱’ 개념 정리 | 요즘IT links Etag bfcache 
          
          
        
      </description>
    </item>
    
    <item>
      <title>DHCP</title>
      <link>https://chankoo.github.io/posts/dhcp/</link>
      <pubDate>Mon, 27 Nov 2023 17:31:27 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/dhcp/</guid>
      <description>
        
          
            content Dynamic Host Configuration Protocol. 네트워크에 연결된 장치들에게 IP 주소와 기타 매개변수(네임서버 주소, 게이트웨이 주소 등)를 자동으로 할당하는 IP 네트워크 레벨의 프로토콜.
서버(보통은 공유기)와 클라이언트로 나뉘는데, DHCP 서버는 서브넷에서 사용가능한 네트워크 자원을 일정 기간 클라이언트에 임대하는 역할을 수행한다. 서버가 중앙 집중식으로 관리하기에 클라이언트 간 충돌 없이 네트워크 자원을 분배할 수 있다.
refs 🌐 DHCP 이란 무엇인가? (그림으로 쉽게 정리) links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>소켓</title>
      <link>https://chankoo.github.io/posts/%EC%86%8C%EC%BC%93/</link>
      <pubDate>Wed, 07 Jun 2023 19:38:33 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%EC%86%8C%EC%BC%93/</guid>
      <description>
        
          
            content 응용계층 간의 통신을 위해서 고안된 인터페이스로 어플리케이션에서 시스템(하위 계층)의 자원과 기능을 사용하도록 한다. 프로토콜이 TCP라면, 응용계층에서 TCP/IP로 내려가는 창구가 된다.
서버 소켓 - 구현상 같은 주소의 소켓이 여러개(하나의 리슨 소켓과 여러개의 통신 소켓)이다. 요청이 리슨 소켓으로 들어오면 accept하여 통신 소켓을 생성한다. 커넥션이 만들어진 후 클라이언트는 통신 소켓과 통신한다. 클라이언트 소켓 - 특정 포트를 선택하는 바인딩 과정 없이 자동으로 포트를 선택한다. 커널이 로컬 포트 중 적당한 포트를 골라 넘겨준다. 스펙상) 소켓은 internet address + port number로 표현하며 네트워크 전체에서 유니크하다.
          
          
        
      </description>
    </item>
    
    <item>
      <title>WebSocket</title>
      <link>https://chankoo.github.io/posts/websocket/</link>
      <pubDate>Thu, 30 Mar 2023 15:23:12 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/websocket/</guid>
      <description>
        
          
            content 서버-클라이언트 양방향 일대일 통신을 제공하는 프로토콜
http는 아니지만 http 업그레이드 헤더를 사용하도록 호환된다 통신 상대가 정해져있어 데이터를 절약한다. stateful 하기에 채널을 온메모리로 관리해야한다. refs 리얼월드 HTTP links 소켓 
          
          
        
      </description>
    </item>
    
    <item>
      <title>SSE</title>
      <link>https://chankoo.github.io/posts/sse/</link>
      <pubDate>Thu, 30 Mar 2023 15:17:58 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/sse/</guid>
      <description>
        
          
            content Server-Sent Events. HTML5 의 기능으로, 한번의 요청에 서버가 여러 이벤트(청크) 전송을 제공하는 프로토콜. http 위에서 동작하는 별도 텍스트 프로토콜이다(text/event-stream).
refs 리얼월드 HTTP Server-sent events - Web APIs | MDN links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>리얼월드 HTTP</title>
      <link>https://chankoo.github.io/posts/%EB%A6%AC%EC%96%BC%EC%9B%94%EB%93%9C-http/</link>
      <pubDate>Tue, 29 Nov 2022 19:46:55 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%EB%A6%AC%EC%96%BC%EC%9B%94%EB%93%9C-http/</guid>
      <description>
        
          
            content refs links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>인증 방식 비교</title>
      <link>https://chankoo.github.io/posts/%EC%9D%B8%EC%A6%9D-%EB%B0%A9%EC%8B%9D-%EB%B9%84%EA%B5%90/</link>
      <pubDate>Sat, 19 Nov 2022 22:27:39 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%EC%9D%B8%EC%A6%9D-%EB%B0%A9%EC%8B%9D-%EB%B9%84%EA%B5%90/</guid>
      <description>
        
          
            content 쿠키와 세션 보다 토큰 기반 인증 방식(JWT)를 이용하면 장점이 많아 현대 웹, 앱은 대부분 JWT를 쓴다.
쿠키와 세션은 세션 아이디를 쿠키에 담고, 별도 세션을 저장하는 방식이다. 요청시 세션 아이디를 이용해 저장소의 세션을 확인하여 인증한다. 그렇기에 세션 저장소를 유지하는 비용이 발생하고, 요청이 stateful 한 상태가 되며, 매번 요청시 세션을 조회해야하는 단점이 있다.
반면에 JWT는 토큰 자체로 인증 여부를 판단하기에 별도 저장소가 필수적이지 않으며 매번 조회 요청을 보내지 않아도 된다. 또한 stateful 하지 않아 확장성이 좋다.
          
          
        
      </description>
    </item>
    
    <item>
      <title>JWT</title>
      <link>https://chankoo.github.io/posts/jwt/</link>
      <pubDate>Sat, 19 Nov 2022 21:38:05 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/jwt/</guid>
      <description>
        
          
            content JSON Web Token. 사용자의 정보를 Json에 담아 보내는 형식의 웹 토큰이다.
Header / Payload / Signature 로 나뉘며, base64 인코딩을 통해 url-safe한 xxx.yyy.zzz 형태로 표현한다. Header에는 Signature 에 서명한 알고리즘 정보를 담는다. Payload에는 실제 사용자 정보를 Json 형태로 담으며 추가에 열려있다. Signature는 비대칭키 방식을 사용하여 header와 payload가 변경 안되었음을 보증한다.
주로 인증을 위해 사용하는데, JWT의 유효성(위조 여부)만 확인하면 인증은 완료된다. 이미 JWT 발급 시점에 (id, pwd로) 사용자를 인증했고 그 결과로 JWT를 생성했기에, (Signature를 이용하여) JWT 가 위조되지 않았다는 것만 확인하면 JWT 발급 시점과 같은 사용자라는 것을 알게되는 원리이다.
          
          
        
      </description>
    </item>
    
    <item>
      <title>bfcache</title>
      <link>https://chankoo.github.io/posts/bfcache/</link>
      <pubDate>Wed, 09 Nov 2022 22:21:33 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/bfcache/</guid>
      <description>
        
          
            content Back/Forward Cache 는 브라우저가 제공하는 페이지 전체(js 포함) 스냅샷으로, 페이지 전환 이벤트(pageshow, pagehide)가 발생할때 캐시한다.
refs Back/forward cache | Articles | web.dev links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>Etag</title>
      <link>https://chankoo.github.io/posts/etag/</link>
      <pubDate>Fri, 04 Nov 2022 11:32:20 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/etag/</guid>
      <description>
        
          
            content 클라이언트의 http 요청의 갱신 여부를 파악하기 위해 설정하는 응답 헤더.
요청 -&amp;gt; 서버가 요청을 Etag 변환(해시 사용) -&amp;gt; 응답 헤더에 Etag 포함 -&amp;gt; 클라이언트가 사용(If-None-Match에 담아)해 요청 -&amp;gt; 동일한 Etag 라면 http 304 Not Modified 반환
refs Etag를 이용하여 더 나은 Restful API 만들기 | 요즘IT Conditional View Processing | Django documentation | Django ETag - HTTP | MDN links 
          
          
        
      </description>
    </item>
    
  </channel>
</rss>
