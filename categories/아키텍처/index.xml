<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>아키텍처 on </title>
    <link>https://chankoo.github.io/categories/%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/</link>
    <description>Recent content in 아키텍처 on </description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright>
    <lastBuildDate>Wed, 22 Nov 2023 17:46:10 +0900</lastBuildDate><atom:link href="https://chankoo.github.io/categories/%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>비동기</title>
      <link>https://chankoo.github.io/posts/%EB%B9%84%EB%8F%99%EA%B8%B0/</link>
      <pubDate>Wed, 22 Nov 2023 17:46:10 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%EB%B9%84%EB%8F%99%EA%B8%B0/</guid>
      <description>
        
          
            content 동기적이지 않은 것(asynchronous)을 의미한다.
동기적이라는 건 작업들을 순차적으로 진행함을 의미하는데, 한 작업이 끝나기를 기다려야하는 속성이 있다. 반면에 비동기는 한 작업이 끝나기를 기다리지 않고 다른 작업을 진행하는 것을 말하며, 동기적이지 않은 모든 방식을 의미한다.
비동기의 예시 non-block I/O - 요청을 block하는 작업이 아니기에 I/O를 기다리는 동안 다른 작업을 처리할 수 있다. 멀티 스레딩 - 여러 작업을 각 스레드가 나누어 진행하기에 동기적이지 않다. block I/O 작업이라도 비동기로 진행할 수 있다 refs 비동기 프로그래밍, 비동기 I/O, 비동기 커뮤니케이션.
          
          
        
      </description>
    </item>
    
    <item>
      <title>API 조합 패턴</title>
      <link>https://chankoo.github.io/posts/api-%EC%A1%B0%ED%95%A9-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Thu, 01 Jun 2023 16:30:05 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/api-%EC%A1%B0%ED%95%A9-%ED%8C%A8%ED%84%B4/</guid>
      <description>
        
          
            content (주로)MSA에서 프로바이더 서비스들이 제공하는 데이터를 조합하여 한번에 제공하는 API 조합기를 두는 패턴
설계
API 조합기로 둘 컴포넌트 선정 클라이언트 간단하지만, 클라이언트가 외부 네트워크에 존재하는 경우 느리다 API 게이트웨이 일반적인 방법으로 API 게이트웨이 패턴이라 불림 스탠드 얼론 서비스 &amp;lsquo;주문 검색 서비스&amp;rsquo; 와 같은 서비스를 두어 조합기 역할을 맡기는 방법 효율적인 조합 로직 프로바이더 서비스 순차 호출에 따른 지연 시간을 줄이는 것이 핵심 리액티브 프로그래밍을 권장 refs 마이크로서비스 패턴 links API Gateway 패턴 리액티브 프로그래밍 
          
          
        
      </description>
    </item>
    
    <item>
      <title>서비스 메시</title>
      <link>https://chankoo.github.io/posts/%EC%84%9C%EB%B9%84%EC%8A%A4-%EB%A9%94%EC%8B%9C/</link>
      <pubDate>Wed, 24 May 2023 20:37:57 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%EC%84%9C%EB%B9%84%EC%8A%A4-%EB%A9%94%EC%8B%9C/</guid>
      <description>
        
          
            content 프록시를 사용하여 서비스 간의 통신을 관리하는 인프라 계층. 도커와 쿠버네티스는 수많은 마이크로서비스의 오케스트레이션을 가능하게 하였고, 이들 서비스 간에 흐르는 트래픽을 추적하고 관리하려는 목적으로 서비스 메시를 사용한다.
(어플리케이션 레벨이 아니라) 인프라 레벨에서 1) 트래픽 관리 2) observability 3) 보안 강화의 기능을 제공한다.
refs 실무자를 위한 서비스 메시 - 지금 서비스 메시가 의미 있는 이유 links Istio Envoy 
          
          
        
      </description>
    </item>
    
    <item>
      <title>API Gateway 패턴</title>
      <link>https://chankoo.github.io/posts/api-gateway-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Thu, 18 May 2023 20:29:43 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/api-gateway-%ED%8C%A8%ED%84%B4/</guid>
      <description>
        
          
            content API Gateway Pattern 을 정확히 이해하자 MSA에 API Gateway Pattern이 필수적임 API Gateway Pattern은 API Gateway Framework와는 무관함 내부 api를 제공(단순 라우팅)할 용도로 API Gateway Framework를 쓰지말자 -&amp;gt; controller와 facade가 없는 프레젠테이션 레이어를 구현하게됨 인가 로직이 비즈니스 레이어(각각의 마이크로서비스)에 들어가야해서 오염됨 로직 구현의 책임을 잘못된 곳에 전가함 클라이언트가 여러 로직을 직접 호출하여 조합하거나 특정 서비스가 자신의 도메인인 것처럼 다른 서비스를 호출하여 구현하는 문제 클라이언트와 비즈니스 레이어의 강결합 클라이언트 성능 저하 내부 서비스의 프로토콜 제약 클라이언트에 응답할 수 있는 Http api 로 고정됨 {{ $image := resources.
          
          
        
      </description>
    </item>
    
    <item>
      <title>CQRS</title>
      <link>https://chankoo.github.io/posts/cqrs/</link>
      <pubDate>Mon, 12 Dec 2022 23:09:46 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/cqrs/</guid>
      <description>
        
          
            content Command와 Query를 다른 것으로 보고 명시적으로 분리하는 패턴. OOP 관점에서 Command를 담당하는 객체와, Query를 담당하는 객체의 책임을 분리하는 것으로 이해하면된다.
MSA, DDD, 이벤트 소싱 등 다른 기술과 함께 활용되며 다양하게 구현한다.
특히 마이크로 서비스로 분리한 아키텍처에서는 Query가 어려운데, 여러 서비스에 흩어진 데이터를 조회하는 비용이 크기 때문이다. 그래서 Query 효율을 높이는 관점에서 CQRS를 많이 활용한다.
refs 마이크로서비스 패턴 links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>2PC</title>
      <link>https://chankoo.github.io/posts/2pc/</link>
      <pubDate>Tue, 06 Dec 2022 23:29:16 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/2pc/</guid>
      <description>
        
          
            content 2단계 커밋(Two Phase Commit) 으로 분산 트랜잭션 환경에서 트랜잭션을 구현하는 방법이다. 트랜잭션의 커밋을 준비와 실제 동작의 2단계로 나누어, 분산 환경에서 커밋 준비가 완료되면 비로소 실제 커밋을 하는 방식이다.
2PC 에서 원자성은 2개의 되돌릴 수 없는 포인트에 의해 결정되는데, 1) 참여자가 준비 단계에서 커밋 가능하다고 답변하는 시점과 2) 코디네이터(리소스 매니저)가 커밋하는 시점이다. 1)과 2) 가 만족되면 참여자의 커밋이 어떤 사유로 실패하든, 반복적으로 커밋을 시도한다.
트랜잭션에 관여하는 모든 서비스가 정상 동작해야하는 가용성 이슈와, 동기적으로 동작하는 성능 이슈 때문에 지고 있는 추세이다.
          
          
        
      </description>
    </item>
    
    <item>
      <title>Saga 패턴</title>
      <link>https://chankoo.github.io/posts/saga-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Tue, 06 Dec 2022 23:22:59 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/saga-%ED%8C%A8%ED%84%B4/</guid>
      <description>
        
          
            content 분산 트랜잭션 환경에서 서비스 간 비동기 메시징을 이용하여 편성한 일련의 로컬 트랜잭션.
각 서비스가 변경분 커밋을 수행하고 완료 메시지를 발행하여 다음 서비스의 트랜잭션을 유도한다. 마찬가지로 각 서비스는 보상 트랜잭션(compensatable transaction)을 통해 문제 발생 시 변경분을 발생 역순으로 undo하도록해 롤백한다.
분상 환경에서 메시징을 이용하는 특성상, saga 그 자체로는 엄격한 Isolation을 제공할 수 없다. 메시지 읽고 처리하는 행위를 격리하기 힘들기에, 메시지 읽는 순서가 바뀐다든지 하는 이슈로 트랜잭션의 결과가 상이한 문제가 생길 수 있는 것이다.
          
          
        
      </description>
    </item>
    
    <item>
      <title>분산 트랜잭션</title>
      <link>https://chankoo.github.io/posts/%EB%B6%84%EC%82%B0-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/</link>
      <pubDate>Tue, 06 Dec 2022 23:14:00 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%EB%B6%84%EC%82%B0-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/</guid>
      <description>
        
          
            content 트랜잭션의 속성(ACID)을 2개 이상으로 분산된 네트워크에서도 만족시키는 트랜잭션.
X/Open DTP(XA) 모델이라는 표준이 있으며, 이는 2단계 커밋(2PC)를 활용하여 각 리소스를 트랜잭션으로 관리한다. 요즘엔 2PC 대신 Saga 패턴을 쓰는 추세이다.
refs 분산 트랜잭션 - 위키백과, 우리 모두의 백과사전 X/Open XA - 위키백과, 우리 모두의 백과사전 마이크로서비스 패턴 links Transaction 2PC Saga 패턴 
          
          
        
      </description>
    </item>
    
    <item>
      <title>마이크로서비스 패턴</title>
      <link>https://chankoo.github.io/posts/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Sun, 27 Nov 2022 16:20:28 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4-%ED%8C%A8%ED%84%B4/</guid>
      <description>
        
          
            content refs links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>ISP</title>
      <link>https://chankoo.github.io/posts/isp/</link>
      <pubDate>Sun, 30 Oct 2022 19:08:11 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/isp/</guid>
      <description>
        
          
            content 인터페이스 분리 원칙; Interface Separation Principle 인터페이스를 분리하여, 요소가 사용하는 인터페이스에만 의존하도록 설계해야한다.
refs 클린 아키텍처 links SOLID 
          
          
        
      </description>
    </item>
    
    <item>
      <title>LSP</title>
      <link>https://chankoo.github.io/posts/lsp/</link>
      <pubDate>Sun, 30 Oct 2022 17:51:17 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/lsp/</guid>
      <description>
        
          
            content 리스코프 치환 원칙; Liskov Subsitution Principle 상위 타입 객체는 하위 타입 객체로 별도 조작 없이 치환 가능해야한다.
객체 지향 언어는 다형성을 제공하기에, LSP를 지킨 설계를 활용하기 유리하다. 사용할 하위 타입을 런타임에 선택하여 상위 타입을 대체하기 용이하다.
LSP를 위반하면 OCP를 위반하는 것이다. 하위 타입을 추가(확장)하여 상위 타입을 바로 대체할 수 없기 때문이다. LSP를 위반한다면 보통 해당 객체를 사용하는 클라이언트 코드를 수정해야한다. 그리고 이 수정은 끔찍한 형태로 의존을 낳는다. 흔히 드는 예시가 직사각형을 상속한 정사각형 인데, 정사각형은 반드시 너비와 높이가 일치해야하므로 직사각형 객체를 대체할 수 없다.
          
          
        
      </description>
    </item>
    
    <item>
      <title>OCP</title>
      <link>https://chankoo.github.io/posts/ocp/</link>
      <pubDate>Fri, 28 Oct 2022 00:36:16 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/ocp/</guid>
      <description>
        
          
            content 개방-폐쇄 원칙; Open Close Principle 소프트웨어 요소는 확장에는 open, 수정에는 close여야 한다. 수정 보다 비용이 적은 확장으로 소프트웨어를 수정해야한다.
OCP를 지키기 위해서는 의존 관계를 잘 설계해야한다. 의존 관계가 확장 가능한 요소와 수정해야하는 요소를 결정짓기 때문인데, A -&amp;gt; B (A가 B에 의존)이라면 A는 확장 가능한 요소이고 B는 수정해야하는 요소가 되는 것이다.
이를 위해 DIP를 지켜야한다. 추상 보다 구현의 변화가 많은데, 구현이 추상에 의존해야 구현을 확장할 수 있기 때문이다.
모듈 레벨(OOP 클래스)에만 적용되는 원칙이 아니다.
          
          
        
      </description>
    </item>
    
    <item>
      <title>모듈</title>
      <link>https://chankoo.github.io/posts/%EB%AA%A8%EB%93%88/</link>
      <pubDate>Thu, 27 Oct 2022 22:23:08 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%EB%AA%A8%EB%93%88/</guid>
      <description>
        
          
            content 설계 시점에 다루는 코드 덩어리. 시점상 가장 먼저 구현하는 단위
refs 개발자에서 아키텍트로 클린 아키텍처 links 컴포넌트 
          
          
        
      </description>
    </item>
    
    <item>
      <title>개발자에서 아키텍트로</title>
      <link>https://chankoo.github.io/posts/%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%97%90%EC%84%9C-%EC%95%84%ED%82%A4%ED%85%8D%ED%8A%B8%EB%A1%9C/</link>
      <pubDate>Thu, 27 Oct 2022 22:16:50 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%97%90%EC%84%9C-%EC%95%84%ED%82%A4%ED%85%8D%ED%8A%B8%EB%A1%9C/</guid>
      <description>
        
          
            content 아키텍트는 기술과 비즈니스 그리고 사용자를 모두 이해해야한다. 유저영역의 문제를 엔지니어링 관점에서 정의하여 소프트웨어 아키텍처를 설계한다. 아키텍처는 품질 속성과 기술 부채를 고려하여 시스템을 요소로 분리해야한다. 그리고 큰 그림 속에서 요소들을 연결하고 통합한다. 아키텍트로서 프로젝트 정리 이해관계자들은 누구였고 주요 비즈니스 목표는 무엇이었는가 최종적으로 어떤 결과를 도출했는가 어떤 기술을 사용했는가 가장 큰 리스크는 무엇이었고, 어떻게 극복했는가 다시 시작할 수 있다면 어떤 점을 다르게 하겠는가 refs links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>SOLID</title>
      <link>https://chankoo.github.io/posts/solid/</link>
      <pubDate>Thu, 27 Oct 2022 22:13:29 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/solid/</guid>
      <description>
        
          
            content 모듈 수준의 소프트웨어 설계 원칙.
SRP OCP LSP ISP DIP
refs 클린 아키텍처 links 모듈 
          
          
        
      </description>
    </item>
    
    <item>
      <title>SRP</title>
      <link>https://chankoo.github.io/posts/srp/</link>
      <pubDate>Thu, 27 Oct 2022 22:10:27 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/srp/</guid>
      <description>
        
          
            content 단일 책임 원칙 - Single Responsibility Principle 모듈은 한 액터(사용자, 이해관계자)만 책임진다. 모듈을 변경한다면 그 이유는 반드시 한 액터 때문이어야 한다.
SRP를 따르면, 여러 액터의 요구를 책임지는 모듈은 책임을 찢어야 한다.
예를 들어 클래스 Employee가 재무팀을 위한 급여 계산 / 인사팀을 위한 업무 시간 계산을 책임지고 있다면, 이는 SRP를 위반한다. 그래서 -&amp;gt; 급여 계산을 위한 클래스와 업무 시간 계산을 위한 클래스로 책임을 분리하고, EmployeeFacade 클래스를 두어 인터페이스를 정리할 수 있다.
          
          
        
      </description>
    </item>
    
    <item>
      <title>GoF의 디자인 패턴</title>
      <link>https://chankoo.github.io/posts/gof%EC%9D%98-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Thu, 27 Oct 2022 22:09:42 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/gof%EC%9D%98-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/</guid>
      <description>
        
          
            content refs links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>DIP</title>
      <link>https://chankoo.github.io/posts/dip/</link>
      <pubDate>Thu, 06 Oct 2022 23:42:10 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/dip/</guid>
      <description>
        
          
            content Dependency Inversion Principle(의존성 역전 원칙) 더 구체적인(하위 계층) 모듈에 의존하는 일반적(절차적)인 의존성의 흐름을 역전 시켜 더 추상적인(상위 계층) 모듈에 의존하도록해야한다.
추상 팩토리 패턴이 대표적이다. 객체 생성을 위해 구체 팩토리에 의존(요소 -&amp;gt; 팩토리)하는 것이 아니라, 추상 팩토리에 의존(요소 -&amp;gt; 추상 팩토리 $\Leftarrow$ 구체 팩토리)하는 것이다.
refs 클린 아키텍처 links SOLID 추상 팩토리 패턴 
          
          
        
      </description>
    </item>
    
    <item>
      <title>DI</title>
      <link>https://chankoo.github.io/posts/di/</link>
      <pubDate>Thu, 06 Oct 2022 23:33:48 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/di/</guid>
      <description>
        
          
            content Dependency Injection(의존성 주입) 클라이언트에서 사용할 의존성을 외부에서 넣어주는 일
refs links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>IOC</title>
      <link>https://chankoo.github.io/posts/ioc/</link>
      <pubDate>Thu, 06 Oct 2022 22:45:02 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/ioc/</guid>
      <description>
        
          
            content Inversion Of Control(제어 역전) 클라이언트(프로그래머)가 직접 사용할 의존성을 제어하는 상황(일반적, 절차적) -&amp;gt; 누군가(프레임워크)가 의존성을 정해주는(DI, DIP 등으로) 상황(역전)
refs 학습 페이지 [Study]IoC, DI, DIP 개념 잡기 - 기록은 기억을 지배한다 links DI DIP 
          
          
        
      </description>
    </item>
    
    <item>
      <title>클린 아키텍처</title>
      <link>https://chankoo.github.io/posts/%ED%81%B4%EB%A6%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/</link>
      <pubDate>Tue, 04 Oct 2022 21:43:18 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%ED%81%B4%EB%A6%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/</guid>
      <description>
        
          
            content refs links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>MVVM</title>
      <link>https://chankoo.github.io/posts/mvvm/</link>
      <pubDate>Mon, 03 Oct 2022 13:02:32 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/mvvm/</guid>
      <description>
        
          
            content View -&amp;gt; ViewModel -&amp;gt; Model 의 구조. View 를 그리기 위한 데이터와 비즈니스 로직을 ViewModel에 모두 담아 View와 Model 결합을 끊는다. MVC(UIKit) 를 이용하던 iOS 개발의 대세 흐름이 MVVM(SwiftUI)을 이용하는 것으로 변했는데, MVC에 비해 각 계층이 더 잘 분리되어 유지보수와 테스트가 더 용이하다. MVVM은 View가 ViewModel을, ViewModel이 Model을 소유하는 방식인데, MVC의 ViewController가 Model과 View를 모두 떠맡아 비대해지는 이슈를 해결하는 구조이다. 화면을 VC 단위로 구성하는 것이 아니라, View가 필요한 비즈니스 로직(ViewModel)을 가져와 사용하는 것이다.
          
          
        
      </description>
    </item>
    
    <item>
      <title>Container-Presenter 패턴</title>
      <link>https://chankoo.github.io/posts/container-presenter-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Mon, 03 Oct 2022 12:37:15 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/container-presenter-%ED%8C%A8%ED%84%B4/</guid>
      <description>
        
          
            content 리액트에서 로직과 뷰 컴포넌트를 분리하는 패턴. 데이터를 가져오고 가공하는 컨테이너 컴포넌트와, 데이터를 렌더링하는 프레젠터 컴포넌트로 나눈다.
aka Smart &amp;amp; Dumb conponents 대개 컨테이너는 렌더링하는 컴포넌트 외에 다른 ui는 렌더링하지 않으며, 프레젠터는 컨테이너로 부터 데이터를 받아 단순히 렌더링 한다.
관심사 분리를 통해 재사용성 높은 순수한 프레젠터 컴포넌트를 만드는 이점이 있으며, 테스트가 쉬워서 험블 객체 패턴을 따랐다고도 볼 수 있겠다.
반면 데이터 가져오는 역할을 hook이 점차 대체하며, 굳이 컨테이너 컴포넌트를 두는게 불필요하다는 의견도 늘고있다.
          
          
        
      </description>
    </item>
    
  </channel>
</rss>
