<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>아키텍처 on </title>
    <link>https://chankoo.github.io/categories/%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/</link>
    <description>Recent content in 아키텍처 on </description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright>
    <lastBuildDate>Wed, 22 Nov 2023 17:46:10 +0900</lastBuildDate><atom:link href="https://chankoo.github.io/categories/%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>비동기</title>
      <link>https://chankoo.github.io/posts/%EB%B9%84%EB%8F%99%EA%B8%B0/</link>
      <pubDate>Wed, 22 Nov 2023 17:46:10 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%EB%B9%84%EB%8F%99%EA%B8%B0/</guid>
      <description>
        
          
            content 동기적이지 않은 것(asynchronous)을 의미한다.
동기적이라는 건 작업들을 순차적으로 진행함을 의미하는데, 한 작업이 끝나기를 기다려야하는 속성이 있다. 반면에 비동기는 한 작업이 끝나기를 기다리지 않고 다른 작업을 진행하는 것을 말하며, 동기적이지 않은 모든 방식을 의미한다.
비동기의 예시 non-block I/O - 요청을 block하는 작업이 아니기에 I/O를 기다리는 동안 다른 작업을 처리할 수 있다. 멀티 스레딩 - 여러 작업을 각 스레드가 나누어 진행하기에 동기적이지 않다. block I/O 작업이라도 비동기로 진행할 수 있다 refs 비동기 프로그래밍, 비동기 I/O, 비동기 커뮤니케이션.
          
          
        
      </description>
    </item>
    
    <item>
      <title>ISP</title>
      <link>https://chankoo.github.io/posts/isp/</link>
      <pubDate>Sun, 30 Oct 2022 19:08:11 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/isp/</guid>
      <description>
        
          
            content 인터페이스 분리 원칙; Interface Separation Principle 인터페이스를 분리하여, 요소가 사용하는 인터페이스에만 의존하도록 설계해야한다.
refs 클린 아키텍처 links SOLID 
          
          
        
      </description>
    </item>
    
    <item>
      <title>LSP</title>
      <link>https://chankoo.github.io/posts/lsp/</link>
      <pubDate>Sun, 30 Oct 2022 17:51:17 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/lsp/</guid>
      <description>
        
          
            content 리스코프 치환 원칙; Liskov Subsitution Principle 상위 타입 객체는 하위 타입 객체로 별도 조작 없이 치환 가능해야한다.
객체 지향 언어는 다형성을 제공하기에, LSP를 지킨 설계를 활용하기 유리하다. 사용할 하위 타입을 런타임에 선택하여 상위 타입을 대체하기 용이하다.
LSP를 위반하면 OCP를 위반하는 것이다. 하위 타입을 추가(확장)하여 상위 타입을 바로 대체할 수 없기 때문이다. LSP를 위반한다면 보통 해당 객체를 사용하는 클라이언트 코드를 수정해야한다. 그리고 이 수정은 끔찍한 형태로 의존을 낳는다. 흔히 드는 예시가 직사각형을 상속한 정사각형 인데, 정사각형은 반드시 너비와 높이가 일치해야하므로 직사각형 객체를 대체할 수 없다.
          
          
        
      </description>
    </item>
    
    <item>
      <title>모듈</title>
      <link>https://chankoo.github.io/posts/%EB%AA%A8%EB%93%88/</link>
      <pubDate>Thu, 27 Oct 2022 22:23:08 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%EB%AA%A8%EB%93%88/</guid>
      <description>
        
          
            content 설계 시점에 다루는 코드 덩어리. 시점상 가장 먼저 구현하는 단위
refs 개발자에서 아키텍트로 links 컴포넌트 
          
          
        
      </description>
    </item>
    
    <item>
      <title>SOLID</title>
      <link>https://chankoo.github.io/posts/solid/</link>
      <pubDate>Thu, 27 Oct 2022 22:13:29 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/solid/</guid>
      <description>
        
          
            content 모듈 수준의 소프트웨어 설계 원칙.
SRP OCP LSP ISP DIP
refs 클린 아키텍처 links 모듈 
          
          
        
      </description>
    </item>
    
    <item>
      <title>SRP</title>
      <link>https://chankoo.github.io/posts/srp/</link>
      <pubDate>Thu, 27 Oct 2022 22:10:27 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/srp/</guid>
      <description>
        
          
            content 단일 책임 원칙 - Single Responsibility Principle 모듈은 한 액터(사용자, 이해관계자)만 책임진다. 모듈을 변경한다면 그 이유는 반드시 한 액터 때문이어야 한다.
SRP를 따르면, 여러 액터의 요구를 책임지는 모듈은 책임을 찢어야 한다.
예를 들어 클래스 Employee가 재무팀을 위한 급여 계산 / 인사팀을 위한 업무 시간 계산을 책임지고 있다면, 이는 SRP를 위반한다. 그래서 -&amp;gt; 급여 계산을 위한 클래스와 업무 시간 계산을 위한 클래스로 책임을 분리하고, EmployeeFacade 클래스를 두어 인터페이스를 정리할 수 있다.
          
          
        
      </description>
    </item>
    
    <item>
      <title>DIP</title>
      <link>https://chankoo.github.io/posts/dip/</link>
      <pubDate>Thu, 06 Oct 2022 23:42:10 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/dip/</guid>
      <description>
        
          
            content Dependency Inversion Principle(의존성 역전 원칙) 더 구체적인(하위 계층) 모듈에 의존하는 일반적(절차적)인 의존성의 흐름을 역전 시켜 더 추상적인(상위 계층) 모듈에 의존하도록해야한다.
추상 팩토리 패턴이 대표적이다. 객체 생성을 위해 구체 팩토리에 의존(요소 -&amp;gt; 팩토리)하는 것이 아니라, 추상 팩토리에 의존(요소 -&amp;gt; 추상 팩토리 $\Leftarrow$ 구체 팩토리)하는 것이다.
refs 클린 아키텍처 links SOLID 추상 팩토리 패턴 
          
          
        
      </description>
    </item>
    
    <item>
      <title>DI</title>
      <link>https://chankoo.github.io/posts/di/</link>
      <pubDate>Thu, 06 Oct 2022 23:33:48 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/di/</guid>
      <description>
        
          
            content Dependency Injection(의존성 주입) 클라이언트에서 사용할 의존성을 외부에서 넣어주는 일
refs links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>IOC</title>
      <link>https://chankoo.github.io/posts/ioc/</link>
      <pubDate>Thu, 06 Oct 2022 22:45:02 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/ioc/</guid>
      <description>
        
          
            content Inversion Of Control(제어 역전) 클라이언트(프로그래머)가 직접 사용할 의존성을 제어하는 상황(일반적, 절차적) -&amp;gt; 누군가(프레임워크)가 의존성을 정해주는(DI, DIP 등으로) 상황(역전)
refs 학습 페이지 [Study]IoC, DI, DIP 개념 잡기 - 기록은 기억을 지배한다 links DI DIP 
          
          
        
      </description>
    </item>
    
    <item>
      <title>MVVM</title>
      <link>https://chankoo.github.io/posts/mvvm/</link>
      <pubDate>Mon, 03 Oct 2022 13:02:32 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/mvvm/</guid>
      <description>
        
          
            content View -&amp;gt; ViewModel -&amp;gt; Model 의 구조. View 를 그리기 위한 데이터와 비즈니스 로직을 ViewModel에 모두 담아 View와 Model 결합을 끊는다. MVC(UIKit) 를 이용하던 iOS 개발의 대세 흐름이 MVVM(SwiftUI)을 이용하는 것으로 변했는데, MVC에 비해 각 계층이 더 잘 분리되어 유지보수와 테스트가 더 용이하다. MVVM은 View가 ViewModel을, ViewModel이 Model을 소유하는 방식인데, MVC의 ViewController가 Model과 View를 모두 떠맡아 비대해지는 이슈를 해결하는 구조이다. 화면을 VC 단위로 구성하는 것이 아니라, View가 필요한 비즈니스 로직(ViewModel)을 가져와 사용하는 것이다.
          
          
        
      </description>
    </item>
    
    <item>
      <title>Container-Presenter 패턴</title>
      <link>https://chankoo.github.io/posts/container-presenter-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Mon, 03 Oct 2022 12:37:15 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/container-presenter-%ED%8C%A8%ED%84%B4/</guid>
      <description>
        
          
            content 리액트에서 로직과 뷰 컴포넌트를 분리하는 패턴. 데이터를 가져오고 가공하는 컨테이너 컴포넌트와, 데이터를 렌더링하는 프레젠터 컴포넌트로 나눈다.
aka Smart &amp;amp; Dumb conponents 대개 컨테이너는 렌더링하는 컴포넌트 외에 다른 ui는 렌더링하지 않으며, 프레젠터는 컨테이너로 부터 데이터를 받아 단순히 렌더링 한다.
관심사 분리를 통해 재사용성 높은 순수한 프레젠터 컴포넌트를 만드는 이점이 있으며, 테스트가 쉬워서 험블 객체 패턴을 따랐다고도 볼 수 있겠다.
반면 데이터 가져오는 역할을 hook이 점차 대체하며, 굳이 컨테이너 컴포넌트를 두는게 불필요하다는 의견도 늘고있다.
          
          
        
      </description>
    </item>
    
  </channel>
</rss>
