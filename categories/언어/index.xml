<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>언어 on chankoo</title>
    <link>https://chankoo.github.io/categories/%EC%96%B8%EC%96%B4/</link>
    <description>Recent content in 언어 on chankoo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 30 Nov 2023 16:18:53 +0900</lastBuildDate><atom:link href="https://chankoo.github.io/categories/%EC%96%B8%EC%96%B4/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>콜백 함수</title>
      <link>https://chankoo.github.io/posts/%EC%BD%9C%EB%B0%B1-%ED%95%A8%EC%88%98/</link>
      <pubDate>Thu, 30 Nov 2023 16:18:53 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%EC%BD%9C%EB%B0%B1-%ED%95%A8%EC%88%98/</guid>
      <description>
        
          
            content 인자로 다른 함수에게 전달되는 함수.
refs links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>Active Record</title>
      <link>https://chankoo.github.io/posts/active-record/</link>
      <pubDate>Wed, 22 Nov 2023 23:08:32 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/active-record/</guid>
      <description>
        
          
            content DB row의 wrapper 객체로 데이터에 대한 접근과 도메인 로직을 함께 구현해놓는 방식이다.
refs P of EAA: Active Record Fetching Title#kql4 links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>리액티브 프로그래밍</title>
      <link>https://chankoo.github.io/posts/%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/</link>
      <pubDate>Thu, 01 Jun 2023 16:39:03 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/</guid>
      <description>
        
          
            content 데이터 스트림에 영향을 미치는 모든 변경 사항을 observer 들에게 전파하는 프로그래밍
리액티브 매니페스토
반응성(responsive) : 리액티브 시스템은 빠를 뿐 아니라 + 일정하고 예상가능한 반응 시간을 제공한다. 회복성(resilient) : 장애가 발생해도 시스템은 반응해야한다. 여러 컴포넌트의 시간과 공간 분리 (즉, 컴포넌트가 각각 독립적인 생명주기를 갖고 다른 프로세스에서 실행), 작업 위임시 비동기적으로 위임하는 등의 기법이 있다. 탄력성(elastic) : 애플리케이션의 생명주기 동안 다양한 부하를 받는데 이때 리액티브 시스템에서는 자동으로 관련 컴포넌트에 할당된 자원 수를 늘린다.
          
          
        
      </description>
    </item>
    
    <item>
      <title>생성자</title>
      <link>https://chankoo.github.io/posts/%EC%83%9D%EC%84%B1%EC%9E%90/</link>
      <pubDate>Wed, 12 Oct 2022 11:19:58 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%EC%83%9D%EC%84%B1%EC%9E%90/</guid>
      <description>
        
          
            content 객체를 초기화하고, 멤버 변수를 할당하여 객체를 (개념적으로)생성하는 서브루틴.
python의 예를 들면, python 객체는 new 를 통해 메모리에 할당되며, init 을 통해 멤버 변수를 정의한다. (개념적인) 객체의 생성이 init 을 통해 이루어졌으므로, init 이 python의 생성자라 할 수 있다.
refs Constructor (object-oriented programming) - Wikipedia Object lifetime - Wikipedia Python: __init__() is not the only constructor - DEV Community links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>ASGI</title>
      <link>https://chankoo.github.io/posts/asgi/</link>
      <pubDate>Tue, 11 Oct 2022 21:00:21 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/asgi/</guid>
      <description>
        
          
            content Asynchronous Server Gateway Interface. 파이썬 웹 애플리케이션과 웹 서버의 공통 인터페이스를 기술한 프로토콜.
WSGI 처럼, 프로토콜 서버 내 앱들에게 표준화된 요청/응답을 주고받는 방식이나, ASGI는 비동기 방식으로 이벤트를 주고 받는 구조적인 차이가 있다.
refs ASGI (Asynchronous Server Gateway Interface) Specification — ASGI 3.0 documentation &amp;ldquo;파이썬 웹 개발의 미래&amp;rdquo; ASGI의 개념과 활용 방법 - ITWorld Korea links WSGI 
          
          
        
      </description>
    </item>
    
    <item>
      <title>WSGI</title>
      <link>https://chankoo.github.io/posts/wsgi/</link>
      <pubDate>Tue, 11 Oct 2022 21:00:21 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/wsgi/</guid>
      <description>
        
          
            content WSGI(Web Server Gateway Interface) 는 파이썬 웹앱과 웹서버 간 통신 인터페이스 명세이다.
refs links ASGI gunicorn 
          
          
        
      </description>
    </item>
    
    <item>
      <title>dis</title>
      <link>https://chankoo.github.io/posts/dis/</link>
      <pubDate>Sun, 09 Oct 2022 22:02:55 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/dis/</guid>
      <description>
        
          
            content 파이썬 바이트코드 역 어셈블러. CPython의 바이트 코드를 역 어셈블하여 바이트 코드 레벨의 분석을 돕는 모듈이다.
ex)
def hi(x): x += 1 print(x) return x 위 정의에 따르면, 추상화한 바이트코드를 바이트코드로 바꾸는 것도 어셈블이라 볼 수 있다.
refs dis &amp;mdash; 파이썬 바이트 코드 역 어셈블러 — 파이썬 설명서 주석판 links Bytecode Assembler 
          
          
        
      </description>
    </item>
    
    <item>
      <title>UseEffect</title>
      <link>https://chankoo.github.io/posts/useeffect/</link>
      <pubDate>Thu, 06 Oct 2022 13:18:27 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/useeffect/</guid>
      <description>
        
          
            content 함수형 컴포넌트에서 이펙트를 정의하는 훅. 렌더링 후 리액트가 내부의 함수를 실행한다. 리액트는 각 렌더링 마다 deps 배열을 비교하여 이펙트 내 함수 실행 여부를 따진다.
refs links 함수형 컴포넌트 
          
          
        
      </description>
    </item>
    
    <item>
      <title>함수형 컴포넌트</title>
      <link>https://chankoo.github.io/posts/%ED%95%A8%EC%88%98%ED%98%95-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/</link>
      <pubDate>Thu, 06 Oct 2022 01:40:37 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%ED%95%A8%EC%88%98%ED%98%95-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/</guid>
      <description>
        
          
            content react의 함수형 컴포넌트는 당연하게도 함수형 프로그래밍의 패러다임을 따른다. 컴포넌트 내 state는 불변하며, setState는 새 state로 컴포넌트 함수를 다시 호출한다. 그때마다 다시 렌더링되는 것이고 각 렌더링은 고유의 함수(핸들러, 이펙트)를 가진다.
refs useEffect 완벽 가이드 — Overreacted links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>why numpy array</title>
      <link>https://chankoo.github.io/posts/why-numpy-array/</link>
      <pubDate>Mon, 03 Oct 2022 16:17:54 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/why-numpy-array/</guid>
      <description>
        
          
            content 파이썬의 list 보다 np array가
더 빠르다 element로 PyObject 대신 value를 들고 있어 직접 접근할 수 있다. 메모리 효율이 좋다. element의 크기가 작다 PyObject - 4 for type pointer, 4 for reference count, 4 for value &amp;ndash; and the memory allocators rounds up to 16 value - single-precision numbers takes 4 bytes each, double-precision ones, 8 bytes 동적배열 아니어서 크기가 고정이며 정적할당하여 element 타입이 고정이다 refs links PyObject Dynamic Array 
          
          
        
      </description>
    </item>
    
    <item>
      <title>Python-GC</title>
      <link>https://chankoo.github.io/posts/python-gc/</link>
      <pubDate>Mon, 03 Oct 2022 16:08:52 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/python-gc/</guid>
      <description>
        
          
            content 파이썬(CPython)에서는 아래 두가지 객체에 대해 가비지 컬렉션을 실행한다.
PyObject의 ref count가 0
순환 참조가 발생했고 그 외의 참조는 없음
예제 l = [] l.append(l) del l refs Python GC가 작동하는 원리 links 가비지 컬렉션 PyObject 
          
          
        
      </description>
    </item>
    
    <item>
      <title>GIL</title>
      <link>https://chankoo.github.io/posts/gil/</link>
      <pubDate>Mon, 03 Oct 2022 15:57:13 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/gil/</guid>
      <description>
        
          
            content 파이썬 객체의 레퍼런스 카운팅이 정상적으로 동작하도록, 인터프리터의 동작을 전역적으로 통제하는 락. 여러 스레드가 한 객체의 레퍼런스 카운트를 조작하는 동시성 을 제어하기위해, GIL 을 가진 스레드만 자원을 통제할 수 있다.
더 구체적으로 말하면, 멀티 스레딩 환경에서 각 스레드는 레퍼런스 카운팅을 위해 PyObject 의 ob_refcnt를 조작하는데, 이는 race condition이다. race condition 해결을 위해 일반적인 mutex 를 사용하자니 각 객체 마다 락이 필요하고, deadlock 의 리스크도 존재한다. 그래서 파이썬(CPython)은 GIL을 통해 인터프리터 자체를 잠가버렸다.
          
          
        
      </description>
    </item>
    
    <item>
      <title>PyObject</title>
      <link>https://chankoo.github.io/posts/pyobject/</link>
      <pubDate>Mon, 03 Oct 2022 15:37:15 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/pyobject/</guid>
      <description>
        
          
            content 일반적인 CPython 구현체를 가정했을때, 파이썬의 메모리 관리 알고리즘은 C로 쓰여졌고, 이해를 위해서는 CPython 의 내부 구현을 알아야한다.
모든 파이썬 객체는 PyObject라는 c struct 를 확장하여 가지고 있다.
ob_type 은 해당 객체의 타입 오브젝트(PyTypeObject)를 가리키는 포인터이다. PyTypeObject 역시 c struct 이며 특정 타입(int, dict 등)에 대한 메타 데이터를 가진다. ob_refcnt 는 객체를 참조하는 레퍼런스의 수를 저장한다. refs Memory Management in Python – Real Python links CPython 
          
          
        
      </description>
    </item>
    
    <item>
      <title>Cython</title>
      <link>https://chankoo.github.io/posts/cython/</link>
      <pubDate>Mon, 03 Oct 2022 13:54:50 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/cython/</guid>
      <description>
        
          
            content Cython: C-Extension for Python C로 파이썬의 확장 모듈을 구현하기 위해 설계한 컴파일 언어. C와 파이썬의 superset이며 표준 C/C++ 컴파일러를 이용한다. 이러한 특성은 파이썬 언어의 높은 생산성을 활용하면서 실행 속도의 향상을 가져온다.
refs 사이썬 - 위키백과, 우리 모두의 백과사전 links CPython 컴파일러 
          
          
        
      </description>
    </item>
    
    <item>
      <title>CPython</title>
      <link>https://chankoo.github.io/posts/cpython/</link>
      <pubDate>Mon, 03 Oct 2022 13:40:56 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/cpython/</guid>
      <description>
        
          
            content C로 구현한 파이썬 인터프리터 시스템. 파이썬 언어로 쓰인 스크립트를 바이트코드(.pyc, pycache)로 컴파일한 후, 인터프리터로 실행한다.
refs CPython 파헤치기: 따라 하면서 이해하는 파이썬 내부의 동작 원리 – 도서출판 인사이트 links 인터프리터 Bytecode 
          
          
        
      </description>
    </item>
    
  </channel>
</rss>
