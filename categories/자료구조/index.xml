<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>자료구조 on </title>
    <link>https://chankoo.github.io/categories/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/</link>
    <description>Recent content in 자료구조 on </description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright>
    <lastBuildDate>Tue, 21 Nov 2023 19:33:43 +0900</lastBuildDate><atom:link href="https://chankoo.github.io/categories/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>LSM Tree</title>
      <link>https://chankoo.github.io/posts/lsm-tree/</link>
      <pubDate>Tue, 21 Nov 2023 19:33:43 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/lsm-tree/</guid>
      <description>
        
          
            content Log Structured Merge Tree는 로그성 데이터 색인을 위해 고안된 자료구조로, 정렬된 키-값 데이터인 SS테이블(Sorted String Table) 형식으로 디스크에 데이터를 저장한다.
refs 데이터 중심 애플리케이션 설계 색인(index)의 두 가지 형태 : LSM 트리 &amp;amp; B 트리 | by allocProc | Medium links B-Tree Hash 인덱스 
          
          
        
      </description>
    </item>
    
    <item>
      <title>B-Tree</title>
      <link>https://chankoo.github.io/posts/b-tree/</link>
      <pubDate>Tue, 21 Nov 2023 18:54:17 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/b-tree/</guid>
      <description>
        
          
            content BST(Binary Search Tree)를 일반화한 자료구조로 2개 이상의 자식 노드를 갖는 Balanced Tree이다.
B Tree 류 자료구조는 DB 인덱스로 많이 쓰인다. (Balanced BST인)AVL Tree, RB Tree에 비해 자식 노드 개수가 많아 디스크 접근 수가 적음 블록 단위로 메모리에 적재하는 OS 특성도 효율적으로 활용 B Tree 인덱스의 성능은 키의 크기, 키의 카디널리티, 레코드 대비 인덱스 스캔의 범위 등 다양한 요소에 영향 받는다.
디스크 I/O로 데이터를 가져오는 단위인 블록의 크기는 고정(mysql은 16KB)인데, 키의 크기가 커지면 한블록에 저장하는 키의 개수가 적어진다.
          
          
        
      </description>
    </item>
    
    <item>
      <title>해시</title>
      <link>https://chankoo.github.io/posts/%ED%95%B4%EC%8B%9C/</link>
      <pubDate>Sat, 15 Oct 2022 23:46:35 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%ED%95%B4%EC%8B%9C/</guid>
      <description>
        
          
            content 임의 길이 데이터를 해시 함수를 통해 변환한 값으로, 1) 길이가 고정이고 2) 변환 전 값을 구하는 역함수가 없다.
refs links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>Generator</title>
      <link>https://chankoo.github.io/posts/generator/</link>
      <pubDate>Wed, 12 Oct 2022 00:08:35 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/generator/</guid>
      <description>
        
          
            content 제너레이터는 제어 흐름을 양보할 수 있는 Iterator이다. 루프를 순회하는 도중 의도적으로 순회를 멈추고, 자신을 호출한 루틴으로 제어 흐름을 양보할 수 있다. 때문에 semicoroutine 이라고도 불리는데, 제어 흐름을 넘겨줄 routine을 지정할 수 있는 coroutine 의 특수한 형태이기 때문이다.
이러한 제너레이터의 동작은 1) 메모리 효율 2) 동시성 의 관점에서 살펴볼만하다. 루프 내 요소의 평가가 필요할때 메모리에 요소를 올리는 lazy evaluation 이고, 원하는 시점에 제어흐름을 넘겨가며 동시성 프로그래밍을 가능케하는 pseudo thread 이기 때문이다.
          
          
        
      </description>
    </item>
    
    <item>
      <title>Dynamic Array</title>
      <link>https://chankoo.github.io/posts/dynamic-array/</link>
      <pubDate>Mon, 03 Oct 2022 00:11:36 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/dynamic-array/</guid>
      <description>
        
          
            content python 의 list 는 dynamic array이다. 런타임에 element를 추가할때, 리스트에 할당된 메모리 공간이 모자라면 리스트 크기를 늘린다. 그런데 dynamic array도 엄연한 array 이기에 &amp;rsquo;element 가 연속된 메모리 공간을 점유한다&amp;rsquo;는 제약을 따라야한다. 그래서 python(cpython)은 요소가 추가되어 리스트 크기가 변해야할 때, 전체 list를 복사하여 더 큰(2의 거듭제곱) 공간에 통째로 재할당 한다.
이는 시간 복잡도 계산에 영향을 준다. list 에 요소를 더하는 append 나 insert 연산의 시간 복잡도를 계산할 때 메모리 재할당 시간까지 고려해야 한다는 의미다.
          
          
        
      </description>
    </item>
    
  </channel>
</rss>
