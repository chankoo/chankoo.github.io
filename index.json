[{"body":"","link":"https://chankoo.github.io/categories/","section":"categories","tags":null,"title":"Categories"},{"body":"","link":"https://chankoo.github.io/","section":"","tags":null,"title":"chankoo"},{"body":"","link":"https://chankoo.github.io/posts/","section":"posts","tags":null,"title":"Posts"},{"body":"","link":"https://chankoo.github.io/categories/%ED%85%8C%EC%8A%A4%ED%8A%B8/","section":"categories","tags":null,"title":"테스트"},{"body":"테스트 실행을 위해 필요한 초기 상태로, 객체와 환경 등 모든 것의 고정된 상태를 의미한다. 예를 들어 테스트에 db 객체가 필요하다면, 필요한 모든 데이터가 로딩 된 db 객체를 픽스처로 만들어두어야 한다.\n테스트 더블과 헷갈릴 수 있는데, 더블은 테스트 수행 중에 실제 구현을 대신하여 동작하는 구현을 의미한다. 반면에 픽스처는 테스트 수행을 위해 고정되어야할 환경으로 그 의미가 전혀 다르다. 같은 객체가 더블이면서 픽스처인 경우가 있어(ex. 픽스처로 세팅된 db Mock) 혼동이 오는데, 그 목적이 달라 사용하는 맥락에 따라 구분해야한다.\nrefs Unit Test에 나오는 Fixture와 Mock은 무엇일까? :: Carry On Progamming links 테스트 더블 ","link":"https://chankoo.github.io/posts/%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%94%BD%EC%8A%A4%EC%B2%98/","section":"posts","tags":null,"title":"테스트 픽스처"},{"body":"asyncio 라이브러리가 제공하는 잠금으로 코루틴 간 경합 상황을 해결하는 도구이다.\n멀티 스레딩 환경에서는 적합하지 않은데, 스레드 레벨에서는 점유 배제를 보장할 수 없기 때문이다. 즉, 스레드 A의 코루틴이 잠금을 획득했더라도 스레드 B의 코루틴은 영향 받지 않는다.\nrefs asyncio의 동기화수단들 · Wireframe links ","link":"https://chankoo.github.io/posts/asyncio-lock/","section":"posts","tags":["분산시스템","python","동시성"],"title":"Asyncio Lock"},{"body":"","link":"https://chankoo.github.io/tags/python/","section":"tags","tags":null,"title":"python"},{"body":"","link":"https://chankoo.github.io/tags/","section":"tags","tags":null,"title":"Tags"},{"body":"","link":"https://chankoo.github.io/tags/%EB%8F%99%EC%8B%9C%EC%84%B1/","section":"tags","tags":null,"title":"동시성"},{"body":"","link":"https://chankoo.github.io/categories/%EB%B0%B1%EC%97%94%EB%93%9C/","section":"categories","tags":null,"title":"백엔드"},{"body":"","link":"https://chankoo.github.io/tags/%EB%B6%84%EC%82%B0%EC%8B%9C%EC%8A%A4%ED%85%9C/","section":"tags","tags":null,"title":"분산시스템"},{"body":"작업 다대다 채팅을 실험했다. 같은 채팅방에 있는 유저 N명이 각자 s초 간격으로 메시지를 전송하는 상황을 가정했다.\n목표 100명의 사용자가 1초 간격으로 각자 메시지를 입력할 때, 정상적인 입출력이 가능한 시스템을 구성한다. 커넥션 유지 시간을 10초로 두고 6회의 이터레이션을 돌게함으로써 약 1분간의 부하 테스트를 진행한다.\n살펴봐야할 지표는\n커넥션 유지 - 주어진 시간 동안 100개 커넥션을 문제없이 유지하는지 RPS - 입력 RPS 100(100명 / 1초), 출력 RPS 10000(100명 * 100개 / 1초) 부하가 가능한지 결과 요약 커넥션을 유지하는 데에는 큰 부하가 없었다 사용자 수 제곱에 비례하는 출력수 때문에 부하가 크다. 환경 인프라: AWS ECS Fargate\n서버: FastApi + Uvicorn\n캐시 스토리지, 메시지큐: Redis\n테스팅: K6 + Grafana + InfluxDB\n결과 상세 작업1 N = 100, 요청 간격: 1초 -\u0026gt; 입력 RPS = 100, 출력 RPS = 10000 한 개의 Fargate 태스크(vCPU 1개, 메모리 2GB)로 테스트를 시작했다. 실패율은 0%\u001d로 100개의 웹소켓 연결을 문제없이 유지했다. 어쩌면 웹소켓 커넥션을 유지하는 것 자체는 그리 큰 비용이 아닐 수도 있겠다고 판단했다.\n하지만 입출력 메시지 일부가 누락되는 상황이 발견되었는데, 출력하는 메시지가 초당 5,690개에 그쳤기 때문이다. 예상했던, 초당 10,000개(100^2) 메시지를 받아야 했으나 57% 가량만 기록된 것이다. 입력에 성공한 메시지 기준으로 계산해보아도 70%를 밑돌았다. 총 출력 건의 기대 값은 574,100건(총 입력 5,741 건에 사용자수 100을 곱한 값)이나 395,696건으로 69% 수준에 불과했다.\n[AWS ECS Fargate 설정] 태스크: 1 태스크 CPU: 1 vCPU 태스크 메모리: 2 GB 결과\nchecks\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.: 100.00%\nws_msgs_received\u0026hellip;\u0026hellip;: 395696 5690.736973/s\nws_msgs_sent\u0026hellip;\u0026hellip;\u0026hellip;.: 5741 82.564699/s\nws_session_duration\u0026hellip;: avg=11.57s min=10.16s med=11.78s max=12.19s p(90)=12.11s p(95)=12.18s\n작업2 N = 50, 요청 간격: 0.5초 -\u0026gt; 입력 RPS = 100, 출력 RPS = 5000 출력 RPS를 5,000으로 줄여 메시지 누락의 원인을 분석했다. 그랬더니 기대 출력 건 대비 97%(285,084 / (5,862 * 50)) 수준을 보여주는 것을 확인할 수 있었다. 출력 부하가 입력 부하보다 더 큰 영향을 주는 것으로 나타났다. 출력 수가 사용자 수 N의 제곱에 비례하기 때문이다.\n결과\nchecks\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.: 100.00%\nws_msgs_received\u0026hellip;\u0026hellip;: 285084 4626.873784/s\nws_msgs_sent\u0026hellip;\u0026hellip;\u0026hellip;.: 5862 95.139447/s\nws_session_duration\u0026hellip;: avg=10.24s min=10.03s med=10.23s max=10.44s p(90)=10.36s p(95)=10.37s\n목표 부하 수준(출력 RPS 10,000)을 견디기 위해 태스크를 2개(메모리 4GB)로 확장했을 때, 입력 대비 약 96%의 출 력 메시지를 성공적으로 처리했다.\n[AWS ECS Fargate 설정] 태스크: 2 태스크 CPU: 1 vCPU 태스크 메모리: 4 GB [AWS Elasticache - redis 설정] cache.t4g.small(메모리 1.37 GiB, 네트워크 5Gbps) 결과\nchecks\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.: 100.00%\nws_msgs_received\u0026hellip;\u0026hellip;: 551920 8962.004184/s\nws_msgs_sent\u0026hellip;\u0026hellip;\u0026hellip;.: 5756 93.465169/s\nws_session_duration\u0026hellip;: avg=10.22s min=10.02s med=10.24s max=10.36s p(90)=10.31s p(95)=10.32s\n그러나 추가적인 태스크 확장으로도 비슷한 부하 수준만 견뎌냈는데, 이는 Redis의 네트워크 처리량 병목 때문이었다. 메시지큐로 사용하는 Redis에서 허용된 네트워크 대역폭이 작업 수행 수준에 근접하였고, 실제로 대역폭 한계를 초과하는 이상치를 기록했다. 아래 이미지에서 좌측 그래프에서 NetworkBandwidthOutAllowanceExceed(주황색 선)를 확인할 수 있다. 이 병목 역시 입출력의 비대칭에서 기인하는데, 입력 메시지 한개당 사용자수 만큼의 출력 메시지를 내어야하는 상황에서, 출력 네트워크 처리량이 한계를 넘어선 것이다.\nrefs sample-chat 1차 · Issue #5 · chankoo/load-testing-practices · GitHub links ","link":"https://chankoo.github.io/pages/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%94%94%EC%9E%90%EC%9D%B8-%EC%97%B0%EC%8A%B5-%EC%B1%84%ED%8C%85-%EC%84%9C%EB%B9%84%EC%8A%A4-2-%EA%B8%B0%EB%B3%B8-%EC%84%B1%EB%8A%A5-%ED%85%8C%EC%8A%A4%ED%8A%B8/","section":"pages","tags":["부하테스트","시스템디자인"],"title":"\u003c시스템 디자인 연습\u003e 채팅 서비스 2 - 기본 성능 테스트"},{"body":"","link":"https://chankoo.github.io/pages/","section":"pages","tags":null,"title":"Pages"},{"body":"","link":"https://chankoo.github.io/series/","section":"series","tags":null,"title":"Series"},{"body":"","link":"https://chankoo.github.io/tags/%EB%B6%80%ED%95%98%ED%85%8C%EC%8A%A4%ED%8A%B8/","section":"tags","tags":null,"title":"부하테스트"},{"body":"","link":"https://chankoo.github.io/series/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%94%94%EC%9E%90%EC%9D%B8-%EC%97%B0%EC%8A%B5/","section":"series","tags":null,"title":"시스템 디자인 연습"},{"body":"","link":"https://chankoo.github.io/tags/%EC%8B%9C%EC%8A%A4%ED%85%9C%EB%94%94%EC%9E%90%EC%9D%B8/","section":"tags","tags":null,"title":"시스템디자인"},{"body":"","link":"https://chankoo.github.io/tags/http/","section":"tags","tags":null,"title":"http"},{"body":"","link":"https://chankoo.github.io/tags/web/","section":"tags","tags":null,"title":"web"},{"body":"웹소켓은 stateful 하기에 웹소켓 서버의 확장을 구현하기 까다롭다.\n(다른 경우와 마찬가지로)수직보다는 수평 확장이 대개 낫다. 수직 확장은 1) 비용이 많이 들고(자원 확장의 비선형성, 때에 따라 자원 조절 불가) 2) 단일실패점이 될 위험이 있다. 메시지 공유를 위한 서버 간 채널이 필요하다. 보통 pub/sub 을 통해 각각 다른 서버에 연결된 클라이언트를 동기화한다. 로드 밸런싱 알고리즘에 대한 고려가 필요하다. 웹소켓 부하 분산은 (요청 단위 아니라) 지속적인 커넥션 단위로 동작해야한다. 그렇기에 일반적으로 많이 쓰는 라운드 로빈을 사용하면, 실제 요청량에 따라 부하 분산에 실패할 수 있다. 연결이 끊어졌을때 연결 복원 방법을 생각해두어야한다. fallback 을 고려해야한다. 웹소켓 연결을 지원하지 않는 프록시, 브라우저, 특정 방화벽 등이 존재한다. refs The challenge of scaling WebSockets [with video] | Ably Realtime Why Websockets are Hard To Scale? [Detailed Explanation] links WebSocket ","link":"https://chankoo.github.io/posts/%EC%9B%B9%EC%86%8C%EC%BC%93-%ED%99%95%EC%9E%A5%EC%84%B1/","section":"posts","tags":["web","http"],"title":"웹소켓 확장성"},{"body":"작업 여러명이 참여한 채팅방에서 메시지를 입력하고 출력하는 다대다 채팅을 구현한다. 웹소켓으로 구성한 일반적인 형태의 채팅 서버를 만들고 그 성능을 테스트했다.\n시스템 구성 AWS 기반으로 채팅 서버를 구현했다. 채팅 서버는 AWS ECS Fargate 로 배포했으며 때에 따라 확장한다. 채팅 서버 앞단에 ALB를 두어 웹소켓 트래픽을 로드 밸런싱한다. 채팅 서버의 웹소켓 엔드포인트에서 실시간으로 채팅을 입출력한다. ws://{host}/chats/ws/{channel_id} channel_id 는 채팅방 역할을 한다. 즉, 같은 channel_id 에 접속한 사용자는 메시지 입출력을 공유하는 다대다 채팅에 참여한다. 채팅 메시지 작성시 id 생성기 서버에서 id 값을 받아온다. 역시 ECS로 배포한 서비스이며 때에 따라 확장한다. snowflake-id를 사용한다. grpc로 통신한다. 채팅을 메시지큐에 발행/구독한다. AWS Elasticache Redis 의 pub/sub 을 이용한다. 채팅 서버에 웹소켓 연결을 유지하는 동안, 발행/구독하며 메시지를 입출력한다. 작성한 메시지는 우선 캐시에 저장한다. Celery로 구성한 별도 태스크 서버를 두어 메시지 저장 작업을 비동기로 진행한다. 태스크 서버는 메시지 데이터를 Redis에 캐시한다. refs 가상 면접 사례로 배우는 대규모 시스템 설계 기초 실시간 댓글 개발기(part.1) – DAU 60만 Alex 댓글의 실시간 댓글을 위한 이벤트 기반 아키텍처 – tech.kakao.com 라이브채팅 플랫폼 구현기 1탄 : 개발 언어 및 기반기술 조사 links ","link":"https://chankoo.github.io/pages/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%94%94%EC%9E%90%EC%9D%B8-%EC%97%B0%EC%8A%B5-%EC%B1%84%ED%8C%85-%EC%84%9C%EB%B9%84%EC%8A%A4-1-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/","section":"pages","tags":["부하테스트","시스템디자인"],"title":"\u003c시스템 디자인 연습\u003e 채팅 서비스 1 - 아키텍처"},{"body":"","link":"https://chankoo.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"categories","tags":null,"title":"알고리즘"},{"body":"유향 그래프의 정점을 탐색 가능한 순서로 정렬하는 알고리즘이다.\n유입 간선이 없는 정점들을 찾아 정렬된 리스트에 추가한다. 유입 간선이 없으므로 바로 탐색해도 무방한 정점들이다. 해당 정점들의 유출 간선들을 제거한다. 앞선 정점들을 방문한 상황에서는, 해당 간선들이 그 다음 탐색에 영향주지 않는다. 모든 정점을 정렬할 때 까지 1과 2를 반복한다. 불가하다면 그래프에 사이클이 존재하는 것이다. [구현 예시] from collections import defaultdict, deque indegree = defaultdict(int) for \u0008v, neighbors in G.items(): for neighbor in neighbors: indegree[neighbor] += 1 Q = deque() for v in G.keys(): if indegree[v] == 0: Q.append(v) result = [] while Q: v = Q.popleft() result.append(v) for neighbor in G[v]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: Q.append(neighbor) refs Topological sorting - Wikipedia links ","link":"https://chankoo.github.io/posts/%EC%9C%84%EC%83%81-%EC%A0%95%EB%A0%AC/","section":"posts","tags":null,"title":"위상 정렬"},{"body":"집합의 모든 값을 비트 배열에 저장한 자료형으로 특정 값이 집합에 속하는지 검사하는 용도로 쓰인다.\nm 비트 크기에 k 개의 서로 다른 해시함수를 사용해 구현한다. 해시 함수는 독립적이고 균일하게 분포해야한다.\nO(k) 시간에 새로운 값을 검사할 수 있다. k개 해시 모두 1인 경우 집합에 속하는 값이라 판단한다. 한정된 공간에서 집합이 커질 수록 긍정 오류(속하지 않으나 속한다고 판별)가 커지는 특성이 있지만, 부정 오류(속하는데 속하지 않는다 판별)는 발생하지 않아 1차적인 판별 알고리즘으로 많이 쓰인다.\nrefs 블룸 필터 - 위키백과, 우리 모두의 백과사전 Bloom Filters by Example links ","link":"https://chankoo.github.io/posts/%EB%B8%94%EB%A3%B8-%ED%95%84%ED%84%B0/","section":"posts","tags":null,"title":"블룸 필터"},{"body":"","link":"https://chankoo.github.io/categories/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/","section":"categories","tags":null,"title":"자료구조"},{"body":"컴퓨터에 음수를 저장하기 위한 일반적인 방법으로, 특정 값의 2의 보수를 그 값의 음수 표현으로 여긴다. 특정 2진수 n에 대해, n보다 한자리 큰 2의 제곱수에서 n을 빼서 구한다.\n\u0026ldquo;n의 2의 보수는 00이다\u0026rdquo; 와 같이 표현한다. 최상위 비트(MSB)를 부호 비트로 쓰는 상황(0일 때 양수 1일 때 음수를 표현)을 전제한다. 십진수 7을 예로 들면, 4비트 이진수로 표현하면 0111 이고, 0111의 2의 보수는 1001인데, 1001을 -7에 대한 표현으로 저장하는 것이다.\n1의 보수로 2의 보수 구하는 법\n이진수의 모든 비트를 반전시켜 1의 보수를 구한다. (0111 -\u0026gt; 1000) 1의 보수에 1을 더해 2의 보수를 구한다. (1000-\u0026gt; 1001) refs 2의 보수 - 위키백과, 우리 모두의 백과사전 links ","link":"https://chankoo.github.io/posts/2%EC%9D%98-%EB%B3%B4%EC%88%98/","section":"posts","tags":null,"title":"2의 보수"},{"body":"","link":"https://chankoo.github.io/categories/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0/","section":"categories","tags":null,"title":"컴퓨터구조"},{"body":"content Two Phase Locking. DB에서 직렬성을 구현하는데 널리 쓰이는 알고리즘.\n잠금을 확장과 수축의 두단계로 나누어 모든 트랜잭션이 lock을 획득한 후 차례로 unlock 하기에 직렬성을 구현할 수 있다.\nrefs 데이터 중심 애플리케이션 설계 2 Phase Locking (2PL) : 네이버 블로그 links 직렬성 ","link":"https://chankoo.github.io/posts/2pl/","section":"posts","tags":["동시성"],"title":"2PL"},{"body":"","link":"https://chankoo.github.io/categories/db/","section":"categories","tags":null,"title":"DB"},{"body":"Domain과 Model Domain은 사용자가 SW를 사용하는 대상 영역을 말한다 SW의 본질은 (해당 도메인에서)사용자의 문제를 해결하는 것이다 그러므로 개발은 사용자 활동에 관련한 지식 체계에 집중해야 한다 지식의 양이 방대하므로 Model을 통해 추상화한다 Model의 유용성 모델과 핵심 설계는 서로 영향을 주며 구체화된다 유지보수와 계속되는 기능 개선을 가능케 한다 모델은 모든 구성원이 사용하는 언어의 중추이다 개발자와 도메인 전문가의 의사소통시 번역이 불필요하다 언어가 모델이 긴밀히 연결되므로 언어를 통해 모델을 정제할 수 있다 모델은 지식의 정수만을 뽑아낸 것이다 도메인 지식을 조직화하고 가장 중요한 요소를 구분짓는다 효과적인 모델링의 요소 개발 project의 iteration 내내 모델과 구현의 연결고리를 유지한다 모델은 언어에 기반해야하고 언어 역시 모델을 토대로 정제된다 모델은 풍부한 도메인 지식을 담아야한다. 지식이 명시적으로 모델을 통해 드러나야한다 모델을 정제해가며 중요한 개념은 더하고 필요없는 개념은 제거한다 도메인의 격리 우선 Layered Achitecture를 적용해 설계요소 별로 계층을 분리한다 계층간 관계는 loosely coupled 되어야 한다 모델은 도메인 계층에 존재한다. 업무 개념, 업무 상황에 관한 정보, 업무 규칙을 표현한다 도메인 객체의 생명주기 관리 현재 모델링은 객체지향패러다임이 지배적이고 DDD 역시 OOP에 기반한다 도메인 객체의 관리 이슈는 생명주기 동안의 무결성 유지하기 생명주기 관리의 복잡성으로 인해 난해해지는 모델 방지하기 관리 패턴 AGGREGATE 객체간 관계로 이루어진 객체 집합에는 불변식(반드시 유지되어야하는 일관성 규칙)이 지켜져야한다 Entity와 ValueObject를 AGGREGATE로 모으고 각각에 대해 경계를 정의하라. 즉, 한 Entity를 AGGREGATE의 루트로 만들고 AGGREGATE 내부의 객체는 루트 엔티티를 통해서만 접근가능(캡슐화)하게 만든다 FACTORY 복잡한 객체이거나 AGGREGATE인 경우, 인스턴스를 생성하는 책임을 별도의 객체로 옮긴다 복잡한 객체 조립 과정을 캡슐화 팩토리 위치에 따라 두가지 경우로 나뉨 팩토리 메소드: 서브클래스에서 클래스의 인스턴스 종류를 결정 추상 팩토리: 인터페이스를 이용하여 구상 클래스를 지정 않고도 생성 REPOSITORY db와 같은 인프라스트럭쳐에 접근하는 행위를 캡슐화 더불어 인프라스트럭쳐에 의존하지 않고 순수한 객체로 핸들링하는 수단 인프라의 객체로 구성된 컬렉션 객체를 메모리에 올린다는 느낌 즉, REPOSITORY 통해 클라이언트는 영속화된 객체를 획득하고, 해당 객체의 생명주기를 쉽게 관리한다 또한 데이터 소스로부터 도메인 설계를 분리한다 The ORM is always an implementation detail of the repository. DDD의 적용 BC(Bounded Context) + MS(Microservice) 단일 시스템(기능 측면) 성장은 이슈를 내포\n통합 db위의 단일 코드가 확장되는 형태 도메인 부재의 문제 프레젠테이션, 서비스, data, db 등의 레이어로 구분된 수평 level의 계층만 존재 수직적으로 묶여진 BC없이(도메인 구분 없이) 분별없이 확장됨 BC의 적용\n패키지를 나누어 응집도를 높이고 문제를 완화(ex. user, project)\n여전히 모호한 경계 Q: User와 Project는 N:N 아닌가? A: BC를 잘 나누었으면 사실 user와 project는 별개임이 드러남 부가적으로 클래스간 통신을 위한 인터페이스가 도출됨 MS의 적용 -\u0026gt; 언어의 경계를 찾아 BC를 구성하는데 도움\n서비스 관점에서의 컴포넌트화\n독립배포 -\u0026gt; 서비스의 응집도 높아짐 명시적이고 공개된 인터페이스 비즈니스 수행에 따른 구성\n조직의 형태에 따라 시스템을 설계(ex. 기능조직, 목적조직) 분산화된 데이터 관리\n통합 db에서라면 join의 의지가 자꾸드러난다. 즉, 다른 ms를 호출하는게 아니라 (편하게) join을 하게되는 문제 진화하는 설계\n서비스별 독립적인 변경이 가능 refs DDD START! 수다 #1 - YouTube links ","link":"https://chankoo.github.io/posts/domain-driven-design/","section":"posts","tags":["책"],"title":"Domain Driven Design"},{"body":"","link":"https://chankoo.github.io/categories/%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/","section":"categories","tags":null,"title":"아키텍처"},{"body":"","link":"https://chankoo.github.io/tags/%EC%B1%85/","section":"tags","tags":null,"title":"책"},{"body":"","link":"https://chankoo.github.io/tags/oop/","section":"tags","tags":null,"title":"OOP"},{"body":" 오해를 덜어낸 객체지향 구현 로직 (클래스가 아니라)특정한 객체를 상상하고, 우선 객체의 행동을 정의하자 정의된 행동을 기반으로 협력의 공동체를 상상해보자. 이 공동체는 요청과 응답의 흐름으로 소통할 것이고 공동체의 구성원에게는 여러가지 책임이 할당된다 다음으로 협력에 필요한 데이터 필드가 있다면 이를 정의하자. 잊지말자 상태보다 협력이 우선이다 마지막으로, (이제서야) 클래스를 구현해야한다. 게다가 클래스는 \u0026lsquo;타입\u0026rsquo;을 구현하기 위한 수단에 불과하다 더 구체적인 설계와 구현 구조설계: 도메인 모델\n도메인의 본질적인 부분을 개념으로 모델링 안정적인 \u0026lsquo;구조\u0026rsquo;의 설계 기능적 요구사항 추출: 유스케이스\n사용자와 시스템이 상호작용하는 케이스들 즉 공통의 사용자 목표를 추출하는 시나리오(유저 플로우)의 집합 합치기: 구조와 기능을 통합해 클래스를 설계하고 구현한다\n클래스 설계와 구현 동일한 클래스들을 세가지의 관점으로 나누어 바라보며 설계\u0026amp;구현한다\n개념관점 도메일 모델과 유스케이를 참고하여 특정 객체의 협력을 상상하고 필요한 개념을 구체화한다 명세관점 사용자 영역에서 개발자 영역으로 넘어가는 단계 객체의 책임을 명세한다. 즉, 인터페이스를 프로그래밍한다 인터페이스의 형태는 보통 클래스 메소드의 시그니쳐로 표현된다 구현관점 객체의 책임을 객체 내부적으로 구현한다 구현의 형태는 클래스 프로퍼티와 메소드이다 refs links ","link":"https://chankoo.github.io/posts/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%9D%98-%EC%82%AC%EC%8B%A4%EA%B3%BC-%EC%98%A4%ED%95%B4/","section":"posts","tags":["책","OOP"],"title":"객체지향의 사실과 오해"},{"body":"OOP에서 1) 객체의 attribute와 method를 하나로 묶고 2) 실제 구현 내용을 내부에 감추는 일.\n캡슐화는 객체간 종속을 인터페이스 레벨에 묶어두어 모듈의 결합도를 낮춘다.\nrefs 캡슐화 - 위키백과, 우리 모두의 백과사전 객체지향의 사실과 오해 links ","link":"https://chankoo.github.io/posts/%EC%BA%A1%EC%8A%90%ED%99%94/","section":"posts","tags":["OOP"],"title":"캡슐화"},{"body":"","link":"https://chankoo.github.io/tags/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/","section":"tags","tags":null,"title":"컴포넌트"},{"body":"content 응집도 높은 컴포넌트를 설계하려면, 1) REP 2) CCP 3) CRP 원칙을 기억해야한다. 세 원칙은 상충하기에 설계 목적에 따라 세 원칙간 균형을 잡아야한다. 컴포넌트의 결합을 잘 설계하려면, 1) ADP 2) SDP 3) SAP 를 이해해야한다. ADP(Acyclic Dependencies Principle)은 컴포넌트 간 의존성이 순환하지 않도록 하여 컴포넌트 간 의존을 끊는 최소한의 규칙이고, SDP(Stable Dependencies Principle)은 안정된(변화가 적은) 모듈이 불안정한(변화가 많은) 모듈에 의존하지 않도록 설계하는 규칙이다. 그리고 SAP(Stable Abstraction Principle)는 안정성과 추상화 정도 사이의 관계를 정의하는데, 불안한(변경이 잦은, 다른 컴포넌트에 많이 의존하고 있는) 컴포넌트는 구체적이어도 괜찮지만, 안정적인(변경이 적은, 다른 컴포넌트가 많이 의존하는) 컴포넌트는 추상화하여 쉽게 확장 가능하도록 해야한다.\n컴포넌트 레벨에 DIP를 적용하면 SDP와 SAP를 지키는데 용이하다. 결국 같은 말인데, DIP = 추상적인 것에 의존하라 = 안정적인 것에 의존하라 + 안정적인 것은 추상화해라.\nrefs 클린 아키텍처 links REP CCP CRP ","link":"https://chankoo.github.io/posts/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%84%A4%EA%B3%84-%EC%9B%90%EC%B9%99/","section":"posts","tags":["컴포넌트"],"title":"컴포넌트 설계 원칙"},{"body":"Open Authorization 2.0 개방형 인증을 위한 표준으로 유저 신원 확인을 위해 다른 서비스에서 리소스를 가져오는 방식으로 동작한다. 비밀번호를 입력할 필요 없이 유저(Resource Owner)의 신원 정보를 서드파티 서비스(Resource Server \u0026amp; Authorization Server) 에서 받아오는 방식이다.\nrefs OAuth_2.md OAuth - Wikipedia links ","link":"https://chankoo.github.io/posts/oauth2.0/","section":"posts","tags":["인증"],"title":"OAuth2.0"},{"body":"","link":"https://chankoo.github.io/categories/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/","section":"categories","tags":null,"title":"네트워크"},{"body":"","link":"https://chankoo.github.io/tags/%EC%9D%B8%EC%A6%9D/","section":"tags","tags":null,"title":"인증"},{"body":"content 분산 시스템의 ID 생성 목적으로 트위터가 고안한 자료구조. 크기가 작고(8바이트) 특정 기술에 의존하지 않아 대용량 분산 시스템의 요구사항을 잘 만족시킨다.\ntimestamp - 약 70년의 timestamp를 표현 가능. 생성 순으로 정렬 가능 instance - 장비의 고유 ID로 사용 seqence - 동일한 ms에 생성한 id에 순번을 매김. 즉, ms 마다 4097(2^12)개 id 생성 가능 refs Snowflake ID - Wikipedia 가상 면접 사례로 배우는 대규모 시스템 설계 기초 분산 처리 시스템에서 유일한 식별자를 만드는 방법(twitter snowflake) links ","link":"https://chankoo.github.io/posts/snowflake-id/","section":"posts","tags":["분산시스템"],"title":"Snowflake ID"},{"body":"","link":"https://chankoo.github.io/tags/tcp/","section":"tags","tags":null,"title":"TCP"},{"body":"content HTTP2에서 스트림은 하나의 TCP 커넥션 내 존재하는 다수의 가상 TCP 소켓이다. 클라이언트와 서버는 스트림을 기준으로 양방향 통신하여, 스트림은 요청과 응답 메시지를 묶는 단위가 된다. HTTP1.1 까지 요청과 응답은 하나의 메시지 단위로만 이뤄졌는데, HTTP2 부터는 여러개의 요청/응답 메시지를 연속적(스트림 단위)으로 전달하는 것이다.\n스트림은 한개 이상의 요청/응답 메시지로 구성되며, 메시지는 프레임이라는 단위로 나뉜다. 프레임은 HTTP2 통신상 가장 작은 정보 단위이며 Header 이거나 Data이다.\nrefs 리얼월드 HTTP HTTP/2에서 Frame, Stream의 의미 links HTTP2 TCP 소켓 ","link":"https://chankoo.github.io/posts/%EC%8A%A4%ED%8A%B8%EB%A6%BC/","section":"posts","tags":["http","TCP"],"title":"스트림"},{"body":"구글에서 개발한 직렬화 데이터 구조. JSON과 같은 기존 포맷보다 작고 직렬화/역직렬화 속도가 빠르다.\n데이터 타입을 정의한 Proto file을 (해당 언어에 맞게) 컴파일하여 사용한다. 최초 1바이트(두자리 16진수)로 필드 넘버와 타입을 표현하고, 차례로 length와 데이터를 표현한다.\nmessage Person { string name = 1; // 필드 타입 string, 필드 넘버 1 int32 age = 2; } refs 프로토콜 버퍼란 무엇인가(Protocol Buffer) 서버, 클라이언트 예제와 함께 feat. express \u0026amp; Vue 구글 프로토콜 버퍼 (Protocol buffer) Language Guide (proto 2) | Protocol Buffers Documentation links Marshalling ","link":"https://chankoo.github.io/posts/%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EB%B2%84%ED%8D%BC/","section":"posts","tags":null,"title":"프로토콜 버퍼"},{"body":"Transmission Control Protocol. TCP/IP 스택 전송 계층 프로토콜로 소켓 간 신뢰할 수 있는 통신을 보장한다.\n프로세스와 프로세스(엄밀히는 소켓과 소켓)를 잇는 논리적인 개념의 point-to-point 통신 reliable: 응용계층에서 받은 데이터의 error와 loss가 없음을 보장 in-order byte stream: 데이터의 순서를 유지 Pipelined : window size 단위로 패킷을 묶어 통신 send \u0026amp; receive buffers: 송신 측과 수신 측 모두 send, receive buffer를 각각 가짐 Full duplex: 통신하는 host 양쪽 모두가 데이터 전송 가능 Connection oriented: handshake를 먼저 수행한 후 통신. handshake에서 window size, buffer, seq number와 같은 정보를 교환함 Flow control Congetion control refs TCP.md reliable_data_transfer.md links 소켓 ","link":"https://chankoo.github.io/posts/tcp/","section":"posts","tags":["TCP"],"title":"TCP"},{"body":"","link":"https://chankoo.github.io/tags/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/","section":"tags","tags":null,"title":"디자인패턴"},{"body":"객체 생성을 위해 구체 팩토리에 의존(요소 -\u0026gt; 팩토리)하는 것이 아니라, 추상 팩토리에 의존(요소 -\u0026gt; 추상 팩토리 $\\Leftarrow$ 구체 팩토리)하는 패턴이다.\nDIP의 전형적인 예시이다.\nrefs links DIP ","link":"https://chankoo.github.io/posts/%EC%B6%94%EC%83%81-%ED%8C%A9%ED%86%A0%EB%A6%AC-%ED%8C%A8%ED%84%B4/","section":"posts","tags":["디자인패턴"],"title":"추상 팩토리 패턴"},{"body":"CAP Theorem. 분산 시스템에서 CAP의 세가지 조건이 동시에 만족할 수 없다는 정리이다.\nConsistency(일관성): 일관된 읽기를 보장 Availability(가용성): 응답을 보장 Partition tolererance(분할 용인): (네트워크 실패를 가정) 일부 메시지가 드랍되어도 시스템이 동작함 P의 조건은 분산 시스템과 네트워크의 본질이므로, 시스템 구현시 CP 또는 AP를 선택하는 문제만 남는다.\nrefs CAP Theorem, 오해와 진실 links ","link":"https://chankoo.github.io/posts/cap/","section":"posts","tags":["분산시스템"],"title":"CAP"},{"body":"content 해시 테이블에 저장한 데이터 개수 n을 버킷의 개수 k로 나눈 것(n/k)\n로드 팩터가 높을수록 해시 테이블의 성능이 감소한다. 같은 버킷을 쓰는 데이터가 많아져 해시 테이블에서 탐색하는 시간이 늘어나기 때문이다.\n따라서 언어별로 해시 테이블을 구현할때 로드 팩터의 임계치를 두고있으며, 임계치를 넘어설때 버킷의 수를 늘려 리해싱한다. (동적 배열의 메모리 재할당과 유사)\nrefs links 해시 테이블 해시 충돌 Dynamic Array ","link":"https://chankoo.github.io/posts/%EB%A1%9C%EB%93%9C-%ED%8C%A9%ED%84%B0/","section":"posts","tags":null,"title":"로드 팩터"},{"body":"","link":"https://chankoo.github.io/categories/%EC%96%B8%EC%96%B4/","section":"categories","tags":null,"title":"언어"},{"body":"인자로 다른 함수에게 전달되는 함수.\nrefs links ","link":"https://chankoo.github.io/posts/%EC%BD%9C%EB%B0%B1-%ED%95%A8%EC%88%98/","section":"posts","tags":null,"title":"콜백 함수"},{"body":"","link":"https://chankoo.github.io/categories/os/","section":"categories","tags":null,"title":"OS"},{"body":"OS가 CPU를 프로세스에게 할당하는 정책이다.\n선점형 vs 비선점형(협력적) 자원을 점유하는 프로세스를 중지하고 강제로 자원을 가져가는 선점형 자원을 점유하는 프로세스가 종료되거나, I/O 발생하여 대기 할때까지 기다리는 비선점형 정적 vs 동적 프로세스에 부여된 우선순위가 고정 vs 유동 refs 스케줄링 (컴퓨팅) - 위키백과, 우리 모두의 백과사전 백엔드 개발자들이 알아야할 동시성 4 — 스케줄링. 지난 포스팅에선 많은 쓰레드와 잦은 컨텍스트 스위칭이 어떻게 웹서버의… | by Choi Geonu | Medium links ","link":"https://chankoo.github.io/posts/%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81/","section":"posts","tags":["동시성"],"title":"스케줄링"},{"body":"Continuation Passing Style. 말그대로 Continuation을 전달하는 방식으로 프로그래밍하는 것을 말한다.\n이는 CPS 함수를 정의할 때 특정한 작업(ex. 콜백 함수) 을 명시적 인자로 받게되는데, CPS 함수는 해당 함수의 작업이 끝난 후 인자로 받은 작업을 수행하게 된다. Continuation이 CPS 함수에 있다가 인자로 받은 작업으로 넘어가는 것이다.\nCPS가 아니라면 함수가 그냥(암묵적으로) 작업을 수행하며, Continuation은 해당 함수에 머무른다.\nrefs Continuation-passing style - Wikipedia 백엔드 개발자들이 알아야할 동시성 5 — Continuation Passing Style | by Choi Geonu | Medium Continuation-Passing Style. CPS 이해하기 | by Ji Sungbin | Medium links 스케줄링 Event Loop 콜백 함수 ","link":"https://chankoo.github.io/posts/cps/","section":"posts","tags":["동시성","함수형프로그래밍"],"title":"CPS"},{"body":"","link":"https://chankoo.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/","section":"tags","tags":null,"title":"함수형프로그래밍"},{"body":"","link":"https://chankoo.github.io/tags/cache/","section":"tags","tags":null,"title":"cache"},{"body":"리소스의 캐시 여부를 지정하는 http 응답/요청 헤더. Cache-Control에 부여한 directive에 따라 캐시 사용 전략이 결정된다. Etag나 bfcache 등이 모두 영향받는다.\nprivate - only cached in client public - can be cached in proxies refs Cache-Control - HTTP | MDN 프론트엔드 개발자가 알아야 할 ‘캐싱’ 개념 정리 | 요즘IT links Etag bfcache ","link":"https://chankoo.github.io/posts/cache-control/","section":"posts","tags":["cache","http","브라우저"],"title":"Cache-Control"},{"body":"","link":"https://chankoo.github.io/tags/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80/","section":"tags","tags":null,"title":"브라우저"},{"body":"Cross-Origin Resource Sharing. 출처가 다른(Cross-Origin) 요청에 대해 리소스를 내려 줄 것인지 판단하는 정책이다.\n요청 헤더 Origin에 출처가 담긴다. 스킴, 도메인, 포트 중 하나라도 다르면 Cross-Origin으로 본다. 응답 헤더 Access-Control-Allow-Origin에 허용된 출처가 담긴다. 브라우저가 Origin, Access-Control-Allow-Origin 그리고 요청 시나리오를 고려하여 CORS 위반 여부를 판단한다. refs CORS는 왜 이렇게 우리를 힘들게 하는걸까? | Evans Library links ","link":"https://chankoo.github.io/posts/cors/","section":"posts","tags":["web","http","브라우저"],"title":"CORS"},{"body":"","link":"https://chankoo.github.io/categories/%EB%B3%B4%EC%95%88/","section":"categories","tags":null,"title":"보안"},{"body":"코루틴 기반의 파이썬 라이브러리로 고성능 I/O를 위한 동시성을 지원한다.\ngreenlet 이라는 경량 스레드(코루틴)와 event loop를 이용하여 넌블러킹 \u0026amp; 비동기 I/O를 지원한다. monkey patching을 이용해 표준 라이브러리의 구현을 gevent의 구현으로 바꿔치기하는 방식으로 동작한다.\n파이썬이 표준으로 제공하는 구현이 아니고 어디까지나 monkey patching(흑마법) 이기에 한계가 분명하다. (대표적으로 mysqlclient는 gevent 와 호환되지 않는다)\nrefs What is gevent? - gevent 23.9.2.dev0 documentation 백엔드 개발자들이 알아야할 동시성 번외편— Python의 Concurrency | by Choi Geonu | Medium links coroutine 스레드 ","link":"https://chankoo.github.io/posts/gevent/","section":"posts","tags":["동시성","python"],"title":"gevent"},{"body":"특정 이벤트가 발생했을때 타겟 서비스 엔드포인트로 데이터를 전달하는 http 기반의 콜백\nrefs 웹훅(Webhook) | 토스페이먼츠 개발자센터 links ","link":"https://chankoo.github.io/posts/webhook/","section":"posts","tags":["web","http"],"title":"webhook"},{"body":"content Dynamic Host Configuration Protocol. 네트워크에 연결된 장치들에게 IP 주소와 기타 매개변수(네임서버 주소, 게이트웨이 주소 등)를 자동으로 할당하는 IP 네트워크 레벨의 프로토콜.\n서버(보통은 공유기)와 클라이언트로 나뉘는데, DHCP 서버는 서브넷에서 사용가능한 네트워크 자원을 일정 기간 클라이언트에 임대하는 역할을 수행한다. 서버가 중앙 집중식으로 관리하기에 클라이언트 간 충돌 없이 네트워크 자원을 분배할 수 있다.\nrefs 🌐 DHCP 이란 무엇인가? (그림으로 쉽게 정리) links ","link":"https://chankoo.github.io/posts/dhcp/","section":"posts","tags":["IP"],"title":"DHCP"},{"body":"","link":"https://chankoo.github.io/tags/ip/","section":"tags","tags":null,"title":"IP"},{"body":"","link":"https://chankoo.github.io/tags/mysql/","section":"tags","tags":null,"title":"mysql"},{"body":"컬럼 텍스트의 전체 값을 인덱싱해서 키워드 검색(full text search)을 용이하게 하는 방법으로 stopword, n-gram 등의 전문 검색 알고리즘을 사용한다.\nrefs Real MySQL links ","link":"https://chankoo.github.io/posts/%EC%A0%84%EB%AC%B8-%EA%B2%80%EC%83%89-%EC%9D%B8%EB%8D%B1%EC%8A%A4/","section":"posts","tags":["mysql"],"title":"전문 검색 인덱스"},{"body":"인덱싱할 컬럼 값의 해시를 키로 이용하는 인덱스. 동등 비교에 최적화(O(N)) 되었지만 범위 검색이나 정렬에는 전혀 사용할 수 없다.\nrefs Real MySQL links 해시 ","link":"https://chankoo.github.io/posts/hash-%EC%9D%B8%EB%8D%B1%EC%8A%A4/","section":"posts","tags":null,"title":"Hash 인덱스"},{"body":"refs links ","link":"https://chankoo.github.io/posts/real-mysql/","section":"posts","tags":["책"],"title":"Real MySQL"},{"body":"작업 이번에는 피드 서비스에서 주된 이슈인 Fanout 시나리오를 실험했다. 유저가 게시글을 작성하면 해당 글을 500명의 친구 피드로 전송하는 것이다. 이는 한 유저 당 501개의 create 요청을 발생시키는 고부하 작업이다.\n목표 500 RPS(약 250,000 QPS) 를 견디는 시스템을 만든다. 가상 사용자(VU) 500명을 설정하고, 1초 간격으로 3분 동안 요청을 지속했다.\n결과 요약 DB의 옵션을 이해하고 우선적으로 DB 성능을 튜닝하는 것이 중요하다. \u0008그래도 DB가 병목일 땐 캐시와 비동기 작업을 적극적으로 활용하자. 환경 AWS\n서버: Django + gunicorn\nDB: SQLite or Mysql or Redis\n인프라: Docker Compose or (AWS ECS Fargate + Docker)\n테스팅: K6 + Grafana + InfluxDB\n결과 상세 vCPU 8개를 사용하여 테스트했을 때, 초당 1개 요청도 처리하지 못하는 저조한 성능을 보였다. 태스크 CPU와 메모리 사용량이 3%~5%로 낮아 DB 병목이 의심되었다. 기본적으로 Django에 설정된 SQLite는 높은 수준의 동시성을 요구하는 작업에 적합하지 않았다.\n또 다른 문제\u0008는, 로컬 파일 시스템에 데이터를 저장하는 SQLite의 특성에서 기인했다. 데이터가 애플리케이션 서버마다 분산되어 있었고, 이로 인해 피드의 일관성 문제가 발생했다. 두 개의 태스크를 사용함에 따라, 각 태스크는 작성된 포스트의 절반만 조회할 수 있었다.\n[AWS ECS Fargate 설정] 태스크: 2 태스크 CPU: 4 vCPU 태스크 메모리: 8 GB 결과\nchecks\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.: 99.19%\ndata_received\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;: 122 kB 635 B/s\nhttp_reqs\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.: 124 0.646009/s\niteration_duration\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.: avg=14.98s p(95)=29.45s\nDB를 MySQL로 변경하고 AWS EC2에서 도커 컨테이너로 DB 서버를 구축했을 때, 처리량은 100 RPS 수준으로 증가했지만 85%의 요청이 실패하는 새로운 문제에 직면했다.\n[AWS EC2 - Mysql container] 인스턴스 유형: t4g.medium(cpu 2 | memory 4GiB | EBS 버스트 대역폭 2,085 Mbps) innodb_buffer_pool_size = 128M(default) innodb_flush_log_at_trx_commit = 1(default) max_connections = 150(default) 결과\nchecks\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.: 15.48%\ndata_received\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;: 5.1 GB 27 MB/s\nhttp_reqs\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.: 19611 104.708861/s\niteration_duration\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.: avg=4.67s p(95)=14.95s\n원인을 추정하다가 DB 커넥션 수가 요청 실패율에 결정적인 영향을 미친다는 것을 발견했다(꽤 오랜 시간이 걸렸다). MySQL 기준 max_connections 이 너무 낮으면, 요청이 커넥션을 맺기 위해 대기하다가 타임아웃이 나서 에러가 많아진다. 시도와 실패를 반복하며 많은 RPS를 기록하고, 앱 서버의 자원도 많이 사용한다. 반대로 max_connections이 높으면, 타임아웃으로 요청이 실패하는 경우가 줄어들고 DB 트랜잭션을 기다리는 상황이 발생한다. 자연히 DB 서버의 자원을 많이 사용하고, 과부하로 트랜잭션 처리량이 줄어들면 RPS 역시 적어진다.\n아래처럼 max_connections을 1000으로 높여준 결과 11 RPS로 처리량이 크게 줄었지만, 1% 미만의 요청 실패율을 보여주었다. 버퍼 풀의 메모리 사이즈(innodb_buffer_pool_size)나 로그의 flush 타이밍(Innodb_flush_log_at_trx_commit) 옵션 역시 중요한 튜닝 포인트지만, 실패율 문제를 해결하는 것에는 부가적인 영향만 주었다.\n[AWS EC2 - Mysql container] 인스턴스 유형: t4g.medium(cpu 2 | memory 4GiB | EBS 버스트 대역폭 2,085 Mbps) innodb_buffer_pool_size = 2048M innodb_flush_log_at_trx_commit = 2 max_connections = 1000 결과\nchecks\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.: 99.03%\ndata_received\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;: 2.3 MB 11 kB/s\nhttp_reqs\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.: 2376 11.442402/s\niteration_duration\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.: avg=40.92s p(95)=58.12s\n요청 실패를 줄이는 것에는 성공했지만 DB가 병목인 상황을 쉽게 해결하기는 어려워보인다. 목표인 500 RPS을 달성하려면 DB가 약 250,000 QPS를 처리해야하는데, 이는 DB 서버 스펙을 크게 높이든지, 분산 DB를 도입해야하는 수준으로 보였다. 어느 쪽이든 금전적, 시간적 비용이 걱정되는 상황이라 캐시와 비동기를 도입하여 가볍게 해결해보고자 하였다.\n피드를 캐시에 저장하도록 로직을 변경하고 별도의 비동기 태스크(Celery)로 작업했다. 캐시는 DB 부하를 줄이면서 고성능의 인메모리 저장소를 활용하려는 접근이다. 또한 별도의 비동기 서버를 활용하여 서비스 반응 시간을 줄이고, 동시성 수준을 높일 수 있었다. 이로써 고비용의 하드웨어 업그레이드나 복잡한 분산 시스템 구축 없이도 처리량을 300 RPS 수준으로 끌어올렸고, 성능 목표에 접근할 수 있었다.\n다만 비동기 태스크의 처리량이 낮은 상태여서 추가적인 최적화와 확장이 필요한 상태이다. 아래 이미지에서 보이듯, 피드 서비스(sample-feed) 작업이 완료된 후에도 캐시(ElastiCache redis)와 저장 태스크(sample-feed) 작업이 한동안 지속되는 상황인 것이다.\n[AWS ECS Fargate (피드 서비스)] 태스크: 4 태스크 CPU | 메모리: 2 vCPU | 4 GB [AWS ECS Fargate \u0008(캐시 저장 태스크)] 태스크: 2 태스크 CPU | 메모리: 2 vCPU | 4 GB [AWS Elasticache - Redis] cache.t4g.medium 결과\nchecks\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.: 99.96%\ndata_received\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;: 19 MB 305 kB/s\nhttp_reqs\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.: 18993 308.319286/s\niteration_duration\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.: avg=1.6s p(95)=4.78s\nrefs sample-feed 4차 · Issue #4 · chankoo/load-testing-practices · GitHub links ","link":"https://chankoo.github.io/pages/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%94%94%EC%9E%90%EC%9D%B8-%EC%97%B0%EC%8A%B5-%ED%94%BC%EB%93%9C-%EC%84%9C%EB%B9%84%EC%8A%A4-3-db-%EB%B3%91%EB%AA%A9/","section":"pages","tags":["부하테스트","mysql","시스템디자인"],"title":"\u003c시스템 디자인 연습\u003e 피드 서비스 3 - DB 병목"},{"body":"content \u0008DB row의 wrapper 객체로 데이터에 대한 접근과 도메인 로직을 함께 구현해놓는 방식이다.\nrefs P of EAA: Active Record Fetching Title#kql4 links ","link":"https://chankoo.github.io/posts/active-record/","section":"posts","tags":["django"],"title":"Active Record"},{"body":"","link":"https://chankoo.github.io/tags/django/","section":"tags","tags":null,"title":"django"},{"body":"동기적이지 않은 것(asynchronous)을 의미한다.\n동기적이라는 건 작업들을 순차적으로 진행함을 의미하는데, 한 작업이 끝나기를 기다려야하는 속성이 있다. 반면에 비동기는 한 작업이 끝나기를 기다리지 않고 다른 작업을 진행하는 것을 말하며, 동기적이지 않은 모든 방식을 의미한다.\n비동기의 예시 non-block I/O - 요청을 block하는 작업이 아니기에 I/O를 기다리는 동안 다른 작업을 처리할 수 있다. 멀티 스레딩 - 여러 작업을 각 스레드가 나누어 진행하기에 동기적이지 않다. block I/O 작업이라도 비동기로 진행할 수 있다 refs 비동기 프로그래밍, 비동기 I/O, 비동기 커뮤니케이션.. 비동기(asynchronous)라는 .. 참 많이 사용하는데요~ 각 맥락에 따른 의미를 설명합니다~ 들러보세영~ㅎㅎ - YouTube 👩‍💻 완벽히 이해하는 동기/비동기 \u0026amp; 블로킹/논블로킹 links ","link":"https://chankoo.github.io/posts/%EB%B9%84%EB%8F%99%EA%B8%B0/","section":"posts","tags":["동시성"],"title":"비동기"},{"body":"컴퓨터 과학에서 어떠한 작업을 처리하는 흐름의 단위를 말한다.\n종류 하드웨어 스레드 - 하드웨어 레벨에서 CPU 코어의 작업을 나눠 놓은 단위이다. 코어의 한 하드웨어 스레드가 메모리에 접근하는 시간에 다른 스레드가 CPU 연산을 이용하는 병행처리를 가능케 한다. OS 스레드 - 일반적인 의미의 스레드로, CPU에서 실제로 실행(CPU 스케줄링)되는 단위이다. OS 커널이 시스템콜을 통해 스레드를 생성하고, 컨텍스트 스위칭을 한다. 네이티브 스레드, 커널 스레드라 불리기도 한다. 유저 스레드 - 유저가 관리하는 단위의 스레드로 프로그래밍 레벨에서 추상화한 OS 스레드를 의미한다. 실제로 실행하기 위해서 OS 스레드와 연결해야하며 연결 관계에 따라 일대일, 일대다, 다대다로 나뉜다. 일대일 스레드 - OS 스레드와 일대일 매핑된 유저 스레드는 OS 스레드와 같이 동작한다. 스레드 관리와 스케줄링을 OS 에 위임하고, 멀티코어 활용이 용이하다. 일대다/ 다대다 스레드 - 유저 스레드가 하나의 OS 스레드와 연결되므로, 유저 스레드간 스위칭이 빠르다. 그린 스레드 - OS와는 독립적으로 유저 레벨에서 관리되는 스레드(엄밀한 의미의 유저 스레드)를 의미하며 OS 스레드와 일대다/다대다 관계이다. refs 스레드 종류가 참 많죠? 하드웨어 스레드, OS 스레드, 네이티브 스레드, 커널 스레드, 유저 스레드, 그린 스레드까지 한번에 정리해서 알려드립니다!! - YouTube links coroutine ","link":"https://chankoo.github.io/posts/%EC%8A%A4%EB%A0%88%EB%93%9C/","section":"posts","tags":["동시성"],"title":"스레드"},{"body":"DB Connection Pool. DB와의 커넥션 풀을 어플리케이션 단에 미리 만들어두는 것이다. DB와 커넥션을 맺고 끊기 위해 매번 TCP 통신하는 비용을 줄인다.\nmysql 기준으로 성능에 중요한 설정 max_connections: 클라이언트와 맺을 수 있는 최대 커넥션 수 wait_timeout: inactive 커넥션을 얼마까지 기다린 뒤 close 할지 설정 django 기준으로 성능에 중요한 설정 django는 커넥션 풀을 지원하지 않고, 요청마다 커넥션을 맺고 끊는다. CONN_MAX_AGE: 하지만 CONN_MAX_AGE(default: 0)에 값을 주면, 커넥션을 지정한 시간 동안 종료하지 않아 커넥션 풀처럼 재사용이 가능하다. 각 스레드는 고유한 커넥션을 갖는다. gunicorn 과 같은 서버를 이용하여 여러 스레드를 서빙하는 경우 그린 스레드(gevent) 조차 고유한 커넥션으로 연결된다. 대규모 동시성이 필요한 경우, gunicorn의 worker_connection을 크게 설정한다. db의 max_connections 를 더 크게 조정하면서 db의 부하를 살피거나 커넥션 풀 라이브러리를 사용하여 불필요한 커넥션을 유지하는 비용을 줄일 수도 있다. 고유한 커넥션을 쓰지 말고 커넥션 풀에서 스레드가 커넥션을 가져다쓰는 방식으로 수정하는 것이다. refs DBCP (DB connection pool)의 개념부터 설정 방법까지! hikariCP와 MySQL을 예제로 설명합니다! 이거 잘 모르면 힘들.. - YouTube Django에서 DB Connection 관리 SH DEVLOG Design — Gunicorn 21.2.0 documentation Scaling Django+Gevent with LDAP Connection Pooling | by J. Clayton Tallieu | Medium (Django) Django에서 Thread를 다룰 때 주의할 점 links gunicorn ","link":"https://chankoo.github.io/posts/dbcp/","section":"posts","tags":["mysql","django"],"title":"DBCP"},{"body":"Log Structured Merge Tree는 로그성 데이터 색인을 위해 고안된 자료구조로, 정렬된 키-값 데이터인 SS테이블(Sorted String Table) 형식으로 디스크에 데이터를 저장한다.\nrefs 데이터 중심 애플리케이션 설계 색인(index)의 두 가지 형태 : LSM 트리 \u0026amp; B 트리 | by allocProc | Medium links B-Tree Hash 인덱스 ","link":"https://chankoo.github.io/posts/lsm-tree/","section":"posts","tags":null,"title":"LSM Tree"},{"body":"mysql의 InnoDB는 아래와 같은 구조로 인덱스를 생성한다. 해당 인덱스는 B-Tree 로 기본키를 저장하고, 기본키는 데이터에 접근한다. 이때 기본키와 데이터는 같은 공간에 저장한다. 이를 클러스터드 인덱스(테이블이 곧 기본키 인덱스)라고 부른다.\nrefs [MySQL] B-Tree로 인덱스(Index)에 대해 쉽고 완벽하게 이해하기 - MangKyu\u0026rsquo;s Diary 데이터 중심 애플리케이션 설계 links B-Tree Hash 인덱스 전문 검색 인덱스 ","link":"https://chankoo.github.io/posts/mysql-%EC%9D%B8%EB%8D%B1%EC%8A%A4/","section":"posts","tags":["mysql"],"title":"Mysql 인덱스"},{"body":"BST(Binary Search Tree)를 일반화한 자료구조로 2개 이상의 자식 노드를 갖는 Balanced Tree이다.\nB Tree 류 자료구조는 DB 인덱스로 많이 쓰인다. (Balanced BST인)AVL Tree, RB Tree에 비해 자식 노드 개수가 많아 디스크 접근 수가 적음 블록 단위로 메모리에 적재하는 OS 특성도 효율적으로 활용 B Tree 인덱스의 성능은 키의 크기, 키의 카디널리티, 레코드 대비 인덱스 스캔의 범위 등 다양한 요소에 영향 받는다.\n디스크 I/O로 데이터를 가져오는 단위인 블록의 크기는 고정(mysql은 16KB)인데, 키의 크기가 커지면 한블록에 저장하는 키의 개수가 적어진다. 결과적으로 더 많은 디스크 I/O를 유발하고, 인덱스 트리의 깊이를 더 깊게 만든다. 인덱스를 거치는 읽기 작업이 효율적이려면, 보통 전체 레코드 대비 25% 정도 읽는 작업 까지를 한계로 본다. 키의 카디널리티가 낮거나(ex. 성별), 전체 레코드 대비 많은 양을 읽는 작업이라면 인덱스를 사용 않는 것이 좋다. refs 데이터 중심 애플리케이션 설계 Site Unreachable Real MySQL links ","link":"https://chankoo.github.io/posts/b-tree/","section":"posts","tags":["mysql"],"title":"B-Tree"},{"body":"refs links ","link":"https://chankoo.github.io/posts/%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A4%91%EC%8B%AC-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%84%A4%EA%B3%84/","section":"posts","tags":["책","분산시스템"],"title":"데이터 중심 애플리케이션 설계"},{"body":"refs links ","link":"https://chankoo.github.io/posts/%EA%B0%80%EC%83%81-%EB%A9%B4%EC%A0%91-%EC%82%AC%EB%A1%80%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84-%EA%B8%B0%EC%B4%88/","section":"posts","tags":["책","분산시스템"],"title":"가상 면접 사례로 배우는 대규모 시스템 설계 기초"},{"body":"","link":"https://chankoo.github.io/tags/elasticsearch/","section":"tags","tags":null,"title":"elasticsearch"},{"body":"키워드에 문서 인덱스를 저장하는 작업으로, 키워드를 포함한 문서를 빠르게 찾는 역인덱스이다.\n예를 들어,\n\u0026ldquo;검색 엔진은 정보를 빠르게 찾을 수 있는 도구이다.\u0026rdquo; \u0026ldquo;인덱스는 검색을 효율적으로 만들어주는 역할을 한다.\u0026rdquo; 위 문서들을 역색인 하면 아래와 같이 저장한다.\n{ \u0026#34;검색\u0026#34;: [1, 2], \u0026#34;엔진\u0026#34;: [1], \u0026#34;정보\u0026#34;: [1], \u0026#34;빠르게\u0026#34;: [1], \u0026#34;찾다\u0026#34;: [1], \u0026#34;도구\u0026#34;: [1], \u0026#34;인덱스\u0026#34;: [2], \u0026#34;효율적으로\u0026#34;: [2], \u0026#34;만들다\u0026#34;: [2], \u0026#34;역할\u0026#34;: [2] } 반면, 전문 검색 인덱스는 검색이 필요한 단어를 모두 인덱싱하는 방식으로, 일반적인 인덱싱 방식과 크게 다르지 않다.\n{ 1: [\u0026#34;검색\u0026#34;, \u0026#34;엔진\u0026#34;, \u0026#34;정보\u0026#34;, \u0026#34;빠르게\u0026#34;, \u0026#34;찾을\u0026#34;, \u0026#34;수\u0026#34;, \u0026#34;있는\u0026#34;, \u0026#34;도구\u0026#34;], 2: [\u0026#34;인덱스\u0026#34;, \u0026#34;검색\u0026#34;, \u0026#34;효율적으로\u0026#34;, \u0026#34;만들어주는\u0026#34;, \u0026#34;역할\u0026#34;, \u0026#34;한다\u0026#34;] } refs 6.1 역 인덱스 - Inverted Index - Elastic 가이드북 links 전문 검색 인덱스 ","link":"https://chankoo.github.io/posts/%EC%97%AD%EC%83%89%EC%9D%B8/","section":"posts","tags":["elasticsearch"],"title":"역색인"},{"body":"작업 두번째 실험에서는 AWS ECS Fargate 를 이용해 페이지 조회 작업을 스케일 아웃했다. 첫번째 실험과 같은 조건인데, 100개의 짧은 글(post)이 로드된 페이지를 읽는 작업이다.\n목표 1000 RPS를 견디는 환경을 만든다. 이를 위해 가상 사용자(VU) 1000명을 설정하고, 1초 간격으로 3분 동안 요청을 지속했다.\n결과 요약 물리적 네트워크 대역폭이 병목인 상황을 확인하고 테스트 환경까지 클라우드에 구축했다. 위 목표를 달성하기 위해 Fargate 기준 vCPU 8개(1024 * 8)가 필요하다는 것을 확인했다. 환경 AWS\n서버: Django + gunicorn\nDB: SQLite or MySQL or Redis\n인프라: AWS ECS Fargate, Docker\n테스팅: K6 + Grafana + InfluxDB\n결과 상세 AWS Fargate CPU와 메모리를 증가시키며 실험했지만, RPS가 200 수준에서 더 이상 개선되지 않았다. CPU와 메모리 사용량에 여유가 있음에도 불구하고 성능이 개선되지 않아 다른 병목 요소가 있을 것으로 추측하고 원인을 찾기 시작했다.\n[AWS fargate 설정] 태스크: 2개 태스크 CPU: 4 vCPU 태스크 메모리: 8 GB 결과\nchecks\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.: 99.73%\ndata_received\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;: 2.1 GB 10 MB/s\nhttp_reqs\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.: 42910 208.976842/s\niteration_duration\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.: avg=4.24s p(95)=10.47s\n사용 중이던 DB(SQLite)를 AWS RDS(MySQL)와 ElastiCache(Redis)로 각각 변경했지만, 결과는 동일했다. 설정한 RDS와 ElastiCache의 지표도 정상이어서 DB 병목이 아님을 확인했다.\n[AWS RDS(mysql) 설정] 인스턴스 클래스: db.t3.micro vCPU: 2 RAM: 1GB 네트워크: 2085Mbps(256MBps) [AWS ElastiCache(Redis) 설정] 노드 유형: cache.t3.micro memory: 0.5GiB network: Up to 5Gbps(625MBps) 결과\nchecks\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.: 99.80%\ndata_received\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;: 2.1 GB 10 MB/s\nhttp_reqs\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.: 43381 208.450836/s\niteration_duration\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.: avg=4.19s p(95)=10.17s\n지표를 확인하던 중 K6의 데이터 수신 속도(data_received)가 항상 초당 10 MB에 머무는 것을 발견했다. 이는 로컬 환경에서 기록한 17 MB/s 보다 낮았다. 그제서야 테스트를 수행하는 클라이언트 역시 실험의 변수가 될 수 있음을 깨달았다. 집에서 사용하는 100mbps 인터넷의 실제 속도가 90mbps 가량이었고, 이는 초당 데이터 송수신량이 최대 11.25MBps로 제한됨을 의미했다.\nAWS EC2 인스턴스에 테스팅 환경을 새로 구축한 후, data_received가 17 MB/s로 증가했고, CPU 사용량이 99%에 도달하는 것을 확인할 수 있었다.\n[Client(AWS EC2) 설정] 인스턴스 유형: c6gn.large vCPU 수: 2 Memory: 4 GiB Network Bandwidth: Up to 25Gbps [AWS fargate 설정] 태스크: 1개 태스크 CPU: 4 vCPU 태스크 메모리: 8 GiB 결과\nchecks\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.: 99.78%\ndata_received\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;: 3.2 GB 17 MB/s\nhttp_reqs\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.: 65565 358.497221/s\niterations\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;: 65565 358.497221/s\n최종적으로 Fargate 태스크 수를 늘려 아래와 같은 결과를 얻었다. 목표로 했던 RPS 1000에 거의 도달할 수 있었다.\n[AWS fargate 설정] 태스크: 2개 태스크 CPU: 4 vCPU 태스크 메모리: 8 GiB 결과\nchecks\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.: 99.96%\ndata_received\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;: 7.2 GB 40 MB/s\nhttp_reqs\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.: 147692 813.172902/s\niteration_duration\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.: avg=1.22s p(95)=1.93s\nrefs sample-feed 3차 · Issue #3 · chankoo/load-testing-practices · GitHub links ","link":"https://chankoo.github.io/pages/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%94%94%EC%9E%90%EC%9D%B8-%EC%97%B0%EC%8A%B5-%ED%94%BC%EB%93%9C-%EC%84%9C%EB%B9%84%EC%8A%A4-2-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%8C%80%EC%97%AD%ED%8F%AD-%ED%95%9C%EA%B3%84/","section":"pages","tags":["부하테스트","시스템디자인"],"title":"\u003c시스템 디자인 연습\u003e 피드 서비스 2 - 네트워크 대역폭 한계"},{"body":"작업 첫번째 실험은 가장 기본적인 페이지 조회이다. 로컬 환경에서 Django와 gunicorn 조합으로 어느 정도의 조회 트래픽을 감당하는지 파악하는 것이었다. 크게 두가지 작업을 진행했는데, 하나는 빈 페이지를 읽는, 다른 하나는 100자 분량의 짧은 글(post) 100개가 로드된 페이지를 읽는 작업이다.\n목표 목표는 로컬 환경에서 1000 RPS(초당 요청 수)를 견딜 수 있는지 확인하는 것이다. 이를 위해 가상 사용자(VU) 1000명을 설정하고, 1초 간격으로 5분 동안 요청을 지속했다.\n결과 요약 gevent 워커 사용: gunicorn gevent 워커를 사용했을 때 조회 성능이 안정적이었다. 많은 수의 경량 스레드를 활용하는 gevent의 특성 때문으로 보인다. 스케일 아웃이 필요: 데이터를 포함한 페이지에서는 1000 RPS를 처리하지 못했다. 서버를 늘려야하겠다. 환경 로컬 호스트\n서버: Django + gunicorn\nDB: SQLite\n인프라: Docker\n테스팅: K6 + Grafana + InfluxDB\n결과 상세 빈 페이지를 \u0008읽을 때는 gunicorn 설정을 조정하는 것만으로 목표를 달성하는 수준이었다. 워커 클래스를 gevent로 설정하고 워커당 1000개 worker_connections 을 사용함으로써 I/O 작업이 대부분인 웹 페이지 조회 요청을 효과적으로 처리했다. 이는 sync 설정을 사용했을때 요청 처리 시간이 늘며 RPS 300~400 수준을 기록한 것과 대비되는 결과다.\n[gunicorn 설정] worker = 9(cpu_count * 2 + 1) worker_class = \u0026quot;gevent\u0026quot; worker_connections = 1000 결과\nchecks\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.: 99.74%\ndata_received\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;: 81 MB 268 kB/s\nhttp_reqs\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.: 276763 918.952395/s\niteration_duration\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.: avg=1.08s p(95)=1.42s\n반면에 데이터를 포함한 페이지를 읽을 때는 모든 gunicorn 설정에서 RPS 300 미만을 기록했다. DB 병목을 의심하며 Redis에 캐시하여 실험해봤지만, 최종적으로 RPS 350 수준에 그쳤다. 이 결과로 인해 컴퓨팅 파워의 스케일 아웃이 필요하다고 판단했다.\n결과\nchecks\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.: 99.58%\ndata_received\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;: 5.0 GB 17 MB/s\nhttp_reqs\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.: 106619 351.608025/s\niteration_duration\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.: avg=2.82s p(95)=4.63s\nrefs sample-feed 1차 · Issue #1 · chankoo/load-testing-practices · GitHub sample-feed 2차 · Issue #2 · chankoo/load-testing-practices · GitHub links ","link":"https://chankoo.github.io/pages/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%94%94%EC%9E%90%EC%9D%B8-%EC%97%B0%EC%8A%B5-%ED%94%BC%EB%93%9C-%EC%84%9C%EB%B9%84%EC%8A%A4-1-%EC%84%9C%EB%B2%84-%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%84%A4%EC%A0%95/","section":"pages","tags":["부하테스트","시스템디자인"],"title":"\u003c시스템 디자인 연습\u003e 피드 서비스 1 - 서버 동시성 설정"},{"body":"배경 \u0026lsquo;대용량 트래픽\u0026rsquo; 또는 \u0026lsquo;분산 시스템\u0026rsquo;과 같은 용어를 채용공고에서 접하는 것이 일반적인 경험이 된 지 오래다. 대규모 서비스를 운영하는 아키텍처 대부분이 분산 시스템을 기반으로 하고 있기에, 이를 이해하고 경험해봐야겠다는 생각을 한 지도 오래되었다.\n그러나 대규모 분산 시스템을 실제로 경험하는 것은 쉬운 일이 아니다. 시니어 개발자들은 시스템 디자인 인터뷰 자리에서 복잡한 아키텍처를 뚝딱 그려낸다던데, 언제 그런 수준으로 성장할 수 있을지 의문이 들었다. \u0026ldquo;가상 면접 사례로 배우는 대규모 시스템 설계 기초\u0026quot;와 같은 훌륭한 책을 읽으며 이론적 지식을 쌓는 것은 유익했지만, 내 업무에 그러한 지식을 적용할 기회는 많지 않았다. 비즈니스에 도움이 되어야 쓸 수 있는게 기술이니까\u0026hellip; 하는 아쉬움을 느끼며 실질적인 경험을 쌓기 위해 무언가 다른 접근이 필요하다고 생각했다.\n그래서 분산 시스템을 설계하고 구현하는 토이 프로젝트를 시작하려 한다. 높은 부하를 견디는 규모 확장성에 관한 설계를 직접 구현해보며 확인\u001d 것이고, 와중에 새로운 문제를 만나 모르던 것을 알게 될 것이다. 이러한 경험을 꾸준히 이어가 더 전문성있는 엔지니어로 성장하기를 기대하며, 더 즐겁게 일하는 개발자로 발전하는 과정이라 믿는다.\n목적 프로젝트의 주된 목적은 서비스 부하가 증가할 때 시스템에 발생하는 다양한 문제들을 직접 경험하고 해결하는 것이다. 부하가 증가할 때 시스템이 어떻게 반응하는지 관찰하고, 그에 맞는 적절한 구조적 조치들을 적용해보려 한다.\n방식 목적 달성을 위해 부하 테스트를 활용하려한다. 가상의 트래픽을 생성해 시스템에 부하를 주고, 이에 따라 나타나는 시스템의 반응을 관찰하며 시스템을 점진적으로 개선해 나갈 것이다.\n아래와 같은 서비스들을 테스트하겠다. 널리 알려진 시스템 디자인 시나리오들이다.\n피드 서비스: 사용자들이 게시물을 업로드하고, 이 게시물이 다른 사용자들의 피드에 실시간으로 반영되는 시나리오를 구현한다. 채팅 서비스: 실시간으로 메시지를 주고받는 채팅 서비스를 구현한다. 웹소켓과 발행/구독 모델 등으로 시스템을 구성하고, 부하를 늘린다. 부하 테스트 시 눈여겨볼 지표를 정리했다.\nRPS 요청 실패 비율 요청 처리 시간 요청 \u0008전 차단 시간 cpu 사용량 메모리 사용량 네트워크 처리량 환경 \u0008서버\nPython + Django + gunicorn: 가장 익숙한 스택으로 빠르게 구현 Python + Fastapi + uvicorn: 실시간 비동기 서버를 가볍게 구현 DB\nSQLite or MySQL or PostgresSQL or Redis: 상황과 목적에 따라 선택 인프라\nDocker Compose: 개발 환경 설정에 익숙하며, 여러 컴포넌트를 빠르고 효율적으로 실험하기 적합 AWS ECS Fargate: 도커 기반 컨테이너를 손쉽게 관리 가능. 서비스와 태스크로 구성해 배포하는 방식이 직관적 부하 테스트\nK6 + Grafana + InfluxDB 가벼우면서 러닝 커브가 낮은 k6 를 선택했다. 테스트 결과를 시각화하는 일에 큰 리소스를 쓰고 싶지 않았다. 마침 k6는 grafana, influxdb 를 이용한 대시보드 템플릿이 이미 잘 만들어져있어 적합했다. javascript 로 테스트 시나리오를 작성할 수 있어 익숙한 탓도 컸다. 그밖에 고려한 툴 JMeter, nGrinder 등도 많이 쓰이지만 간단한 부하 생성용으로는 무거워보였고, 러닝 커브가 상대적으로 높다고 판단했다. locust는 \u0008파이썬 기반의 툴이라 반가웠지만, 신뢰가 가는 예제와 레퍼런스를 찾기가 상대적으로 어렵다는 느낌이 들었다. refs 가상 면접 사례로 배우는 대규모 시스템 설계 기초 서버 사이드 테스트 자동화 여정 - 4. 성능 테스트 자동화 목표 설정 및 테스트 환경 구성 대용량 트래픽은 어떻게 테스트해야할까? 60만 RPM 테스트하기 by 스케일아웃 (K6, AWS, EC2, 테스트, 성능테스트) GitHub - schooldevops/k6-tutorials ","link":"https://chankoo.github.io/pages/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%94%94%EC%9E%90%EC%9D%B8-%EC%97%B0%EC%8A%B5-%EC%A4%80%EB%B9%84/","section":"pages","tags":["부하테스트","시스템디자인"],"title":"\u003c시스템 디자인 연습\u003e 준비"},{"body":"소프트웨어 엔지니어링의 특징(프로그래밍과 비교한) sustainability 시간이 흐름에 따라 요구되는 기술적, 비즈니스적 변화에 capable 해야함 코드의 지속가능성을 높이는 방향성 기발한(clever) 코드가 아니라 클린한 코드 변할 가능성이 있는 의존을 제거함 규모 확장성 (주로)조직 규모, (부가적으로) 컴퓨트 자원 확장에 드는 비용보다 효용이 높은 상태를 유지해야함 트레이드 오프 만병통치약은 없으며 모든 선택 간 트레이드 오프를 따져야함 가설과 추정으로 선택하는 것도 좋지만 데이터로 근거있는 결정을 내리는게 중요할 때가 있다 refs links ","link":"https://chankoo.github.io/posts/%EA%B5%AC%EA%B8%80-%EC%97%94%EC%A7%80%EB%8B%88%EC%96%B4%EB%8A%94-%EC%9D%B4%EB%A0%87%EA%B2%8C-%EC%9D%BC%ED%95%9C%EB%8B%A4/","section":"posts","tags":["책"],"title":"구글 엔지니어는 이렇게 일한다"},{"body":"Next.js 의 페이지 간 이동을 client-side에서 처리하는 것을 의미한다\na 태그를 사용한 전통적인 라우팅과 달리, full page reload 를 (당연히) 하지 않고, 링크가 있으면 prefetching 하여 필요한 데이터(js 파일)를 미리 받아오며, 자체적으로 code splitting과 cache, partial-rendering 을 통해 사용성을 높이는 이점이 있다.\nrefs links Client-Side Routing ","link":"https://chankoo.github.io/posts/client-side-navigation/","section":"posts","tags":["web","frontend","nextjs"],"title":"Client-side Navigation"},{"body":"","link":"https://chankoo.github.io/tags/frontend/","section":"tags","tags":null,"title":"frontend"},{"body":"","link":"https://chankoo.github.io/tags/nextjs/","section":"tags","tags":null,"title":"nextjs"},{"body":"","link":"https://chankoo.github.io/tags/msa/","section":"tags","tags":null,"title":"MSA"},{"body":" 패턴 개괄\n애플리케이션 패턴(application pattern): 개발자가 맞닥뜨리는 문제를 해결합니다. 분해: 시스템을 여러 서비스로 분해하는 기준을 결정하는 것. 비즈니스 능력 \u0026lt;-\u0026gt; 하위 도메인(DDD) 쿼리: 분산 db에서 쿼리하는 방법 API 조합 \u0026lt;-\u0026gt; CQRS 데이터 일관성: 분산 db 간 일관성 유지하는 방법 참고 - 2PC는 가용성 이슈와 성능 이슈 때문에 제외 테스트 자동화: 가급적 E2E를 피하고, 서비스 별로 분리하여 테스트하는 단순화가 필요 consumer-driven contract test / consumer-side contract test / service component test 애플리케이션 인프라(application infrastructure): 개발에도 영향을 미치는 인프라 문제를 해결합니다. 통신: 통신(IPC) 스타일 서비스 디스커버리 신뢰성: 한 서비스가 불능일때 서비스 간 통신의 신뢰성 보장하는 방법 트랜잭셔널 메시징: 여러 서비스에 걸친 트랜잭션의 일관성 보장하는 방법 외부API: 클라이언트와 서비스의 통신 방법 보안: 일반적으로 API 게이트웨이가 인증(인가까지도) 처리. 보통 JWT 같은 액세스 토큰 사용 관측성: 여러 서비스에 걸친 동작의 모니터링과 트러블슈팅을 위한 방법 헬스 체크 / 로그 수집 / 분산 추적 / 예외 추적 / 애플리케이션 지표 / audit logging 횡단 관심사 처리: 횡단(공통) 관심사(cross-cutting concerns)를 한 곳에서 처리하도록 인프라 패턴(infrastructure pattern): 주로 개발 영역 밖의 인프라 문제를 해결합니다. 배포 Microservices Patterns - Conceptual Map refs 마이크로서비스 패턴 El camino de un aprendiz mSVC Patterns links 2PC ","link":"https://chankoo.github.io/posts/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4-%ED%8C%A8%ED%84%B4-%EB%AA%A8%EC%9D%8C/","section":"posts","tags":["MSA","분산시스템"],"title":"마이크로서비스 패턴 모음"},{"body":"응용계층 간의 통신을 위해서 고안된 인터페이스로 어플리케이션에서 시스템(하위 계층)의 자원과 기능을 사용하도록 한다. 프로토콜이 TCP라면, 응용계층에서 TCP/IP로 내려가는 창구가 된다.\n서버 소켓 - 구현상 같은 주소의 소켓이 여러개(하나의 리슨 소켓과 여러개의 통신 소켓)이다. 요청이 리슨 소켓으로 들어오면 accept하여 통신 소켓을 생성한다. 커넥션이 만들어진 후 클라이언트는 통신 소켓과 통신한다. 클라이언트 소켓 - 특정 포트를 선택하는 바인딩 과정 없이 자동으로 포트를 선택한다. 커널이 로컬 포트 중 적당한 포트를 골라 넘겨준다. 스펙상) 소켓은 internet address + port number로 표현하며 네트워크 전체에서 유니크하다. 한쌍의 소켓(src ip, src port, dest ip, dest port) 으로 커넥션이 만들어진다. (위 서버 소켓과 같이 실제 구현은 조금 다르다.)\nrefs 소켓 프로그래밍. (Socket Programming) :: 개발자를 위한 레시피 커널이 로컬 포트를 선택하는 과정 links ","link":"https://chankoo.github.io/posts/%EC%86%8C%EC%BC%93/","section":"posts","tags":["TCP"],"title":"소켓"},{"body":"","link":"https://chankoo.github.io/tags/react/","section":"tags","tags":null,"title":"react"},{"body":"content 데이터 스트림에 영향을 미치는 모든 변경 사항을 observer 들에게 전파하는 프로그래밍\n리액티브 매니페스토\n반응성(responsive) : 리액티브 시스템은 빠를 뿐 아니라 + 일정하고 예상가능한 반응 시간을 제공한다. 회복성(resilient) : 장애가 발생해도 시스템은 반응해야한다. 여러 컴포넌트의 시간과 공간 분리 (즉, 컴포넌트가 각각 독립적인 생명주기를 갖고 다른 프로세스에서 실행), 작업 위임시 비동기적으로 위임하는 등의 기법이 있다. 탄력성(elastic) : 애플리케이션의 생명주기 동안 다양한 부하를 받는데 이때 리액티브 시스템에서는 자동으로 관련 컴포넌트에 할당된 자원 수를 늘린다. 메시지 주도(message-driven) : 회복성과 탄력성을 지원하려면 약한 결합, 고립, 위치 투명성 등을 지원하도록 경계를 명확히 정의한다. 또한 비동기 메시지를 전달해 컴포넌트 간 통신이 이뤄진다. 대표적인 리액티브 프로그래밍 프레임워크(라이브러리)로는\nRxJava, RxJS, RxSwift react refs Reactive Programming 101 : 리액티브 프로그래밍이 뭔가요 | juneyr.dev links ","link":"https://chankoo.github.io/posts/%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/","section":"posts","tags":["MSA","함수형프로그래밍","react"],"title":"리액티브 프로그래밍"},{"body":"","link":"https://chankoo.github.io/tags/api/","section":"tags","tags":null,"title":"api"},{"body":"(주로)MSA에서 프로바이더 서비스들이 제공하는 데이터를 조합하여 한번에 제공하는 API 조합기를 두는 패턴\n설계\nAPI 조합기로 둘 컴포넌트 선정 클라이언트 간단하지만, 클라이언트가 외부 네트워크에 존재하는 경우 느리다 API 게이트웨이 일반적인 방법으로 API 게이트웨이 패턴이라 불림 스탠드 얼론 서비스 \u0026lsquo;주문 검색 서비스\u0026rsquo; 와 같은 서비스를 두어 조합기 역할을 맡기는 방법 효율적인 조합 로직 프로바이더 서비스 순차 호출에 따른 지연 시간을 줄이는 것이 핵심 리액티브 프로그래밍을 권장 refs 마이크로서비스 패턴 links API Gateway 패턴 리액티브 프로그래밍 ","link":"https://chankoo.github.io/posts/api-%EC%A1%B0%ED%95%A9-%ED%8C%A8%ED%84%B4/","section":"posts","tags":["MSA","api"],"title":"API 조합 패턴"},{"body":"content 프록시를 사용하여 서비스 간의 통신을 관리하는 인프라 계층. 도커와 쿠버네티스는 수많은 마이크로서비스의 오케스트레이션을 가능하게 하였고, 이들 서비스 간에 흐르는 트래픽을 추적하고 관리하려는 목적으로 서비스 메시를 사용한다.\n(어플리케이션 레벨이 아니라) 인프라 레벨에서 1) 트래픽 관리 2) observability 3) 보안 강화의 기능을 제공한다.\nrefs 실무자를 위한 서비스 메시 - 지금 서비스 메시가 의미 있는 이유 links ","link":"https://chankoo.github.io/posts/%EC%84%9C%EB%B9%84%EC%8A%A4-%EB%A9%94%EC%8B%9C/","section":"posts","tags":["MSA"],"title":"서비스 메시"},{"body":"content API Gateway Pattern 을 정확히 이해하자 MSA에 API Gateway Pattern이 필수적임 API Gateway Pattern은 API Gateway Framework와는 무관함 내부 api를 제공(단순 라우팅)할 용도로 API Gateway Framework를 쓰지말자 -\u0026gt; controller와 facade가 없는 프레젠테이션 레이어를 구현하게됨 인가 로직이 비즈니스 레이어(각각의 마이크로서비스)에 들어가야해서 오염됨 로직 구현의 책임을 잘못된 곳에 전가함 클라이언트가 여러 로직을 직접 호출하여 조합하거나 특정 서비스가 자신의 도메인인 것처럼 다른 서비스를 호출하여 구현하는 문제 클라이언트와 비즈니스 레이어의 강결합 클라이언트 성능 저하 내부 서비스의 프로토콜 제약 클라이언트에 응답할 수 있는 Http api 로 고정됨 API Gateway Pattern 의 종류 Edge Gateway(중앙 집중식) 가장 일반적인 패턴으로 게이트웨이가 거의 모든 것을 처리함. (마이크로)서비스가 많고, 서비스간(east-west) 트래픽이 많은 경우 적합하지 않음 SSL/TLS termination 인증 (Authentication) 권한 부여 (Authorization) 요청 라우팅 (Request routing) 속도 제한 (Rate limiting) Request/response manipulation Facade routing Two-Tier Gateway(2계층) 보안 게이트웨이와 라우팅 게이트웨이로 역할을 나눔. Edge Gateway 단독으로 쓰는 것보다 유연하지만 라우터 하나에 모든 서비스가 물려있는 한계가 있음 보안 게이트웨이 SSL/TLS termination 인증 (Authentication) 연결 및 요청의 중앙 집중식 로깅 (Centralized logging of connections and requests) 추적 주입 (Tracing injection) 라우팅 게이트웨이 권한 부여 (Authorization) 서비스 발견 (Service discovery) 부하 분산 (Load balancing) Microgateway 2계층을 확장하여 서비스마다 전용 게이트웨이를 두는 방식으로, 서비스 간 트래픽을 관리하는데 용이한 구조 Edge 게이트웨이 SSL/TLS termination 라우팅 (Routing) 속도 제한 (Rate limiting) 마이크로 게이트웨이 부하 분산 (Load balancing) 서비스 발견 (Service discovery) API별 인증 (Authentication per API) Per-Pod Gateway 개별 pod(또는 컨테이너)에 프록시 게이트웨이를 포함하는 형태로 Microgateway를 확장 Sidecar Gateways and Service Mesh(사이드카 게이트웨이 및 서비스 메시) 사이드카 게이트웨이가 ingress와 engress 를 모두 수행하는 형태로 보통 서비스 메시를 통하여 구현된다. 사이드카 게이트웨이 아웃바운드 부하 분산 (Outbound load balancing) 서비스 검색 통합 (Service discovery integration) 서비스 간 인증 (Inter‑service authentication) 권한 부여 (Authorization) refs WOOWACON 마이크로서비스 패턴 효과적인 API 제공을 위한 API Gateway 패턴 선택 - NGINX STORE links 서비스 메시 ","link":"https://chankoo.github.io/posts/api-gateway-%ED%8C%A8%ED%84%B4/","section":"posts","tags":["MSA","api"],"title":"API Gateway 패턴"},{"body":"서버-클라이언트 양방향 일대일 통신을 제공하는 프로토콜\nhttp는 아니지만 http 업그레이드 헤더를 사용하도록 호환된다 통신 상대가 정해져있어 데이터를 절약한다. stateful 하기에 채널을 온메모리로 관리해야한다. refs 리얼월드 HTTP links 소켓 ","link":"https://chankoo.github.io/posts/websocket/","section":"posts","tags":["web","http"],"title":"WebSocket"},{"body":"Server-Sent Events. HTML5 의 기능으로, 한번의 요청에 서버가 여러 이벤트(청크) 전송을 제공하는 프로토콜. http 위에서 동작하는 별도 텍스트 프로토콜이다(text/event-stream).\nrefs 리얼월드 HTTP Server-sent events - Web APIs | MDN links ","link":"https://chankoo.github.io/posts/sse/","section":"posts","tags":["web","http"],"title":"SSE"},{"body":"","link":"https://chankoo.github.io/tags/%EA%B8%B0%EC%96%B5%EC%9E%A5%EC%B9%98/","section":"tags","tags":null,"title":"기억장치"},{"body":"파일 시스템에서 파일 관리를 위해 파일의 위치, 크기, 소유자 등의 정보를 갖고있는 특수한 형태의 파일.\nrefs links 파일 시스템 ","link":"https://chankoo.github.io/posts/%EB%94%94%EB%A0%89%ED%86%A0%EB%A6%AC/","section":"posts","tags":["기억장치","파일시스템"],"title":"디렉토리"},{"body":"","link":"https://chankoo.github.io/tags/%ED%8C%8C%EC%9D%BC%EC%8B%9C%EC%8A%A4%ED%85%9C/","section":"tags","tags":null,"title":"파일시스템"},{"body":"OSI 모델 데이터 링크 계층에서 여러 네트워크를 연결하는 장치. MAC 주소 테이블을 기반으로 네트워크 간 트래픽을 전달하는 역할\nrefs 네트워크 브리지 - 위키백과, 우리 모두의 백과사전 links ","link":"https://chankoo.github.io/posts/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%B8%8C%EB%A6%AC%EC%A7%80/","section":"posts","tags":[],"title":"네트워크 브리지"},{"body":"빠르고 확실하고 저렴한 테스트를 많이 수행해야한다. refs 마이크로서비스 패턴 links ","link":"https://chankoo.github.io/posts/%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%94%BC%EB%9D%BC%EB%AF%B8%EB%93%9C/","section":"posts","tags":null,"title":"테스트 피라미드"},{"body":"content mockist vs classicist\nmockist(aka 런던 학파) - 단위 테스트에 실제 의존성 사용을 피하고, 목과 스텁을 이용해서 요소가 어떻게 상호작용하는지를 테스트해야 한다고 주장 classicis(aka 디트로이트 학파) - 실제 의존성을 테스트하는 것을 최우선으로 두어서, 목과 스텁 보단 페이크를 사용하여 실행 코드의 최종 결과가 무엇인지 확인해야 한다고 주장 refs 좋은 코드 나쁜 코드 Mocks Aren\u0026rsquo;t Stubs links ","link":"https://chankoo.github.io/posts/mock%EA%B3%BC-fake/","section":"posts","tags":null,"title":"Mock과 Fake"},{"body":"테스트할 객체가 의존하는 요소들이 실제 동작하는 것처럼 보이도록 별도로 생성한 가짜 객체이다.\n이렇게 테스트 더블을 생성하여 진행하는 테스트를 고립(Solitary) 테스트라 부른다. 해당 객체가 의존하는 다른 요소들은 테스트하지 않는 방식이다.\n테스트 더블의 종류\nDummy 아무런 기능이 없는 객체로 인터페이스만 필요할때 쓰인다. Fake 동작하지만, 실제와 다른 방식으로 구현된 객체이다. ex) DB 객체를 Hashmap으로 구현 Stub 동작하는 것처럼 만든 더미로 미리 지정된 데이터를 돌려주는 객체이다. Spy Stub으로 기능하면서 부가적인 정보를 기록하는 객체이다. Mock 실제와 같은 구현으로 동작하는 객체이다. 테스트 관련 라이브러리를 통해 실제 객체를 동적으로 생성한다. refs 테스트 더블 (Test Double) links ","link":"https://chankoo.github.io/posts/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%8D%94%EB%B8%94/","section":"posts","tags":null,"title":"테스트 더블"},{"body":"Command와 Query를 다른 것으로 보고 명시적으로 분리하는 패턴. OOP 관점에서 Command를 담당하는 객체와, Query를 담당하는 객체의 책임을 분리하는 것으로 이해하면된다.\nMSA, DDD, 이벤트 소싱 등 다른 기술과 함께 활용되며 다양하게 구현한다.\n특히 마이크로 서비스로 분리한 아키텍처에서는 Query가 어려운데, 여러 서비스에 흩어진 데이터를 조회하는 비용이 크기 때문이다. 그래서 Query 효율을 높이는 관점에서 CQRS를 많이 활용한다.\nrefs 마이크로서비스 패턴 links ","link":"https://chankoo.github.io/posts/cqrs/","section":"posts","tags":["MSA"],"title":"CQRS"},{"body":"refs links ","link":"https://chankoo.github.io/posts/%EC%A2%8B%EC%9D%80-%EC%BD%94%EB%93%9C-%EB%82%98%EC%81%9C-%EC%BD%94%EB%93%9C/","section":"posts","tags":["책"],"title":"좋은 코드 나쁜 코드"},{"body":"2단계 커밋(Two Phase Commit) 으로 분산 트랜잭션 환경에서 트랜잭션을 구현하는 방법이다. 트랜잭션의 커밋을 준비와 실제 동작의 2단계로 나누어, 분산 환경에서 커밋 준비가 완료되면 비로소 실제 커밋을 하는 방식이다.\n2PC 에서 원자성은 2개의 되돌릴 수 없는 포인트에 의해 결정되는데, 1) 참여자가 준비 단계에서 커밋 가능하다고 답변하는 시점과 2) 코디네이터(리소스 매니저)가 커밋하는 시점이다. 1)과 2) 가 만족되면 참여자의 커밋이 어떤 사유로 실패하든, 반복적으로 커밋을 시도한다.\n트랜잭션에 관여하는 모든 서비스가 정상 동작해야하는 가용성 이슈와, 동기적으로 동작하는 성능 이슈 때문에 지고 있는 추세이다.\nrefs [Architecture] MSA : SAGA 패턴이란 - Azderica 데이터 중심 애플리케이션 설계 마이크로서비스 패턴 links 분산 트랜잭션 ","link":"https://chankoo.github.io/posts/2pc/","section":"posts","tags":["MSA","분산시스템"],"title":"2PC"},{"body":"content 분산 트랜잭션 환경에서 서비스 간 비동기 메시징을 이용하여 편성한 일련의 로컬 트랜잭션.\n각 서비스가 변경분 커밋을 수행하고 완료 메시지를 발행하여 다음 서비스의 트랜잭션을 유도한다. 마찬가지로 각 서비스는 보상 트랜잭션(compensatable transaction)을 통해 문제 발생 시 변경분을 발생 역순으로 undo하도록해 롤백한다.\n분상 환경에서 메시징을 이용하는 특성상, saga 그 자체로는 엄격한 Isolation을 제공할 수 없다. 메시지 읽고 처리하는 행위를 격리하기 힘들기에, 메시지 읽는 순서가 바뀐다든지 하는 이슈로 트랜잭션의 결과가 상이한 문제가 생길 수 있는 것이다. 그래서 sementic lock, commutative update, pessimistic view, reread value 등의 대안을 이용한다.\nrefs 마이크로서비스 패턴 links 분산 트랜잭션 Isolation Levels ","link":"https://chankoo.github.io/posts/saga-%ED%8C%A8%ED%84%B4/","section":"posts","tags":["MSA","분산시스템"],"title":"Saga 패턴"},{"body":"content 트랜잭션의 속성(ACID)을 2개 이상으로 분산된 네트워크에서도 만족시키는 트랜잭션.\nX/Open DTP(XA) 모델이라는 표준이 있으며, 이는 2단계 커밋(2PC)를 활용하여 각 리소스를 트랜잭션으로 관리한다. 요즘엔 2PC 대신 Saga 패턴을 쓰는 추세이다.\nrefs 분산 트랜잭션 - 위키백과, 우리 모두의 백과사전 X/Open XA - 위키백과, 우리 모두의 백과사전 마이크로서비스 패턴 links Transaction 2PC Saga 패턴 ","link":"https://chankoo.github.io/posts/%EB%B6%84%EC%82%B0-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/","section":"posts","tags":["MSA","분산시스템"],"title":"분산 트랜잭션"},{"body":"refs links ","link":"https://chankoo.github.io/posts/%EB%A6%AC%EC%96%BC%EC%9B%94%EB%93%9C-http/","section":"posts","tags":["책","http"],"title":"리얼월드 HTTP"},{"body":"HTTP/1.1 이후 이루어진 대규모 업데이트(2015년)로 통신 고속화를 목적으로 하는 프로토콜.\n스트림을 사용해 (텍스트가 아니라) 바이너리 데이터를 다중으로 송수신한다. 서버 푸시를 통해 우선순위 높은 콘텐츠를 클라이언트 요청 없이도 전송할 수 있다. 헤더를 압축(HPACK)해 전송한다. refs 리얼월드 HTTP links 스트림 ","link":"https://chankoo.github.io/posts/http2/","section":"posts","tags":["http"],"title":"HTTP2"},{"body":"google에서 개발한 RPC(Remote Procedure Call) 프레임워크.\n기존 RPC처럼, 네트워크 통신이 필요한 요청을 로컬에서 호출하는 것처럼 도와주는 프로토콜이다. HTTP/2 를 사용하며 프로토콜 버퍼(ProtoBuf)를 이용해 통신 효율을 높이는 특징이 있다.\n일반적인 http 기반 API(REST 등) 보다 더 빠르고(5배 가량), HTTP2의 기능을 사용할 수 있는 것이 장점이다.\nrefs [네이버클라우드 기술\u0026amp;경험] 시대의 흐름, gRPC 깊게 파고들기 #1 | by NAVER CLOUD PLATFORM | NAVER CLOUD PLATFORM | Medium What is RPC? gRPC Introduction. - YouTube links HTTP2 프로토콜 버퍼 ","link":"https://chankoo.github.io/posts/grpc/","section":"posts","tags":["http","api"],"title":"gRPC"},{"body":"refs links ","link":"https://chankoo.github.io/posts/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4-%ED%8C%A8%ED%84%B4/","section":"posts","tags":["책","MSA","분산시스템"],"title":"마이크로서비스 패턴"},{"body":"Cross Site Request Forgery. 타겟 사이트의 사용자 권한을 획득한 피싱(cross) 사이트가 위조된 요청을 타겟 사이트로 날리는 공격. 사용자가 타겟 사이트의 권한을 획득한 채로 피싱 사이트에서 작업하는 방식으로 동작한다.\nrefs links ","link":"https://chankoo.github.io/posts/csrf/","section":"posts","tags":null,"title":"CSRF"},{"body":"Cross Site Scripting. cross site로 쿠키나 세션 등 정보를 탈취하는 스크립트를 삽입하는 방식의 공격\nrefs links ","link":"https://chankoo.github.io/posts/xss/","section":"posts","tags":null,"title":"XSS"},{"body":"OAuth2.0 에서 정의된 내용으로, 인증을 위해 토큰이 정보를 전달(bear)함을 의미하는 문자열이다.\n[header] Authorization: \u0026lt;type\u0026gt; \u0026lt;credentials\u0026gt; Authorization: Bearer {a token} 토큰은 대부분 JWT를 사용한다.\nrefs RFC 6750 - The OAuth 2.0 Authorization Framework: Bearer Token Usage 토큰 기반 인증 Bearer Authentication links JWT OAuth2.0 ","link":"https://chankoo.github.io/posts/bearer/","section":"posts","tags":["인증"],"title":"Bearer"},{"body":"쿠키에 아래 속성을 추가하여 보안을 확보한다.\nHTTP Only XSS 등 자바스크립트 기반 공격에서 쿠키를 보호하기 위해 사용하는 속성으로, true 인 경우 클라이언트(브라우저)에서 쿠키에 접근할 수 없다.\nSecure HTTPS 에서만 쿠키를 전송하는 속성으로, true 인 경우 HTTP에선 쿠키를 전송하지 않는다.\nrefs [Web] HTTP Only와 Secure Cookie 이해하기 links XSS ","link":"https://chankoo.github.io/posts/%EC%BF%A0%ED%82%A4-%EB%B3%B4%EC%95%88/","section":"posts","tags":["http"],"title":"쿠키 보안"},{"body":"쿠키와 세션 보다 토큰 기반 인증 방식(JWT)를 이용하면 장점이 많아 현대 웹, 앱은 대부분 JWT를 쓴다.\n쿠키와 세션은 세션 아이디를 쿠키에 담고, 별도 세션을 저장하는 방식이다. 요청시 세션 아이디를 이용해 저장소의 세션을 확인하여 인증한다. 그렇기에 세션 저장소를 유지하는 비용이 발생하고, 요청이 stateful 한 상태가 되며, 매번 요청시 세션을 조회해야하는 단점이 있다.\n반면에 JWT는 토큰 자체로 인증 여부를 판단하기에 별도 저장소가 필수적이지 않으며 매번 조회 요청을 보내지 않아도 된다. 또한 stateful 하지 않아 확장성이 좋다.\nrefs JWT(Json Web Token) 알아가기 links JWT ","link":"https://chankoo.github.io/posts/%EC%9D%B8%EC%A6%9D-%EB%B0%A9%EC%8B%9D-%EB%B9%84%EA%B5%90/","section":"posts","tags":["http","인증"],"title":"인증 방식 비교"},{"body":"JSON Web Token. 사용자의 정보를 Json에 담아 보내는 형식의 웹 토큰이다.\nHeader / Payload / Signature 로 나뉘며, base64 인코딩을 통해 url-safe한 xxx.yyy.zzz 형태로 표현한다. Header에는 Signature 에 서명한 알고리즘 정보를 담는다. Payload에는 실제 사용자 정보를 Json 형태로 담으며 추가에 열려있다. Signature는 비대칭키 방식을 사용하여 header와 payload가 변경 안되었음을 보증한다.\n주로 인증을 위해 사용하는데, JWT의 유효성(위조 여부)만 확인하면 인증은 완료된다. 이미 JWT 발급 시점에 (id, pwd로) 사용자를 인증했고 그 결과로 JWT를 생성했기에, (Signature를 이용하여) JWT 가 위조되지 않았다는 것만 확인하면 JWT 발급 시점과 같은 사용자라는 것을 알게되는 원리이다.\n동작은 아래와 같다. 액세스 토큰의 유효 기간을 짧게하고, 리프레시 토큰을 사용하여 액세스 토큰이 탈취되는 리스크를 보완한다.\n사용자가 로그인하면, 서버는 JWT(액세스 토큰, 리프레시 토큰)를 발급한다. 사용자는 JWT를 쿠키나 로컬 스토리지에 저장한다. 사용자는 액세스 토큰과 리프레시 토큰을 포함하여 서버에 요청한다. 액세스 토큰이 만료되었다면 서버는 리프레시 토큰을 확인한다. 리프레시 토큰이 인증된다면 서버는 액세스 토큰을 다시 발급한다. 서버는 액세스 토큰의 위조 여부를 확인하여 인증한다. 리프레시 토큰이 탈취되는 경우를 대비해 별도의 토큰 저장소를 운영하기도 한다.\n액세스 토큰과 리프레시 토큰 쌍을 저장하여 리프레시 토큰으로 새 액세스 토큰 발급 요청이 오면 리프레시 토큰으로 기존 액세스 토큰을 조회하여 만료 여부를 확인한다 기존 액세스 토큰이 만료되지 않았다면, 리프레시 토큰이 탈취된 것으로 간주, 리프레시 토큰을 만료시킨다 JWT를 쿠키에 (Http only 옵션 사용하여) 저장하면 브라우저에서(js로) 쿠키 접근이 불가해 XSS로 부터 안전하지만, 매번 request에 권한을 담기 때문에 CSRF로 부터 취약하다.\nrefs JSON Web Token - Wikipedia RFC 7519: JSON Web Token (JWT) 🌐 JWT 토큰 인증 이란? (쿠키 vs 세션 vs 토큰) JWT에서 Refresh Token은 왜 필요한가? JWT는 어디에 저장해야할까? - localStorage vs cookie links 쿠키 보안 XSS CSRF ","link":"https://chankoo.github.io/posts/jwt/","section":"posts","tags":["web","http","인증"],"title":"JWT"},{"body":"heap을 이용하는 q의 구현을 제공하는 모듈\nheap = [] heapq.heappush(heap, item) heapq.heappop(heap) heappush 와 heappop 을 통해 힙 큐를 구현할 수 있다.\n주의할 것은\nheap 은 heap 자료구조가 아님. 선형 자료구조(ex. 리스트) 를 받아 힙의 구현을 도와주는 모듈임 최소 힙을 구현함 0을 제외한 인덱스로 읽지 말자 - heap[0] 을 제외한 값은 정렬된 형태가 아님 refs heapq — 힙 큐 알고리즘 — Python 3.12.0 문서 파이썬의 heapq 모듈로 힙 자료구조 사용하기 | Engineering Blog by Dale Seo links ","link":"https://chankoo.github.io/posts/python-heapq/","section":"posts","tags":["python"],"title":"Python heapq"},{"body":"Back/Forward Cache 는 브라우저가 제공하는 페이지 전체(js 포함) 스냅샷으로, 페이지 전환 이벤트(pageshow, pagehide)가 발생할때 캐시한다.\nrefs Back/forward cache | Articles | web.dev links ","link":"https://chankoo.github.io/posts/bfcache/","section":"posts","tags":["cache","브라우저"],"title":"bfcache"},{"body":"content 클라이언트의 http 요청의 갱신 여부를 파악하기 위해 설정하는 응답 헤더.\n요청 -\u0026gt; 서버가 요청을 Etag 변환(해시 사용) -\u0026gt; 응답 헤더에 Etag 포함 -\u0026gt; 클라이언트가 사용(If-None-Match에 담아)해 요청 -\u0026gt; 동일한 Etag 라면 http 304 Not Modified 반환\nrefs Etag를 이용하여 더 나은 Restful API 만들기 | 요즘IT Conditional View Processing | Django documentation | Django ETag - HTTP | MDN links ","link":"https://chankoo.github.io/posts/etag/","section":"posts","tags":["http","cache"],"title":"Etag"},{"body":"content 테스트를 더 잘하기 위한 패턴으로, 테스트하기 어려운 행위는 \u0026lsquo;험블 객체\u0026rsquo;로 추출해 객체의 역할을 최소화 시키는 방식이다.\n흔한 예로, 험블 객체 패턴으로 프레젠터와 뷰를 나누게 되는데, UI 와 엮인 행위는 테스트가 어려우므로 뷰에 UI 관련 행위만 남겨놓는 것이다. 데이터를 처리하는 행위는 프레젠터가 책임지고 테스트를 완수하며, 뷰는 데이터를 넘겨 받아 뿌려주는 역할만 하는 보잘 것 없는(humble) 모듈이 된다.\nrefs 클린 아키텍처 links ","link":"https://chankoo.github.io/posts/%ED%97%98%EB%B8%94-%EA%B0%9D%EC%B2%B4-%ED%8C%A8%ED%84%B4/","section":"posts","tags":["디자인패턴"],"title":"험블 객체 패턴"},{"body":"컴퓨터 과학에서 통신을 위해 적합한 형식으로 데이터를 변환하는 것.\n마샬링은 객체의 통신 뿐 아니라 서버에서 서버, 프로그램에서 프로그램 등 데이터의 통신을 위한 변환을 통칭한다. 메모리를 공유하지 않는 상황에서, 메모리에 올라간 데이터를 통신을 위한 형태로 변환하는 것이다.\n직렬화는 마샬링의 한 종류이며 복원의 목적으로 객체를 바이트 스트림으로 변환해 저장하는 것을 의미한다.\nrefs 마샬링 (컴퓨터 과학) - 위키백과, 우리 모두의 백과사전 links ","link":"https://chankoo.github.io/posts/marshalling/","section":"posts","tags":null,"title":"Marshalling"},{"body":"content 공통 재사용 원칙; Common Reuse Principle 컴포넌트의 요소가 공통적으로 재사용하는 모듈만 컴포넌트에 포함하라.\n컴포넌트 속 모듈(A)은 사실상 해당 컴포넌트의 모든 모듈과 의존성을 지닌다고 할 수 있다. 다른 모듈이 A에 직접 의존하지 않는다고해도, A의 변경으로 다른 모듈에 변화(재컴파일, 재검증, 재배포)가 발생할 가능성이 있어서 그렇다. 그래서 CRP는 컴포넌트 내 모듈과 강하게 결합하지 않는 모듈(A)을 컴포넌트에 위치시키지 말라고 조언하는 배제의 원칙으로서 기능한다.\nrefs 클린 아키텍처 links 컴포넌트 ","link":"https://chankoo.github.io/posts/crp/","section":"posts","tags":["컴포넌트"],"title":"CRP"},{"body":"content 공통 폐쇄 원칙; Common Closure Principle 컴포넌트는 변경에 대해 닫혀있는 수준이 공통적이어야한다. 즉, 컴포넌트 변경하는 이벤트는 동일한 시점에 동일한 사유로 발생해야하며, 그 외 이벤트로는 변경이 불가해야한다.\n하나의 모듈이 하나의 액터만 책임진다는 SRP의 컴포넌트 수준 원칙이다. 변경 사유가 다른 모듈은 별개 컴포넌트로 분리해야한다,\nOCP 의 Closure와 동일한 의미의 닫혀있음이다.\nrefs 클린 아키텍처 links 컴포넌트 SRP OCP ","link":"https://chankoo.github.io/posts/ccp/","section":"posts","tags":["컴포넌트"],"title":"CCP"},{"body":"content 재사용/ 릴리즈 등가 원칙; Reuse/ Release Equivalence Principle 재사용 단위는 릴리즈 단위와 같아야한다. 즉, 릴리즈 단위인 컴포넌트는 같은 목적으로 재사용 하는 모듈들로 구성해야한다.\nrefs 클린 아키텍처 links 컴포넌트 ","link":"https://chankoo.github.io/posts/rep/","section":"posts","tags":["컴포넌트"],"title":"REP"},{"body":"인터페이스 분리 원칙; Interface Separation Principle 인터페이스를 분리하여, 요소가 사용하는 인터페이스에만 의존하도록 설계해야한다.\nrefs 클린 아키텍처 links SOLID ","link":"https://chankoo.github.io/posts/isp/","section":"posts","tags":["SOLID"],"title":"ISP"},{"body":"","link":"https://chankoo.github.io/tags/solid/","section":"tags","tags":null,"title":"SOLID"},{"body":"한 객체가 여러 형(type)에 속할 수 있는 프로그래밍 언어의 속성. 객체 지향 언어는 동적 바인딩을 제공하여 런타임에 객체의 형을 확정할 수 있게 한다.\n다형성은 객체의 구현 타입에 의존하지 않고 (인터페이스에 의존하는) 추상적인 설계를 가능하게해 요소 간 결합도를 낮춘다.\nrefs 다형성 (컴퓨터 과학) - 위키백과, 우리 모두의 백과사전 links ","link":"https://chankoo.github.io/posts/%EB%8B%A4%ED%98%95%EC%84%B1/","section":"posts","tags":["OOP"],"title":"다형성"},{"body":"리스코프 치환 원칙; Liskov Subsitution Principle 상위 타입 객체는 하위 타입 객체로 별도 조작 없이 치환 가능해야한다.\n객체 지향 언어는 다형성을 제공하기에, LSP를 지킨 설계를 활용하기 유리하다. 사용할 하위 타입을 런타임에 선택하여 상위 타입을 대체하기 용이하다.\nLSP를 위반하면 OCP를 위반하는 것이다. 하위 타입을 추가(확장)하여 상위 타입을 바로 대체할 수 없기 때문이다. LSP를 위반한다면 보통 해당 객체를 사용하는 클라이언트 코드를 수정해야한다. 그리고 이 수정은 끔찍한 형태로 의존을 낳는다. 흔히 드는 예시가 직사각형을 상속한 정사각형 인데, 정사각형은 반드시 너비와 높이가 일치해야하므로 직사각형 객체를 대체할 수 없다. 때문에 다형성을 활용해 의존 없이 짜두었던 클라이언트 코드에 직사각형 여부를 확인하는 방식(isinstanceof 나 downcasting을 사용하는 것이 전형적인 위반이다)으로 코드를 수정해야한다. 수정에는 닫혀 있다는 OCP도 위반하는 것이다.\nrefs 클린 아키텍처 Fetching Title#gtbo links OCP 다형성 SOLID ","link":"https://chankoo.github.io/posts/lsp/","section":"posts","tags":["SOLID"],"title":"LSP"},{"body":"개방-폐쇄 원칙; Open Close Principle 소프트웨어 요소는 확장에는 open, 수정에는 close여야 한다. 수정 보다 비용이 적은 확장으로 소프트웨어를 수정해야한다.\nOCP를 지키기 위해서는 의존 관계를 잘 설계해야한다. 의존 관계가 확장 가능한 요소와 수정해야하는 요소를 결정짓기 때문인데, A -\u0026gt; B (A가 B에 의존)이라면 A는 확장 가능한 요소이고 B는 수정해야하는 요소가 되는 것이다.\n이를 위해 DIP를 지켜야한다. 추상 보다 구현의 변화가 많은데, 구현이 추상에 의존해야 구현을 확장할 수 있기 때문이다.\n모듈 레벨(OOP 클래스)에만 적용되는 원칙이 아니다. 오히려 아키텍처 컴포넌트 수준에서 OCP를 지킨다면 더 효과가 클 수 있다.\nrefs 클린 아키텍처 links DIP SOLID ","link":"https://chankoo.github.io/posts/ocp/","section":"posts","tags":["SOLID"],"title":"OCP"},{"body":"런타임에 소프트웨어를 구성하는 요소. (컴파일 언어의 경우) 실행 가능한 바이너리 형태이며, 코드로 확인 가능한 모듈과 달리 가시성이 없다.\n(잘 설계한다면)컴포넌트는 독립적으로 배포 가능한 단위이다. 시스템은 컴포넌트 단위로 쪼개지며, 각 컴포넌트는 다른 컴포넌트에 영향 주지 않고 개발, 배포한다.\nrefs 개발자에서 아키텍트로 클린 아키텍처 links 모듈 컴포넌트 설계 원칙 ","link":"https://chankoo.github.io/posts/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/","section":"posts","tags":["컴포넌트"],"title":"컴포넌트"},{"body":"설계 시점에 다루는 코드 덩어리. 시점상 가장 먼저 구현하는 단위\nrefs 개발자에서 아키텍트로 클린 아키텍처 links 컴포넌트 ","link":"https://chankoo.github.io/posts/%EB%AA%A8%EB%93%88/","section":"posts","tags":null,"title":"모듈"},{"body":" 아키텍트는 기술과 비즈니스 그리고 사용자를 모두 이해해야한다. 유저영역의 문제를 엔지니어링 관점에서 정의하여 소프트웨어 아키텍처를 설계한다. 아키텍처는 품질 속성과 기술 부채를 고려하여 시스템을 요소로 분리해야한다. 그리고 큰 그림 속에서 요소들을 연결하고 통합한다. 아키텍트로서 프로젝트 정리 이해관계자들은 누구였고 주요 비즈니스 목표는 무엇이었는가 최종적으로 어떤 결과를 도출했는가 어떤 기술을 사용했는가 가장 큰 리스크는 무엇이었고, 어떻게 극복했는가 다시 시작할 수 있다면 어떤 점을 다르게 하겠는가 refs links ","link":"https://chankoo.github.io/posts/%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%97%90%EC%84%9C-%EC%95%84%ED%82%A4%ED%85%8D%ED%8A%B8%EB%A1%9C/","section":"posts","tags":["책"],"title":"개발자에서 아키텍트로"},{"body":"모듈 수준의 소프트웨어 설계 원칙으로 다섯가지 원칙의 앞글자를 따서 부른다.\nrefs 클린 아키텍처 links 모듈 SRP OCP LSP ISP DIP ","link":"https://chankoo.github.io/posts/solid/","section":"posts","tags":["SOLID"],"title":"SOLID"},{"body":"단일 책임 원칙 - Single Responsibility Principle 모듈은 한 액터(사용자, 이해관계자)만 책임진다. 모듈을 변경한다면 그 이유는 반드시 한 액터 때문이어야 한다.\nSRP를 따르면, 여러 액터의 요구를 책임지는 모듈은 책임을 찢어야 한다.\n예를 들어 클래스 Employee가 재무팀을 위한 급여 계산 / 인사팀을 위한 업무 시간 계산을 책임지고 있다면, 이는 SRP를 위반한다. 그래서 -\u0026gt; 급여 계산을 위한 클래스와 업무 시간 계산을 위한 클래스로 책임을 분리하고, EmployeeFacade 클래스를 두어 인터페이스를 정리할 수 있다.\nrefs 클린 아키텍처 links SOLID 퍼사드 패턴 ","link":"https://chankoo.github.io/posts/srp/","section":"posts","tags":["SOLID"],"title":"SRP"},{"body":"refs links ","link":"https://chankoo.github.io/posts/gof%EC%9D%98-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/","section":"posts","tags":["책","디자인패턴"],"title":"GoF의 디자인 패턴"},{"body":"content 서브 시스템(클래스들)을 숨기고 대표 인터페이스 하나(퍼사드)만 공개하는 디자인패턴. 퍼사드는 서브시스템 내 모든 인터페이스 집합을 상위 수준에서 제공한다.\n객체 캡슐화와 유사한데, 캡슐화는 객체의 구현을 감추는 것이고 퍼사드는 서브 시스템의 구현을 감춘다.\nrefs GoF의 디자인 패턴 links 캡슐화 ","link":"https://chankoo.github.io/posts/%ED%8D%BC%EC%82%AC%EB%93%9C-%ED%8C%A8%ED%84%B4/","section":"posts","tags":["디자인패턴"],"title":"퍼사드 패턴"},{"body":"싱글 스레드에서 요청을 비동기로 처리하기 위해 사용하는 루프.\n(gevent에서) I/O 요청시 커널에 요청을 주고 커널로 부터 응답 받은 이벤트를 처리하기 위해 돌고있는 루프 유저 영역 요청 -\u0026gt; 이벤트 루프 -\u0026gt; 이벤트 루프 응답 -\u0026gt; 대기하며 진행 커널 영역 블락 -\u0026gt; 이벤트 발생 -\u0026gt; 이벤트 루프에 노티 -\u0026gt; 대기 중인 것을 실현 (javascript에서) 콜백 큐에서 콜백 함수를 꺼내 콜 스택에 넣어 주는 루프 refs DEVIEW 2014 [JS] 도대체 이벤트 루프가 뭔가요? - 배하람의 블로그 links gevent 비동기 ","link":"https://chankoo.github.io/posts/event-loop/","section":"posts","tags":["javascript","동시성","python"],"title":"Event Loop"},{"body":"","link":"https://chankoo.github.io/tags/javascript/","section":"tags","tags":null,"title":"javascript"},{"body":"","link":"https://chankoo.github.io/tags/docker/","section":"tags","tags":null,"title":"docker"},{"body":" 도커 네트워크는 docker0 라는 이름의 가상 네트워크 브리지(bridge 옵션이 디폴트)로 구성된다. docker0 는 도커 내부 로직에 따라 16bit netmask의 ip를 할당 받으며, 컨테이너들의 gateway로 기능한다.\n컨테이너들은 docker0와 pair interface로 통신하는데, docker0 쪽은 vethXXX, 컨테이너 쪽은 eth0 라는 이름으로 구성되어 서로 packet을 주고받는다. 컨테이너는 Linux Namespace 를 이용하여 각자 독립적인 네트워크 공간을 할당받는다\nrefs Networking overview | Docker Docs link 네트워크 브리지 ","link":"https://chankoo.github.io/posts/%EB%8F%84%EC%BB%A4-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/","section":"posts","tags":["docker"],"title":"도커 네트워크"},{"body":"유닉스 기반 OS에서 프로세스가 내부적으로 저장한 파일의 추상표현으로, 음이 아닌 정수이다.\n프로세스가 파일을 열면 OS는 해당 프로세스의 파일 디스크립터 중 가장 작은 값을 할당해준다. 다음부터 프로세스가 파일에 접근할 때는 파일 디스크립터 값을 인덱스로 사용한다. 해당 FD로 파일 테이블 포인터를 찾은 뒤, 시스템 파일을 참조(Inode에 접근)한다.\n0 ~ 2는 예약된 자리로 각각 표준 입력, 표준 출력, 표준 에러 출력을 의미한다.\nrefs 파일 디스크립터(File Descriptor)란? links 파일 inode ","link":"https://chankoo.github.io/posts/%ED%8C%8C%EC%9D%BC-%EB%94%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%84%B0/","section":"posts","tags":["파일시스템"],"title":"파일 디스크립터"},{"body":"매직 메서드 get, set, delete 중 하나 이상을 정의한 객체를 의미하며, 클래스 변수에 저장한 객체(디스크립터 객체)의 어트리뷰트를 제어하는 기능을 한다. 즉, 디스크립터를 이용하면 객체 어트리뷰트의 lookup, storage, and deletion을 커스터마이징할 수 있다.\n보통 인스턴스 데이터에 대한 접근을 관리하는 용도로 쓰인다. ex) django.models.fields.FileField 의 FileDescriptor -\u0026gt; FileField를 가져올때 항상 FieldFile을 내놓도록 제어\nrefs [Chapter .06] 디스크립터로 더 멋진 객체 만들기 - 파이썬 틀린코드 (Feat. 파이썬 클린코드) [Python] 디스크립터(Descriptor) links FileField ","link":"https://chankoo.github.io/posts/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EB%94%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%84%B0/","section":"posts","tags":["python"],"title":"파이썬 디스크립터"},{"body":"업로드한 파일을 위한 Django Field 객체로 DB 테이블의 컬럼을 추상화했다. 파일을 추상화한 FieldFile 객체의 wrapper이다. 생성을 위해 파일 시스템을 추상화한 Storage 의 구현체와 path로 지정할 문자열(upload_to)가 필요하다.\nFileField 를 get 하면 항상 FieldFile 객체를 가져오는데, 이는 파이썬의 디스크립터를 이용하여 기능한다. FileField에 descriptor_class로 FileDescriptor 객체가 선언되어있어서, FileField 를 가져올때 Dynamic lookup 을 통해 FieldFile을 내어놓는 것이다.\nrefs Model field reference | Django documentation | Django links 파일 시스템 파이썬 디스크립터 ","link":"https://chankoo.github.io/posts/filefield/","section":"posts","tags":["django"],"title":"FileField"},{"body":"content 연산을 수행하는 비용(시간, 공간)의 상한을 대략적으로 표기하는 방법\n비용이 어떤 비율로 증가하는지(상수, 선형, 로그, 지수 등)에만 관심있어서 지배적이지 않은 항은 무시한다 O(2N) == O(N) O(log_2(N)) == O(log_10(N)) refs links ","link":"https://chankoo.github.io/posts/big-o/","section":"posts","tags":null,"title":"Big-O"},{"body":"알고리즘을 수행 과정 별로 분할하여 비용(시간 복잡도)을 구하는 분석 방법. 일련의 연산들을 구분하여 평균적인 비용을 낸다는 측면에서 worst-case approach 보다 현실적일 수 있다.\nrefs 분할상환분석 - 위키백과, 우리 모두의 백과사전 links Big-O ","link":"https://chankoo.github.io/posts/%EB%B6%84%ED%95%A0-%EC%83%81%ED%99%98-%EB%B6%84%EC%84%9D/","section":"posts","tags":null,"title":"분할 상환 분석"},{"body":"캐시 라인(or cache block)은 프로세서의 캐시가 메모리로 부터 읽어오는 데이터 chunk.\n보통 32, 64, 128 바이트 사이즈이다. 예를 들어 캐시 라인 사이즈가 64B이고 64kB 크기의 캐시를 쓴다면, 캐시는 1024개(= 64kB / 64B) 라인으로 구성된다.\nrefs 3.2. Cache Lines and Cache Size links ","link":"https://chankoo.github.io/posts/cache-line/","section":"posts","tags":["cache"],"title":"cache line"},{"body":"","link":"https://chankoo.github.io/tags/cpu/","section":"tags","tags":null,"title":"CPU"},{"body":"(프로세서의 메모리)참조는 랜덤이 아니고 비슷한 지역에서 빈번하게 일어난다는 특성(Locality of reference)\nSpatial Locality 와 2) Temporal Locality로 크게 나뉘는데 1)은 비슷한 공간의 영역을 반복적으로, 2)는 최근에 참조한 영역을 반복적으로 참조하는 현상을 말한다. 프로세서의 캐시는 locality를 고려하여 동작하기에 프로그램을 짤 때 locality를 활용한다면 더 캐시 효율적이다.\nrefs Locality of reference - Wikipedia links ","link":"https://chankoo.github.io/posts/locality/","section":"posts","tags":["CPU","cache"],"title":"locality"},{"body":"","link":"https://chankoo.github.io/tags/java/","section":"tags","tags":null,"title":"java"},{"body":"(해시) 충돌은 1) 서로 다른 값이 동일한 해시를 뱉거나(해시 충돌) 2) 서로 다른 해시가 동일한 인덱스를 뱉는 경우를 말한다.\n해시 자료구조를 구성할때 모든 key가 충돌한다면, 탐색에 O(n)이 걸린다.\n모든 데이터가 하나의 인덱스에 저장(Separate Chaning)되거나 다른 인덱스에 순차적으로 저장(Open Addressing)될 것이기 때문이다. 저장할 값의 배열이 크지 않다면, Open Addressing 이 캐시 효율적이다. 연속된 공간에 저장한 데이터는 함께 캐싱될 것이고(cache line), spatial locality 에 따라 hit ratio가 높을 것이기 때문이다. 파이썬이 오픈 어드레싱 방식을 쓴다.\n반면, 배열이 커지면 배열이 한꺼번에 캐싱되지 않아 캐시 효율은 떨어진다. 그러면 Separate Chaining의 효율이 높아지는데, 리스트에서 remove 연산의 효율이 배열보다 좋기 때문이다.(자바의 Hashmap 은 Separate Chaining을 쓴다)\nrefs NAVER D2 caching - Cache Performance in Hash Tables with Chaining vs Open Addressing - Stack Overflow links cache line locality ","link":"https://chankoo.github.io/posts/%ED%95%B4%EC%8B%9C-%EC%B6%A9%EB%8F%8C/","section":"posts","tags":["java","python"],"title":"해시 충돌"},{"body":"content 임의 길이 데이터를 해시 함수를 통해 변환한 값으로, 1) 길이가 고정이고 2) 변환 전 값을 구하는 역함수가 없다.\nrefs links ","link":"https://chankoo.github.io/posts/%ED%95%B4%EC%8B%9C/","section":"posts","tags":null,"title":"해시"},{"body":"해시를 이용해서 key: value 쌍을 저장하고 O(1) 에 value를 찾는 자료구조이다.\n해시 함수를 통해 immutable 한 key에서 해시를 얻는다 크기를 고정한(n) 배열을 생성하고 해시를 인덱스(0~n-1)로 변환하여(보통 modulo 연산. 해시 % n) 배열의 인덱스에 키 밸류를 저장한다 리스트, 그래프 형태로(Separate Channing)로 저장하거나 인접한 다른 인덱스에 삽입(Open Addressing)한다. (해시) 충돌이 발생하면 최악의 경우 탐색에 O(n)이 걸린다.\nrefs links 해시 해시 충돌 ","link":"https://chankoo.github.io/posts/%ED%95%B4%EC%8B%9C-%ED%85%8C%EC%9D%B4%EB%B8%94/","section":"posts","tags":null,"title":"해시 테이블"},{"body":"저장 장치에 접근할 수 있는 경로를 특정 디렉토리에 연결하여, 디렉토리 구조에 편입하는 일\nrefs links 디렉토리 ","link":"https://chankoo.github.io/posts/%EB%A7%88%EC%9A%B4%ED%8A%B8/","section":"posts","tags":["기억장치"],"title":"마운트"},{"body":"블록 단위로 데이터 전송하는 기억장치. 캐릭터 디바이스에 비해 전송 속도가 빠르다.\nrefs links ","link":"https://chankoo.github.io/posts/%EB%B8%94%EB%A1%9D-%EB%94%94%EB%B0%94%EC%9D%B4%EC%8A%A4/","section":"posts","tags":["기억장치"],"title":"블록 디바이스"},{"body":"바이트 단위로 데이터 전송하는 문자 기반 기억장치. 키보드, 마우스, 모니터 등\nrefs links ","link":"https://chankoo.github.io/posts/%E1%84%8F%E1%85%A2%E1%84%85%E1%85%B5%E1%86%A8%E1%84%90%E1%85%A5-%E1%84%83%E1%85%B5%E1%84%87%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3/","section":"posts","tags":["기억장치"],"title":"캐릭터 디바이스"},{"body":"","link":"https://chankoo.github.io/tags/aws/","section":"tags","tags":null,"title":"AWS"},{"body":"AWS Elastic Block Store AWS가 제공하는 기본 블록 디바이스. 네트워크 통신하는 논리 드라이브(볼륨)이다.\nrefs links 블록 디바이스 볼륨 ","link":"https://chankoo.github.io/posts/ebs/","section":"posts","tags":["기억장치","AWS"],"title":"EBS"},{"body":"Process Control Block. 프로세스 관리를 위한 정보를 담은 OS 커널의 자료구조이다. 프로세스 실행과 스케줄링 등에 필요한 정보를 포함하여 OS 입장에서 프로세스를 표현한다.\nrefs links ","link":"https://chankoo.github.io/posts/pcb/","section":"posts","tags":["CPU"],"title":"PCB"},{"body":"유닉스 계통 파일 시스템에서 사용하는 자료구조.\n수퍼블록 - 파일시스템과 파티션 정보(df) inode 블록 - PCB와 유사하게 (inode 방식의) 파일 메타 데이터를 갖는다. 파일과 일대일 매핑 (compare with directory entry) 데이터 블록 - 실제 정보를 저장한 블록(디스크 블록) refs links 파일 시스템 PCB ","link":"https://chankoo.github.io/posts/inode/","section":"posts","tags":["파일시스템"],"title":"inode"},{"body":"","link":"https://chankoo.github.io/tags/unix/","section":"tags","tags":null,"title":"UNIX"},{"body":"OS가 저장 매체의 정보를 관리하는 단위. 저장할(디스크에 쓸) 때 블록(보통 4kb) 단위로 정보를 묶어서 쓰고, 그 참조를 관리한다.\n윈도우에선 \u0026lsquo;클러스터\u0026rsquo;라는 용어도 쓴다.\nrefs links ","link":"https://chankoo.github.io/posts/%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A9%E1%86%A8/","section":"posts","tags":["기억장치","UNIX"],"title":"블록"},{"body":"OS가 사용자에게 제공하는 논리적, 추상적인 정보 집합. 파일 내 실제 정보는 블록 단위로 관리한다.\n(Linux 에서 모든 것은 파일이다)\nrefs links 파일 시스템 ","link":"https://chankoo.github.io/posts/%ED%8C%8C%EC%9D%BC/","section":"posts","tags":["기억장치"],"title":"파일"},{"body":"OS 가 파일을 쉽게 관리하도록 파일을 보관하고 조직하는 체계.\n효율적으로 파일을 저장하기 위해 파일 시스템이 등장했다. 불연속적인 저장 매체 공간에 파일을 체계적으로 저장하고 불러오는 자료구조와 알고리즘을 포함한다.\n블록체인(링크드리스트) 인덱스 블록 기법 refs links 파일 ","link":"https://chankoo.github.io/posts/%ED%8C%8C%EC%9D%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C/","section":"posts","tags":["파일시스템"],"title":"파일 시스템"},{"body":"파일시스템을 갖춘 논리적 스토리지 영역. 보통 마운트하여 접근한다.\nrefs links 마운트 파일 시스템 ","link":"https://chankoo.github.io/posts/%EB%B3%BC%EB%A5%A8/","section":"posts","tags":["기억장치","파일시스템"],"title":"볼륨"},{"body":"","link":"https://chankoo.github.io/tags/%EA%B4%91%EA%B3%A0/","section":"tags","tags":null,"title":"광고"},{"body":"GTM 태그(어플리케이션에 삽입하여 이벤트를 전송하는 코드)를 관리하는 역할을 한다. 태그가 전송한 데이터를 분석하는 툴과는 별개이다.\nrefs links ","link":"https://chankoo.github.io/posts/%EA%B5%AC%EA%B8%80-%ED%83%9C%EA%B7%B8-%EB%A7%A4%EB%8B%88%EC%A0%80/","section":"posts","tags":["광고"],"title":"구글 태그 매니저"},{"body":"","link":"https://chankoo.github.io/categories/%EA%B8%B0%ED%83%80/","section":"categories","tags":null,"title":"기타"},{"body":"프로젝트 규모에 따라 설계 최적점이 다르다. 일반적으로 큰 규모 프로젝트 일수록, 설계 시간을 투입함에 따라 재작업 비용을 크게 줄일 수 있기 때문이다.\nrefs 개발자에서 아키텍트로 links ","link":"https://chankoo.github.io/posts/%EC%84%A4%EA%B3%84-%EC%B5%9C%EC%A0%81%EC%A0%90/","section":"posts","tags":null,"title":"설계 최적점"},{"body":"객체를 초기화하고, 멤버 변수를 할당하여 객체를 (개념적으로)생성하는 서브루틴.\npython의 예를 들면, python 객체는 new 를 통해 메모리에 할당되며, init 을 통해 멤버 변수를 정의한다. (개념적인) 객체의 생성이 init 을 통해 이루어졌으므로, init 이 python의 생성자라 할 수 있다.\nrefs Constructor (object-oriented programming) - Wikipedia Object lifetime - Wikipedia Python: __init__() is not the only constructor - DEV Community links ","link":"https://chankoo.github.io/posts/%EC%83%9D%EC%84%B1%EC%9E%90/","section":"posts","tags":["OOP","python"],"title":"생성자"},{"body":"제너레이터는 제어 흐름을 양보할 수 있는 Iterator이다. 루프를 순회하는 도중 의도적으로 순회를 멈추고, 자신을 호출한 루틴으로 제어 흐름을 양보할 수 있다. 때문에 semicoroutine 이라고도 불리는데, (제어 흐름을 넘겨줄 routine을 지정할 수 있는) coroutine 의 특수한 형태이기 때문이다.\n이러한 제너레이터의 동작은 1) 메모리 효율 2) 동시성 의 관점에서 살펴볼만하다. 루프 내 요소의 평가가 필요할때 메모리에 요소를 올리는 lazy evaluation 이고, 원하는 시점에 제어흐름을 넘겨가며 동시성 프로그래밍을 가능케하는 pseudo thread 이기 때문이다.\nrefs Generator (computer programming) - Wikipedia links Iterator coroutine ","link":"https://chankoo.github.io/posts/generator/","section":"posts","tags":["python"],"title":"Generator"},{"body":"특정 집합 객체 요소에 순차적으로 접근 가능하도록 구현해놓은 객체. Iterator 패턴을 따라서 내부를 노출하지 않고 집합 객체의 구현에 종속되지 않아야한다.\nIterator 를 제공하는 객체는 Iterator Protocol 을 따랐다고 표현하는데, 이는 언어마다 상이하다. 에를 들어 javascript 에선 Iteration Protocol 하위에 Iteration Protocol 과 Iterator Protocol이 존재한다.\n구현은 프로그래밍 언어마다 다양할 수 있다. 보통 Iterable 객체와 묶여서 구현한다. python과 java 모두 Iterable 객체로 부터 Iterator를 얻으며(iter, iterator()), 다음 요소를 가져오는 메소드를 제공한다(next, next()). 그리고 Iterable 을 상속받은 기본 자료형이 존재한다. 이 자료형들은 순회를 위한 코드를 따로 작성하지 않아도 Iterator 를 통해 반복 가능하다. for _ in Iterable 객체: 와 같은 형태로 작성하면 Iterable 객체가 내부적으로 Iterator를 통해 다음 요소를 불러오는 것이다.\nrefs GoF의 디자인 패턴 파이썬 코딩 도장: 39.1 반복 가능한 객체 알아보기 [Java] Iterable과 Iterator :: 그냥 그냥 블로그 links ","link":"https://chankoo.github.io/posts/iterator/","section":"posts","tags":["디자인패턴","python","javascript","java"],"title":"Iterator"},{"body":"Asynchronous Server Gateway Interface. 파이썬 웹 애플리케이션과 웹 서버의 공통 인터페이스를 기술한 프로토콜.\nWSGI 처럼, 프로토콜 서버 내 앱들에게 표준화된 요청/응답을 주고받는 방식이나, ASGI는 비동기 방식으로 이벤트를 주고 받는 구조적인 차이가 있다.\nrefs ASGI (Asynchronous Server Gateway Interface) Specification — ASGI 3.0 documentation \u0026ldquo;파이썬 웹 개발의 미래\u0026rdquo; ASGI의 개념과 활용 방법 - ITWorld Korea links WSGI ","link":"https://chankoo.github.io/posts/asgi/","section":"posts","tags":["web","python"],"title":"ASGI"},{"body":"WSGI(Web Server Gateway Interface) 는 파이썬 웹앱과 웹서버 간 통신 인터페이스 명세이다.\nrefs links ASGI gunicorn ","link":"https://chankoo.github.io/posts/wsgi/","section":"posts","tags":["web","python"],"title":"WSGI"},{"body":"Co-Routine. 다른 루틴과 동등한 레벨에서 상호 협력하는 루틴. routine - subroutine 으로 종속되는 개념과 대비된다.\n프로그래머는 코루틴 간 제어 흐름을 의도에 따라 통제하는데, 실행 중인 코루틴이 자신의 흐름을 멈추고 다른 코루틴에 양보(yield) 하도록 하는 방식이다.\n코루틴 간의 스위칭을 통해 (스레드 스위칭과 유사하게) 동시성 프로그래밍할 수 있다. 코루틴이 \u0026ldquo;lightweight\u0026rdquo; 스레드라고도 불리는 이유이다.\n스레드와의 주된 차이는, 별도의 스택 메모리를 갖지 않는다(stackless coroutine)는 점, 병렬 실행이 불가하다는 점 등이 있다.\n+) 작업 후 다른 루틴에게 명시적으로 제어권을 넘겨줄 경우, CPS를 따라 구현했다고 볼 수 있다.\nrefs 파이썬과 동시성 프로그래밍 - Sungho\u0026rsquo;s Blog Coroutine, Thread 와의 차이와 그 특징 - Crucian Carp links 동시성 스레드 CPS ","link":"https://chankoo.github.io/posts/coroutine/","section":"posts","tags":["동시성"],"title":"coroutine"},{"body":"range select 하는 쿼리를 반복해서 실행할때, 다른 트랜잭션의 영향으로 결과 셋이 달라지는 현상. 존재하지 않는(phantom) 새로운 행들이 나타나거나, 그렇게 나타난 행들이 사라지는 상태를 의미한다.\nSerializable을 제외한 격리 수준에서 모두 발생한다. gap lock을 쓰지 않는다면, range select 쿼리의 대상인 rows set 외에는 락이 걸려있지 않으므로, 다른 트랜잭션이 새로운 row를 만들 수 있고, 그 row가 다음번 range select 에 걸릴 수 있는 것이다.\nrefs links Isolation Levels 직렬성 ","link":"https://chankoo.github.io/posts/phantom-reads/","section":"posts","tags":["동시성"],"title":"Phantom Reads"},{"body":"DB 에서 직렬성은 모든 트랜잭션을 순차적으로 수행하는 것과 같은 결과를 내는 격리 수준을 의미한다.\n보통 아래 세가지 방법 중 하나로 구현하는데,\n실제적인 직렬 실행 - 순차적으로 트랜잭션을 실행한다. 2PL 낙관적 동시성 제어(ex. 직렬성 스냅숏 격리) refs 데이터 중심 애플리케이션 설계 links 2PL Isolation Levels ","link":"https://chankoo.github.io/posts/%EC%A7%81%EB%A0%AC%EC%84%B1/","section":"posts","tags":["동시성"],"title":"직렬성"},{"body":"DB에서 데이터를 조작하는 논리적 작업 단위. 이론적으로 Transaction은 ACID해야한다.\n예로 들면, 송금은 한 Transaction 이어야 하는데, 송금을 구성하는 1) 본인 계좌에서 출금 2) 상대 계좌에 입금이\nAtomic - 발생하거나, 발생하지 않거나하여 그 중간 상태가 없어야하며 Correct(Consistant) - 송금 실행 전 후 모두 관련된 제약을 지키는 상태여야하며 Isolated - 송금 실행 중 다른 Transaction과는 격리(read x, write x)되어야 하며 Durable - 송금 성공의 시점 데이터를 지속적으로 보관해야한다. refs links ","link":"https://chankoo.github.io/posts/transaction/","section":"posts","tags":null,"title":"Transaction"},{"body":"가상 컴퓨터의 실행 프로그램을 위한 이진 표현법. 하드웨어가 아니라 소프트웨어에서 해석되기에 기계어보다 더 추상적이다.\nrefs 바이트코드 - 위키백과, 우리 모두의 백과사전 links ","link":"https://chankoo.github.io/posts/bytecode/","section":"posts","tags":["python"],"title":"Bytecode"},{"body":"ISA를 구현하는 방법을 말한다.\n예를들어, Intel 과 AMD는 동일한 x86 ISA를 쓰지만 Microarchitecture가 다르기에 성능이 다르다.\nrefs links ISA ","link":"https://chankoo.github.io/posts/microarchitecture/","section":"posts","tags":["CPU"],"title":"Microarchitecture"},{"body":"명령어 집합 구조(Instruction Set Architecture) CPU가 이해할 수 있는 기계어 명령어 집합을 의미한다. CPU 마다 비트 길이와 코드가 다르다.\n각 비트를 기능적으로 분할하여 의미를 부여했고, 이 기계어 명렁어와 일대일 매핑하여 문자화 한 것이 어셈블리어(Assembly Language)다.\n이는 소프트웨어와 하드웨어간 인터페이스를 규정한 것이다.\n프로세서 칩을 만드는 회사마다 ISA가 다른데, 익숙한 예로 Intel의 칩은 x86을, ARM의 칩은 ARM 을 쓰는 식이다.\nrefs 명령어 집합 - 위키백과, 우리 모두의 백과사전 [ 컴퓨터구조 ] ISA (Instruction Set Architecture) links Assembly Language ","link":"https://chankoo.github.io/posts/isa/","section":"posts","tags":["CPU"],"title":"ISA"},{"body":"ISA의 명령어를 문자화 시킨 저급 언어이다. 프로그래머가 기계어를 다룰 수 있도록 고안되었고, 기계어 명령어와 일대일 대응한다. 그래서 ISA 의존적이고, 하드웨어 이식성이 낮다.\nrefs [Chapter 7] Assembly Language - 어셈블리어, 어셈블러 links ISA ","link":"https://chankoo.github.io/posts/assembly-language/","section":"posts","tags":[],"title":"Assembly Language"},{"body":"어셈블리 언어(Assembly Language)를 기계어로 어셈블(assemble)하는 프로그램. 어셈블은 CPU의 ISA에 맞게 이루어진다.\n하나의 프로그램을 어셈블하면 여러 개의 소스 파일로 나뉠 수 있다. 이러한 파일(기계어 조각)을 합쳐서 하나의 실행 가능한 파일로 만드는 프로그램을 링커(Linker)라 하며, 그 파일의 코드와 데이터를 메모리에 올리고, 해당 프로그램의 시작 주소로 CPU를 제어하도록 하는 프로그램이 로더(Loader)이다.\nrefs [Chapter 7] Assembly Language - 어셈블리어, 어셈블러 links Assembly Language ISA ","link":"https://chankoo.github.io/posts/assembler/","section":"posts","tags":[],"title":"Assembler"},{"body":"파이썬 바이트코드 역 어셈블러. CPython의 바이트 코드를 역 어셈블하여 바이트 코드 레벨의 분석을 돕는 모듈이다.\nex)\ndef hi(x): x += 1 print(x) return x 위 정의에 따르면, 추상화한 바이트코드를 바이트코드로 바꾸는 것도 어셈블이라 볼 수 있다.\nrefs dis \u0026mdash; 파이썬 바이트 코드 역 어셈블러 — 파이썬 설명서 주석판 links Bytecode Assembler ","link":"https://chankoo.github.io/posts/dis/","section":"posts","tags":["python"],"title":"dis"},{"body":"Transaction 간 격리 수준\nDBMS는 다양한 수준의 Isolation Level을 제공하여 ACID의 Isolation 관점에서 엄격히 제한된 Transaction의 병행성 제약을 완화한다. 이상적으로 Transaction은 엄격히 격리해야 하지만, 실무적으로 걸림돌이 되기에, 격리 수준을 단계적으로 완화하는 Isolation Levels 를 정의하여 상황에 맞게 제공한다.\nSerializable - Isolation 제약을 지키는 수준으로 트랜잭션을 serial schedule 로 수행하여 다른 트랜잭션의 수행과 겹치는 시간이 없다. Repetable Reads 반복해서 읽어도 같은 결과를 보여주는 수준으로, 반복 read 도중 커밋이 발생하여 값이 변해도 커밋 전 값을 읽어간다. (mysql innodb 에서 default) 스냅숏 격리를 통해 구현하여 과거 스냅숏을 보여줌으로써 일관된 읽기를 가능케한다. 즉, 트랜잭션의 첫 읽기 발생시에 스냅숏을 가져와 이후 연산은 그 스냅숏을 기준으로 수행한다. Phantom Reads 는 발생한다. Read Committed 가장 기본적인 격리(postgre에서 default)로 커밋된 결과라면 다 읽어버리는 수준이다. 두가지를 보장하는데, 1) 더티 읽기와 2) 더티 쓰기가 발생하지 않는다. 즉, 커밋 안된 변경을 다른 트랜잭션이 읽어가지 않고, 커밋 안된 쓰기 연산 중에는 다른 트랜잭션이 끼어들 수 없다. 더티 읽기를 없애면 변경 중인 결과를 읽어가서 생기는 혼란을 줄인다. 특히 롤백이 발생하는 경우, 커밋 안된 결과를 읽어갔다면 매우 혼란스러운 결과로 이어질 것이다. 더티 쓰기를 없애면 특정 트랜 잭션 간 내용이 섞인 채 기록되는 문제를 막는다. 대부분의 DB가 해당 격리를 구현하는 방법은, 트랜잭션에서 쓰여진 모든 객체에 쓰기 잠금을 부여하고, 다른 트랜잭션엔 과거 스냅숏을 보여주는 것이다. (읽기 잠금으로 구현하면 동시성이 매우 떨어져 사용하지 않는다.) 비반복 읽기(nonrepeatable read)가 발생하는데, 커밋 여부와 무관하게 시점에 따라 일시적으로 읽기 결과가 일관되지 않는 문제이다. Read Uncommited - 죄다 읽는 수준. 더티 읽기도 발생 refs Isolation (database systems) - Wikipedia Lock으로 이해하는 Transaction의 Isolation Level 데이터 중심 애플리케이션 설계 links Transaction 직렬성 Phantom Reads ","link":"https://chankoo.github.io/posts/isolation-levels/","section":"posts","tags":["mysql","동시성"],"title":"Isolation Levels"},{"body":"UNIX 용 WSGI 서버이다.\n파이썬 어플리케이션을 서빙하는 worker 를 fork하는데, worker 타입은 다음과 같다.\nsync 병렬로 동작하는 N개 프로세스를 fork한다. I/O로 인한 블로킹이 적을 경우 적합 gthread N개 스레드를 fork한다. 멀티스레딩을 지원하는 앱일 경우 적합 gevent gevent로 구현한 N개 웹서버를 실행한다. I/O 바운드인 보통의 서비스에 적합 refs Gunicorn vs Python GIL. What is the Python GIL, how it works… | by Luis Sena | Medium links WSGI 7가지 동시성 모델 gevent ","link":"https://chankoo.github.io/posts/gunicorn/","section":"posts","tags":["python","동시성"],"title":"gunicorn"},{"body":"기아 상태 여러 스레드나 프로세스가 자원을 점유하는 상황에서, 특정 스레드나 프로세스가 자원을 할당 받지 못하여 진행할 수 없는 상태\nrefs links ","link":"https://chankoo.github.io/posts/starvation/","section":"posts","tags":["동시성"],"title":"Starvation"},{"body":"교착 상태 한정된 자원을 공유하는 작업들이 서로의 종료를 기다리며 끝없이 대치하는 상태\n데드락의 필요 조건. 아래 4가지를 모두 만족시켜야 데드락이 발생한다.\n상호 배제(Mutual Exclusion) 점유 대기 비선점 순환 대기 refs links ","link":"https://chankoo.github.io/posts/deadlock/","section":"posts","tags":[],"title":"DeadLock"},{"body":"경쟁 상태 여러 스레드나 프로세스가 한 자원에 동시에 접근하고 조작하여 예상치 못한 결과(non deterministic)을 도출할 수 있는 상태. 즉, 스레드가 자원에 접근하는 타이밍에 결과가 영향 받는 상태를 의미한다\nThread 1 Thread 2 Integer value 0 read value ← 0 read value ← 0 increase value 0 increase value 0 write back → 1 write back → 1 refs Race condition - Wikipedia links ","link":"https://chankoo.github.io/posts/race-condition/","section":"posts","tags":["동시성"],"title":"Race Condition"},{"body":"","link":"https://chankoo.github.io/tags/c/","section":"tags","tags":null,"title":"C"},{"body":"content Portable Operation System Interface X UNIX OS 들이 공통적으로 제공해야할 API 규격이다. OS 간 이식성 높은 유닉스 응용프로그램을 만들기 위한 목적이다.\nC 언어 인터페이스인 시스템콜과 프로세스 환경, 파일 시스템, 압축 포맷 등 다양한 규격을 정의한다.\nrefs POSIX - 위키백과, 우리 모두의 백과사전 links ","link":"https://chankoo.github.io/posts/posix/","section":"posts","tags":["UNIX","C"],"title":"POSIX"},{"body":"Pthreads. UNIX 기반 운영체제에서 멀티 스레딩을 위해 제공하는 api(Windows 도 제공해준다). C 에서 사용\nrefs links POSIX ","link":"https://chankoo.github.io/posts/posix-threads/","section":"posts","tags":["UNIX","C"],"title":"POSIX threads"},{"body":"일반적으로, 여러 스레드가 실행해도 정상적으로 동작(매번 같은 결과를 리턴)하는 코드(변수, 함수 등)를 스레드 안전 하다고 말한다.\n동시성을 다룰 땐 \u0026lsquo;스레드 안전\u0026rsquo; 해야하는데, 이를 구현하는 모델로 잠금장치, 함수형 프로그래밍, 클로저 등을 쓸 수 있겠다.\nrefs 7가지 동시성 모델 links 동시성 ","link":"https://chankoo.github.io/posts/thread-safe/","section":"posts","tags":["동시성","함수형프로그래밍"],"title":"Thread Safe"},{"body":"refs links 7가지 동시성 모델 - 스레드와 잠금장치.pdf ","link":"https://chankoo.github.io/posts/7%EA%B0%80%EC%A7%80-%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%AA%A8%EB%8D%B8/","section":"posts","tags":["책","동시성"],"title":"7가지 동시성 모델"},{"body":"여러 일을 한꺼번에 실행하는 것. Parallelism. CPU의 영역에서 명세하자면, 여러 CPU가 스레드 하나씩을 동시에 실행하는 것이다.\n여러가지 일을 동시에 다루는 요구사항(동시성)을 해결하는 방법이기에 해법의 속성을 내포한다. 실제로 순차적 프로그래밍의 한계를 넘어서는 기술이다.\nrefs 7가지 동시성 모델 links 동시성 ","link":"https://chankoo.github.io/posts/%EB%B3%91%EB%A0%AC%EC%84%B1/","section":"posts","tags":["CPU","동시성"],"title":"병렬성"},{"body":"아마존에서 미팅을 위해 작성하는 문서. 서술 형식으로 6 페이지를 작성하며 미팅은 문서 내용을 이해하는 것에 중점을 둔다.\n서술형 문서를 사용하는 이유는 (슬라이드 형태 문서보다) 서술형의 이야기가 1) 이해하기 쉽고 2) 설득력 있으며 3) 기억에 오래 남기 때문이다.\n문서의 내용은\n배경 문제 질문; The context or question 답을 내기 위한 접근(누가, 어떤 방법으로, 결론); Approaches to answer the question- by whom, by which method, and their conclusions. 기존의 접근과 어떻게 다른지; How is your attempt at answering the question different or the same form previous approaches 왜 고객과 회사를 위해서 이 답이 필요한지. 이 결론이 고객의 혁신을 가져오는지; Now what? - that is, what’s in it for the customer, the company, and how does the answer to the question enable innovation on behalf of the customer ?“ refs The Anatomy of an Amazon 6-pager. A deep dive into writing detailed… | by Jesse Freeman | The Writing Cooperative links ","link":"https://chankoo.github.io/posts/6-pager/","section":"posts","tags":null,"title":"6-pager"},{"body":"Dependency Inversion Principle(의존성 역전 원칙) 더 구체적인(하위 계층) 모듈에 의존하는 일반적(절차적)인 의존성의 흐름을 역전 시켜 더 추상적인(상위 계층) 모듈에 의존하도록해야한다.\nex) 클라이언트 클래스에서 추상 팩토리와 연관 맺고, 런타임에 구체 팩토리를 의존성 주입하는 추상 팩토리 패턴. 클라이언트 클래스가 하위 계층에 의존하지 않고 상위 계층에 의존하는 것임\nrefs 클린 아키텍처 links SOLID ","link":"https://chankoo.github.io/posts/dip/","section":"posts","tags":["SOLID"],"title":"DIP"},{"body":"Dependency Injection(의존성 주입) 클라이언트에서 사용할 의존성을 외부에서 넣어주는 일\nrefs links ","link":"https://chankoo.github.io/posts/di/","section":"posts","tags":["디자인패턴"],"title":"DI"},{"body":"Inversion Of Control(제어 역전) 클라이언트(프로그래머)가 직접 사용할 의존성을 제어하는 상황(일반적, 절차적) -\u0026gt; 누군가(프레임워크)가 의존성을 정해주는(DI, DIP 등으로) 상황(역전)\nrefs 학습 페이지 [Study]IoC, DI, DIP 개념 잡기 - 기록은 기억을 지배한다 links DI DIP ","link":"https://chankoo.github.io/posts/ioc/","section":"posts","tags":["디자인패턴","spring"],"title":"IOC"},{"body":"","link":"https://chankoo.github.io/tags/spring/","section":"tags","tags":null,"title":"spring"},{"body":"함수형 컴포넌트에서 이펙트를 정의하는 훅. 렌더링 후 리액트가 내부의 함수를 실행한다. 리액트는 각 렌더링 마다 deps 배열을 비교하여 이펙트 내 함수 실행 여부를 따진다.\nrefs links 함수형 컴포넌트 ","link":"https://chankoo.github.io/posts/useeffect/","section":"posts","tags":["react"],"title":"UseEffect"},{"body":"react의 함수형 컴포넌트는 당연하게도 함수형 프로그래밍의 패러다임을 따른다. 컴포넌트 내 state는 불변하며, setState는 새 state로 컴포넌트 함수를 다시 호출한다. 그때마다 다시 렌더링되는 것이고 각 렌더링은 고유의 함수(핸들러, 이펙트)를 가진다.\nrefs useEffect 완벽 가이드 — Overreacted links ","link":"https://chankoo.github.io/posts/%ED%95%A8%EC%88%98%ED%98%95-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/","section":"posts","tags":["react","함수형프로그래밍"],"title":"함수형 컴포넌트"},{"body":"광고 매체를 통해 유입된 어플리케이션 유저의 데이터를 다시 광고 매체로 돌려주는 일. 보통 어플리케이션 제공자 입장에서 postback 기능이 있는 솔루션(MMP, Mobile Measurement Partner)이 필요한데, 1) 유저 데이터를 가지고 이용중인 광고를 최적화 하려는 목적과 2) 광고 매체 마다 API 스펙이 제각각이어서 대응이 어려운 문제 때문이다.\nrefs links webhook ","link":"https://chankoo.github.io/posts/postback/","section":"posts","tags":["광고"],"title":"postback"},{"body":"여러 일을 한꺼번에 다루는 것. Concurrency. CPU의 영역에서 명세하자면, CPU는 하나인데 여러 스레드에서 각각의 제어흐름을 다루고 있는 상황이다.\n순차적 프로그래밍의 한계를 넘어서려는 시도이나, 여러가지 일을 동시에 다루는 척(병렬 착각, 병행성)하는 것이기에 그자체로 문제의 속성을 내포한다.\nrefs 7가지 동시성 모델 links 병렬성 ","link":"https://chankoo.github.io/posts/%EB%8F%99%EC%8B%9C%EC%84%B1/","section":"posts","tags":["CPU","동시성"],"title":"동시성"},{"body":"refs links ","link":"https://chankoo.github.io/posts/%ED%81%B4%EB%A6%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/","section":"posts","tags":["책","컴포넌트"],"title":"클린 아키텍처"},{"body":"content 클린 아키텍처 에 따르면, 프로그래밍 패러다임은 아래 세가지 뿐이다.\n패러다임은 패러다임에 맞게 구현된 도구를 사용하거나, 그렇지 않은 도구를 사용하지 않음으로써, 프로그래머의 권한을 제한한다.\n구조적 프로그래밍(structured programming) 프로그래머가 직접적으로 흐름을 통제하는 일을 제한한다. goto 문을 없애는 것 객체 지향 프로그래밍(OOP, object oriented programming) 프로그래머가 간접적으로 흐름을 통제하는 일을 제한한다. 함수 포인터를 사용해 런타임에 실행 함수를 결정하는 일 -\u0026gt; 다형성 문법을 따르게 함 함수형 프로그래밍(functional programming) 변수 할당을 제한한다. 가변 변수를 없애고 CR만 이용한다. refs 클린 아키텍처 links ","link":"https://chankoo.github.io/posts/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84/","section":"posts","tags":["OOP","함수형프로그래밍"],"title":"프로그래밍 패러다임"},{"body":"파이썬의 list 보다 np array가\n더 빠르다 element로 PyObject 대신 value를 들고 있어 직접 접근할 수 있다. 메모리 효율이 좋다. element의 크기가 작다 PyObject - 4 for type pointer, 4 for reference count, 4 for value \u0026ndash; and the memory allocators rounds up to 16 value - single-precision numbers takes 4 bytes each, double-precision ones, 8 bytes 동적배열 아니어서 크기가 고정이며 정적할당하여 element 타입이 고정이다 refs links PyObject Dynamic Array ","link":"https://chankoo.github.io/posts/numpy-array/","section":"posts","tags":["python"],"title":"numpy array"},{"body":"파이썬(CPython)에서는 아래 두가지 객체에 대해 가비지 컬렉션을 실행한다.\nPyObject의 ref count가 0\n순환 참조가 발생했고 그 외의 참조는 없음\n예제 l = [] l.append(l) del l refs Python GC가 작동하는 원리 links 가비지 컬렉션 PyObject ","link":"https://chankoo.github.io/posts/python-gc/","section":"posts","tags":["python"],"title":"Python-GC"},{"body":"파이썬 객체의 레퍼런스 카운팅이 정상적으로 동작하도록, 인터프리터의 동작을 전역적으로 통제하는 락. 여러 스레드가 한 객체의 레퍼런스 카운트를 조작하는 동시성 을 제어하기위해, GIL 을 가진 스레드만 자원을 통제할 수 있다.\n더 구체적으로 말하면, 멀티 스레딩 환경에서 각 스레드는 레퍼런스 카운팅을 위해 PyObject 의 ob_refcnt를 조작하는데, 이는 race condition이다. race condition 해결을 위해 일반적인 mutex 를 사용하자니 각 객체 마다 락이 필요하고, deadlock 의 리스크도 존재한다. 그래서 파이썬(CPython)은 GIL을 통해 인터프리터 자체를 잠가버렸다.\nGIL로 레퍼런스 카운팅 문제를 해결했지만, 이것이 파이썬에서 race condition 이 발생하지 않는다는 얘기는 아니다. GIL은 레퍼런스 카운팅의 atomic한 실행을 보장하는 것 뿐이다. 스레드 레벨에서의 동작은 다른 얘기고 아래처럼 스레드 안전하지 않은 수행이 이루어질 수 있다.\nex) GIL 을 획득하려 대기하는 스레드(B)는 timeout을 걸고 -\u0026gt; timeout 내 작업을 완료 못한 스레드(A)는 작업을 중단한다. 스레드 A의 작업은 thread-safe 하지 못하다.\n[GIL 의 timeout] import sys sys.getswitchinterval() # default 5ms refs 왜 Python에는 GIL이 있는가 Gunicorn vs Python GIL. What is the Python GIL, how it works… | by Luis Sena | Medium 7가지 동시성 모델 links 동시성 PyObject Race Condition CPython Bytecode Thread Safe ","link":"https://chankoo.github.io/posts/gil/","section":"posts","tags":["python","동시성"],"title":"GIL"},{"body":"일반적인 CPython 구현체를 가정했을때, 파이썬의 메모리 관리 알고리즘은 C로 쓰여졌고, 이해를 위해서는 CPython 의 내부 구현을 알아야한다.\n모든 파이썬 객체는 PyObject라는 c struct 를 확장하여 가지고 있다.\nob_type 은 해당 객체의 타입 오브젝트(PyTypeObject)를 가리키는 포인터이다. PyTypeObject 역시 c struct 이며 특정 타입(int, dict 등)에 대한 메타 데이터를 가진다. ob_refcnt 는 객체를 참조하는 레퍼런스의 수를 저장한다. refs Memory Management in Python – Real Python links CPython ","link":"https://chankoo.github.io/posts/pyobject/","section":"posts","tags":["python"],"title":"PyObject"},{"body":"런타임에 원시코드를 읽어가며 기계어로 실시간 컴파일하는 기술. 그 결과 JIT 컴파일을 활용하면 정적 컴파일만큼 빠른 속도로 돌면서도, 인터프리터 언어만큼 잦은 인터랙션을 제공할 수 있다.\nrefs -JIT 컴파일 - 위키백과, 우리 모두의 백과사전\nlinks 인터프리터 ","link":"https://chankoo.github.io/posts/jit-%EC%BB%B4%ED%8C%8C%EC%9D%BC/","section":"posts","tags":[],"title":"JIT 컴파일"},{"body":"프로그래밍 언어(일반적으로 고급 언어)를 읽고 바로 실행하는 프로그램 또는 환경.\n인터프리터는 아래 세가지 중 적어도 하나의 일을 한다.\n소스코드를 직접 실행한다. 소스코드를 더 효율적인 중간 코드(바이트코드)로 변환하고 이를 실행한다. (인터프리터 시스템의 일부인) 컴파일러가 사전에 컴파일한 파일의 실행을 호출한다. 현대의 많은 인터프리터가 JIT 컴파일 과 같은 기술을 지원하여서 컴파일러와의 엄격한 구분은 의미를 잃었다.\nrefs 인터프리터 - 위키백과, 우리 모두의 백과사전 links 컴파일러 JIT 컴파일 Bytecode ","link":"https://chankoo.github.io/posts/%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0/","section":"posts","tags":[],"title":"인터프리터"},{"body":"고급 프로그래밍 언어를 저급 프로그래밍 언어(어셈블리 언어, 기계어 등)로 바꾸어 출력하는 번역 프로그램.\nrefs 컴파일러 - 위키백과, 우리 모두의 백과사전 links ","link":"https://chankoo.github.io/posts/%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC/","section":"posts","tags":[],"title":"컴파일러"},{"body":"Cython: C-Extension for Python C로 파이썬의 확장 모듈을 구현하기 위해 설계한 컴파일 언어. C와 파이썬의 superset이며 표준 C/C++ 컴파일러를 이용한다. 이러한 특성은 파이썬 언어의 높은 생산성을 활용하면서 실행 속도의 향상을 가져온다.\nrefs 사이썬 - 위키백과, 우리 모두의 백과사전 links CPython 컴파일러 ","link":"https://chankoo.github.io/posts/cython/","section":"posts","tags":["python","C"],"title":"Cython"},{"body":"C로 구현한 파이썬 인터프리터 시스템. 파이썬 언어로 쓰인 스크립트를 바이트코드(.pyc, pycache)로 컴파일한 후, 인터프리터로 실행한다.\nrefs CPython 파헤치기: 따라 하면서 이해하는 파이썬 내부의 동작 원리 – 도서출판 인사이트 links 인터프리터 Bytecode ","link":"https://chankoo.github.io/posts/cpython/","section":"posts","tags":["python"],"title":"CPython"},{"body":"","link":"https://chankoo.github.io/tags/ios/","section":"tags","tags":null,"title":"iOS"},{"body":"content View -\u0026gt; ViewModel -\u0026gt; Model 의 구조. View 를 그리기 위한 데이터와 비즈니스 로직을 ViewModel에 모두 담아 View와 Model 결합을 끊는다. MVC(UIKit) 를 이용하던 iOS 개발의 대세 흐름이 MVVM(SwiftUI)을 이용하는 것으로 변했는데, MVC에 비해 각 계층이 더 잘 분리되어 유지보수와 테스트가 더 용이하다. MVVM은 View가 ViewModel을, ViewModel이 Model을 소유하는 방식인데, MVC의 ViewController가 Model과 View를 모두 떠맡아 비대해지는 이슈를 해결하는 구조이다. 화면을 VC 단위로 구성하는 것이 아니라, View가 필요한 비즈니스 로직(ViewModel)을 가져와 사용하는 것이다.\n계층을 분리하는 구조를 더 자세히 이해하려면 Reactive Programming(Data Binding)과 커맨드 패턴에 대한 이해가 필요하다.\nrefs iOS 개발 — MVVM 패턴이란? UIKit의 MVC와의 비교 | by Heechan | HcleeDev | Medium links ","link":"https://chankoo.github.io/posts/mvvm/","section":"posts","tags":["디자인패턴","frontend","iOS"],"title":"MVVM"},{"body":"content 리액트에서 로직과 뷰 컴포넌트를 분리하는 패턴. 데이터를 가져오고 가공하는 컨테이너 컴포넌트와, 데이터를 렌더링하는 프레젠터 컴포넌트로 나눈다.\naka Smart \u0026amp; Dumb conponents 대개 컨테이너는 렌더링하는 컴포넌트 외에 다른 ui는 렌더링하지 않으며, 프레젠터는 컨테이너로 부터 데이터를 받아 단순히 렌더링 한다.\n관심사 분리를 통해 재사용성 높은 순수한 프레젠터 컴포넌트를 만드는 이점이 있으며, 테스트가 쉬워서 험블 객체 패턴을 따랐다고도 볼 수 있겠다.\n반면 데이터 가져오는 역할을 hook이 점차 대체하며, 굳이 컨테이너 컴포넌트를 두는게 불필요하다는 의견도 늘고있다.\nrefs Container/Presentational Pattern links 험블 객체 패턴 ","link":"https://chankoo.github.io/posts/container-presenter-%ED%8C%A8%ED%84%B4/","section":"posts","tags":["디자인패턴","react"],"title":"Container-Presenter 패턴"},{"body":"프로그램이 동적으로 할당했던 메모리 영역 중 필요 없는 영역을 해제하는 메모리 관리 기법.\n가비지 컬렉션이 동작하는 기준은 언어와 구현마다 다른데, 아래와 같은 케이스가 있다.\n레퍼런스 카운트가 0인 객체(CPython) 순환 참조 발생(CPython) 프로그램 코드에서 더이상 접근할 수 없는 객체(Java) 힙 메모리 부족 주기적 실행 개발자의 명시적 요청 refs 쓰레기 수집 (컴퓨터 과학) - 위키백과, 우리 모두의 백과사전 links CPython ","link":"https://chankoo.github.io/posts/%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%EC%85%98/","section":"posts","tags":null,"title":"가비지 컬렉션"},{"body":"python 의 list 는 dynamic array이다. 런타임에 element를 추가할때, 리스트에 할당된 메모리 공간이 모자라면 리스트 크기를 늘린다. 그런데 dynamic array도 엄연한 array 이기에 \u0026rsquo;element 가 연속된 메모리 공간을 점유한다\u0026rsquo;는 제약을 따라야한다. 그래서 python(cpython)은 요소가 추가되어 리스트 크기가 변해야할 때, 전체 list를 복사하여 더 큰(2의 거듭제곱) 공간에 통째로 재할당 한다.\n이는 시간 복잡도 계산에 영향을 준다. list 에 요소를 더하는 append 나 insert 연산의 시간 복잡도를 계산할 때 메모리 재할당 시간까지 고려해야 한다는 의미다. 동적 배열에 요소를 추가할때 메모리 재할당이 필요하다면, O(N) 시간이 필요하다(분할 상환하여 계산한 일반적인 시간 복잡도는 O(1)). 또한 list.pop(k) 역시 k번째 요소를 가져온 뒤 메모리 재할당이 필요하므로 O(N)이다.\nrefs Python Bulit-in Time Complexity: List · Enfow\u0026rsquo;s Blog links 분할 상환 분석 ","link":"https://chankoo.github.io/posts/dynamic-array/","section":"posts","tags":["python"],"title":"Dynamic Array"},{"body":"기억과 생각을 탐색하는 자료구조\n노트 작성 원칙\natomic한 아이디어를 노트로 작성한다. 임시 노트를 작성하고 영구 노트로 옮긴다. 노트 간 연결은 많을수록 좋다. 영구 노트 작성 원칙\n내 글로 다시 쓴다. 출판을 전제로 쓴다. 분량을 제한한다. 페이지 작성법\n영구 노트의 글감을 정리하여 한 편의 글을 쓴다. refs 4. 옵시디안은 제텔카스텐을 위해 태어났다. 제텔카스텐 개념과 기본 세팅[한글 자막] - YouTube links ","link":"https://chankoo.github.io/posts/%EC%A0%9C%ED%85%94%EC%B9%B4%EC%8A%A4%ED%85%90/","section":"posts","tags":[],"title":"제텔카스텐"},{"body":"","link":"https://chankoo.github.io/posts/amortized-analysis/","section":"posts","tags":null,"title":""}]