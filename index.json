[{"body":"","link":"https://chankoo.github.io/","section":"","tags":null,"title":""},{"body":"","link":"https://chankoo.github.io/categories/","section":"categories","tags":null,"title":"Categories"},{"body":"","link":"https://chankoo.github.io/posts/","section":"posts","tags":null,"title":"Posts"},{"body":"","link":"https://chankoo.github.io/tags/react/","section":"tags","tags":null,"title":"react"},{"body":"","link":"https://chankoo.github.io/tags/","section":"tags","tags":null,"title":"Tags"},{"body":"content 함수형 컴포넌트에서 이펙트를 정의하는 훅. 렌더링 후 리액트가 내부의 함수를 실행한다. 리액트는 각 렌더링 마다 deps 배열을 비교하여 이펙트 내 함수 실행 여부를 따진다.\nrefs links [[함수형 컴포넌트]] 함수형 컴포넌트 ","link":"https://chankoo.github.io/posts/useeffect/","section":"posts","tags":["react"],"title":"UseEffect"},{"body":"","link":"https://chankoo.github.io/categories/%EC%96%B8%EC%96%B4/","section":"categories","tags":null,"title":"언어"},{"body":"content react의 함수형 컴포넌트는 당연하게도 함수형 프로그래밍의 패러다임을 따른다. 컴포넌트 내 state는 불변하며, setState는 새 state로 컴포넌트 함수를 다시 호출한다. 그때마다 다시 렌더링되는 것이고 각 렌더링은 고유의 함수(핸들러, 이펙트)를 가진다.\nrefs useEffect 완벽 가이드 — Overreacted links ","link":"https://chankoo.github.io/posts/%ED%95%A8%EC%88%98%ED%98%95-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/","section":"posts","tags":["react","함수형프로그래밍"],"title":"함수형 컴포넌트"},{"body":"","link":"https://chankoo.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/","section":"tags","tags":null,"title":"함수형프로그래밍"},{"body":"","link":"https://chankoo.github.io/series/","section":"series","tags":null,"title":"Series"}]