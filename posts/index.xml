<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on </title>
    <link>https://chankoo.github.io/posts/</link>
    <description>Recent content in Posts on </description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright>
    <lastBuildDate>Tue, 05 Dec 2023 20:08:04 +0900</lastBuildDate><atom:link href="https://chankoo.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>TCP</title>
      <link>https://chankoo.github.io/posts/tcp/</link>
      <pubDate>Tue, 05 Dec 2023 20:08:04 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/tcp/</guid>
      <description>
        
          
            content Transmission Control Protocol. TCP/IP 스택 전송 계층 프로토콜로 소켓 간 신뢰할 수 있는 통신을 보장한다.
프로세스와 프로세스(엄밀히는 소켓과 소켓)를 잇는 논리적인 개념의 point-to-point 통신 reliable: 응용계층에서 받은 데이터의 error와 loss가 없음을 보장 in-order byte stream: 데이터의 순서를 유지 Pipelined : window size 단위로 패킷을 묶어 통신 send &amp;amp; receive buffers: 송신 측과 수신 측 모두 send, receive buffer를 각각 가짐 Full duplex: 통신하는 host 양쪽 모두가 데이터 전송 가능 Connection oriented: handshake를 먼저 수행한 후 통신.
          
          
        
      </description>
    </item>
    
    <item>
      <title>로드 팩터</title>
      <link>https://chankoo.github.io/posts/%EB%A1%9C%EB%93%9C-%ED%8C%A9%ED%84%B0/</link>
      <pubDate>Fri, 01 Dec 2023 17:55:35 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%EB%A1%9C%EB%93%9C-%ED%8C%A9%ED%84%B0/</guid>
      <description>
        
          
            content 해시 테이블에 저장한 데이터 개수 n을 버킷의 개수 k로 나눈 것(n/k)
로드 팩터가 높을수록 해시 테이블의 성능이 감소한다. 같은 버킷을 쓰는 데이터가 많아져 해시 테이블에서 탐색하는 시간이 늘어나기 때문이다.
따라서 언어별로 해시 테이블을 구현할때 로드 팩터의 임계치를 두고있으며, 임계치를 넘어설때 버킷의 수를 늘려 리해싱한다. (동적 배열의 메모리 재할당과 유사)
refs links 해시 테이블 해시 충돌 Dynamic Array 
          
          
        
      </description>
    </item>
    
    <item>
      <title>콜백 함수</title>
      <link>https://chankoo.github.io/posts/%EC%BD%9C%EB%B0%B1-%ED%95%A8%EC%88%98/</link>
      <pubDate>Thu, 30 Nov 2023 16:18:53 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%EC%BD%9C%EB%B0%B1-%ED%95%A8%EC%88%98/</guid>
      <description>
        
          
            content 인자로 다른 함수에게 전달되는 함수.
refs links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>스케줄링</title>
      <link>https://chankoo.github.io/posts/%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81/</link>
      <pubDate>Thu, 30 Nov 2023 15:46:27 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81/</guid>
      <description>
        
          
            content OS가 CPU를 프로세스에게 할당하는 정책이다.
선점형 vs 비선점형(협력적) 자원을 점유하는 프로세스를 중지하고 강제로 자원을 가져가는 선점형 자원을 점유하는 프로세스가 종료되거나, I/O 발생하여 대기 할때까지 기다리는 비선점형 정적 vs 동적 프로세스에 부여된 우선순위가 고정 vs 유동 refs 스케줄링 (컴퓨팅) - 위키백과, 우리 모두의 백과사전 백엔드 개발자들이 알아야할 동시성 4 — 스케줄링. 지난 포스팅에선 많은 쓰레드와 잦은 컨텍스트 스위칭이 어떻게 웹서버의… | by Choi Geonu | Medium links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>CPS</title>
      <link>https://chankoo.github.io/posts/cps/</link>
      <pubDate>Thu, 30 Nov 2023 15:43:19 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/cps/</guid>
      <description>
        
          
            content Continuation Passing Style. 말그대로 Continuation을 전달하는 방식으로 프로그래밍하는 것을 말한다.
이는 CPS 함수를 정의할 때 특정한 작업(ex. 콜백 함수) 을 명시적 인자로 받게되는데, CPS 함수는 해당 함수의 작업이 끝난 후 인자로 받은 작업을 수행하게 된다. Continuation이 CPS 함수에 있다가 인자로 받은 작업으로 넘어가는 것이다.
CPS가 아니라면 함수가 그냥(암묵적으로) 작업을 수행하며, Continuation은 해당 함수에 머무른다.
refs Continuation-passing style - Wikipedia 백엔드 개발자들이 알아야할 동시성 5 — Continuation Passing Style | by Choi Geonu | Medium Continuation-Passing Style.
          
          
        
      </description>
    </item>
    
    <item>
      <title>Cache-Control</title>
      <link>https://chankoo.github.io/posts/cache-control/</link>
      <pubDate>Thu, 30 Nov 2023 14:18:34 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/cache-control/</guid>
      <description>
        
          
            content 리소스의 캐시 여부를 지정하는 http 응답/요청 헤더. Cache-Control에 부여한 directive에 따라 캐시 사용 전략이 결정된다. Etag나 bfcache 등이 모두 영향받는다.
refs Cache-Control - HTTP | MDN 프론트엔드 개발자가 알아야 할 ‘캐싱’ 개념 정리 | 요즘IT links Etag bfcache 
          
          
        
      </description>
    </item>
    
    <item>
      <title>CORS</title>
      <link>https://chankoo.github.io/posts/cors/</link>
      <pubDate>Wed, 29 Nov 2023 21:32:15 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/cors/</guid>
      <description>
        
          
            content Cross-Origin Resource Sharing. 출처가 다른(Cross-Origin) 요청에 대해 리소스를 내려 줄 것인지 판단하는 정책이다.
요청 헤더 Origin에 출처가 담긴다. 스킴, 도메인, 포트 중 하나라도 다르면 Cross-Origin으로 본다. 응답 헤더 Access-Control-Allow-Origin에 허용된 출처가 담긴다. 브라우저가 Origin, Access-Control-Allow-Origin 그리고 요청 시나리오를 고려하여 CORS 위반 여부를 판단한다. refs CORS는 왜 이렇게 우리를 힘들게 하는걸까? | Evans Library links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>DHCP</title>
      <link>https://chankoo.github.io/posts/dhcp/</link>
      <pubDate>Mon, 27 Nov 2023 17:31:27 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/dhcp/</guid>
      <description>
        
          
            content Dynamic Host Configuration Protocol. 네트워크에 연결된 장치들에게 IP 주소와 기타 매개변수(네임서버 주소, 게이트웨이 주소 등)를 자동으로 할당하는 IP 네트워크 레벨의 프로토콜.
서버(보통은 공유기)와 클라이언트로 나뉘는데, DHCP 서버는 서브넷에서 사용가능한 네트워크 자원을 일정 기간 클라이언트에 임대하는 역할을 수행한다. 서버가 중앙 집중식으로 관리하기에 클라이언트 간 충돌 없이 네트워크 자원을 분배할 수 있다.
refs 🌐 DHCP 이란 무엇인가? (그림으로 쉽게 정리) links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>전문 검색 인덱스</title>
      <link>https://chankoo.github.io/posts/%EC%A0%84%EB%AC%B8-%EA%B2%80%EC%83%89-%EC%9D%B8%EB%8D%B1%EC%8A%A4/</link>
      <pubDate>Mon, 27 Nov 2023 15:57:04 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%EC%A0%84%EB%AC%B8-%EA%B2%80%EC%83%89-%EC%9D%B8%EB%8D%B1%EC%8A%A4/</guid>
      <description>
        
          
            content 컬럼 텍스트의 전체 값을 인덱싱해서 키워드 검색(full text search)을 용이하게 하는 방법으로 stopword, n-gram 등의 전문 검색 알고리즘을 사용한다.
refs Real MySQL links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>Hash 인덱스</title>
      <link>https://chankoo.github.io/posts/hash-%EC%9D%B8%EB%8D%B1%EC%8A%A4/</link>
      <pubDate>Mon, 27 Nov 2023 15:46:10 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/hash-%EC%9D%B8%EB%8D%B1%EC%8A%A4/</guid>
      <description>
        
          
            content 인덱싱할 컬럼 값의 해시를 키로 이용하는 인덱스. 동등 비교에 최적화(O(N)) 되었지만 범위 검색이나 정렬에는 전혀 사용할 수 없다.
refs Real MySQL links 해시 
          
          
        
      </description>
    </item>
    
    <item>
      <title>Active Record</title>
      <link>https://chankoo.github.io/posts/active-record/</link>
      <pubDate>Wed, 22 Nov 2023 23:08:32 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/active-record/</guid>
      <description>
        
          
            content DB row의 wrapper 객체로 데이터에 대한 접근과 도메인 로직을 함께 구현해놓는 방식이다.
refs P of EAA: Active Record Fetching Title#kql4 links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>비동기</title>
      <link>https://chankoo.github.io/posts/%EB%B9%84%EB%8F%99%EA%B8%B0/</link>
      <pubDate>Wed, 22 Nov 2023 17:46:10 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%EB%B9%84%EB%8F%99%EA%B8%B0/</guid>
      <description>
        
          
            content 동기적이지 않은 것(asynchronous)을 의미한다.
동기적이라는 건 작업들을 순차적으로 진행함을 의미하는데, 한 작업이 끝나기를 기다려야하는 속성이 있다. 반면에 비동기는 한 작업이 끝나기를 기다리지 않고 다른 작업을 진행하는 것을 말하며, 동기적이지 않은 모든 방식을 의미한다.
비동기의 예시 non-block I/O - 요청을 block하는 작업이 아니기에 I/O를 기다리는 동안 다른 작업을 처리할 수 있다. 멀티 스레딩 - 여러 작업을 각 스레드가 나누어 진행하기에 동기적이지 않다. block I/O 작업이라도 비동기로 진행할 수 있다 refs 비동기 프로그래밍, 비동기 I/O, 비동기 커뮤니케이션.
          
          
        
      </description>
    </item>
    
    <item>
      <title>스레드</title>
      <link>https://chankoo.github.io/posts/%EC%8A%A4%EB%A0%88%EB%93%9C/</link>
      <pubDate>Wed, 22 Nov 2023 16:24:20 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%EC%8A%A4%EB%A0%88%EB%93%9C/</guid>
      <description>
        
          
            content 컴퓨터 과학에서 어떠한 작업을 처리하는 흐름의 단위를 말한다.
종류 하드웨어 스레드 - 하드웨어 레벨에서 CPU 코어의 작업을 나눠 놓은 단위이다. 코어의 한 하드웨어 스레드가 메모리에 접근하는 시간에 다른 스레드가 CPU 연산을 이용하는 병행처리를 가능케 한다. OS 스레드 - 일반적인 의미의 스레드로, CPU에서 실제로 실행(CPU 스케줄링)되는 단위이다. OS 커널이 시스템콜을 통해 스레드를 생성하고, 컨텍스트 스위칭을 한다. 네이티브 스레드, 커널 스레드라 불리기도 한다. 유저 스레드 - 유저가 관리하는 단위의 스레드로 프로그래밍 레벨에서 추상화한 OS 스레드를 의미한다.
          
          
        
      </description>
    </item>
    
    <item>
      <title>DBCP</title>
      <link>https://chankoo.github.io/posts/dbcp/</link>
      <pubDate>Wed, 22 Nov 2023 12:01:24 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/dbcp/</guid>
      <description>
        
          
            content DB Connection Pool. DB와의 커넥션 풀을 어플리케이션 단에 미리 만들어두는 것이다. DB와 커넥션을 맺고 끊기 위해 매번 TCP 통신하는 비용을 줄인다.
mysql 기준으로 성능에 중요한 설정 max_connections: 클라이언트와 맺을 수 있는 최대 커넥션 수 wait_timeout: inactive 커넥션을 얼마까지 기다린 뒤 close 할지 설정 django 기준으로 성능에 중요한 설정 django는 커넥션 풀을 지원하지 않고, 요청마다 커넥션을 맺고 끊는다. CONN_MAX_AGE: 하지만 CONN_MAX_AGE(default: 0)에 값을 주면, 커넥션을 지정한 시간 동안 종료하지 않아 커넥션 풀처럼 재사용이 가능하다.
          
          
        
      </description>
    </item>
    
    <item>
      <title>LSM Tree</title>
      <link>https://chankoo.github.io/posts/lsm-tree/</link>
      <pubDate>Tue, 21 Nov 2023 19:33:43 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/lsm-tree/</guid>
      <description>
        
          
            content Log Structured Merge Tree는 로그성 데이터 색인을 위해 고안된 자료구조로, 정렬된 키-값 데이터인 SS테이블(Sorted String Table) 형식으로 디스크에 데이터를 저장한다.
refs 데이터 중심 애플리케이션 설계 색인(index)의 두 가지 형태 : LSM 트리 &amp;amp; B 트리 | by allocProc | Medium links B-Tree Hash 인덱스 
          
          
        
      </description>
    </item>
    
    <item>
      <title>Mysql 인덱스</title>
      <link>https://chankoo.github.io/posts/mysql-%EC%9D%B8%EB%8D%B1%EC%8A%A4/</link>
      <pubDate>Tue, 21 Nov 2023 19:20:55 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/mysql-%EC%9D%B8%EB%8D%B1%EC%8A%A4/</guid>
      <description>
        
          
            content mysql의 InnoDB는 아래와 같은 구조로 인덱스를 생성한다. 해당 인덱스는 B-Tree 로 기본키를 저장하고, 기본키는 데이터에 접근한다. 이때 기본키와 데이터는 같은 공간에 저장한다. 이를 클러스터드 인덱스(테이블이 곧 기본키 인덱스)라고 부른다.
refs [MySQL] B-Tree로 인덱스(Index)에 대해 쉽고 완벽하게 이해하기 - MangKyu&amp;rsquo;s Diary 데이터 중심 애플리케이션 설계 links B-Tree INNODB Hash 인덱스 전문 검색 인덱스 
          
          
        
      </description>
    </item>
    
    <item>
      <title>B-Tree</title>
      <link>https://chankoo.github.io/posts/b-tree/</link>
      <pubDate>Tue, 21 Nov 2023 18:54:17 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/b-tree/</guid>
      <description>
        
          
            content BST(Binary Search Tree)를 일반화한 자료구조로 2개 이상의 자식 노드를 갖는 Balanced Tree이다.
B Tree 류 자료구조는 DB 인덱스로 많이 쓰인다. (Balanced BST인)AVL Tree, RB Tree에 비해 자식 노드 개수가 많아 디스크 접근 수가 적음 블록 단위로 메모리에 적재하는 OS 특성도 효율적으로 활용 B Tree 인덱스의 성능은 키의 크기, 키의 카디널리티, 레코드 대비 인덱스 스캔의 범위 등 다양한 요소에 영향 받는다.
디스크 I/O로 데이터를 가져오는 단위인 블록의 크기는 고정(mysql은 16KB)인데, 키의 크기가 커지면 한블록에 저장하는 키의 개수가 적어진다.
          
          
        
      </description>
    </item>
    
    <item>
      <title>소켓</title>
      <link>https://chankoo.github.io/posts/%EC%86%8C%EC%BC%93/</link>
      <pubDate>Wed, 07 Jun 2023 19:38:33 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%EC%86%8C%EC%BC%93/</guid>
      <description>
        
          
            content 응용계층 간의 통신을 위해서 고안된 인터페이스로 어플리케이션에서 시스템(하위 계층)의 자원과 기능을 사용하도록 한다. 프로토콜이 TCP라면, 응용계층에서 TCP/IP로 내려가는 창구가 된다.
서버 소켓 - 구현상 같은 주소의 소켓이 여러개(하나의 리슨 소켓과 여러개의 통신 소켓)이다. 요청이 리슨 소켓으로 들어오면 accept하여 통신 소켓을 생성한다. 커넥션이 만들어진 후 클라이언트는 통신 소켓과 통신한다. 클라이언트 소켓 - 특정 포트를 선택하는 바인딩 과정 없이 자동으로 포트를 선택한다. 커널이 로컬 포트 중 적당한 포트를 골라 넘겨준다. 스펙상) 소켓은 internet address + port number로 표현하며 네트워크 전체에서 유니크하다.
          
          
        
      </description>
    </item>
    
    <item>
      <title>WebSocket</title>
      <link>https://chankoo.github.io/posts/websocket/</link>
      <pubDate>Thu, 30 Mar 2023 15:23:12 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/websocket/</guid>
      <description>
        
          
            content 서버-클라이언트 양방향 일대일 통신을 제공하는 프로토콜
http는 아니지만 http 업그레이드 헤더를 사용하도록 호환된다 통신 상대가 정해져있어 데이터를 절약한다. stateful 하기에 채널을 온메모리로 관리해야한다. refs ../1.permanents/리얼월드 HTTP|리얼월드 HTTP links 소켓 
          
          
        
      </description>
    </item>
    
    <item>
      <title>SSE</title>
      <link>https://chankoo.github.io/posts/sse/</link>
      <pubDate>Thu, 30 Mar 2023 15:17:58 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/sse/</guid>
      <description>
        
          
            content Server-Sent Events. HTML5 의 기능으로, 한번의 요청에 서버가 여러 이벤트(청크) 전송을 제공하는 프로토콜. http 위에서 동작하는 별도 텍스트 프로토콜이다(text/event-stream).
refs 리얼월드 HTTP Server-sent events - Web APIs | MDN links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>디렉토리</title>
      <link>https://chankoo.github.io/posts/%EB%94%94%EB%A0%89%ED%86%A0%EB%A6%AC/</link>
      <pubDate>Tue, 10 Jan 2023 20:43:09 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%EB%94%94%EB%A0%89%ED%86%A0%EB%A6%AC/</guid>
      <description>
        
          
            content 파일 시스템에서 파일 관리를 위해 파일의 위치, 크기, 소유자 등의 정보를 갖고있는 특수한 형태의 파일.
refs links 파일 시스템 
          
          
        
      </description>
    </item>
    
    <item>
      <title>CQRS</title>
      <link>https://chankoo.github.io/posts/cqrs/</link>
      <pubDate>Mon, 12 Dec 2022 23:09:46 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/cqrs/</guid>
      <description>
        
          
            content Command와 Query를 다른 것으로 보고 명시적으로 분리하는 패턴. OOP 관점에서 Command를 담당하는 객체와, Query를 담당하는 객체의 책임을 분리하는 것으로 이해하면된다.
MSA, DDD, 이벤트 소싱 등 다른 기술과 함께 활용되며 다양하게 구현한다.
특히 마이크로 서비스로 분리한 아키텍처에서는 Query가 어려운데, 여러 서비스에 흩어진 데이터를 조회하는 비용이 크기 때문이다. 그래서 Query 효율을 높이는 관점에서 CQRS를 많이 활용한다.
refs 마이크로서비스 패턴 links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>인증 방식 비교</title>
      <link>https://chankoo.github.io/posts/%EC%9D%B8%EC%A6%9D-%EB%B0%A9%EC%8B%9D-%EB%B9%84%EA%B5%90/</link>
      <pubDate>Sat, 19 Nov 2022 22:27:39 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%EC%9D%B8%EC%A6%9D-%EB%B0%A9%EC%8B%9D-%EB%B9%84%EA%B5%90/</guid>
      <description>
        
          
            content 쿠키와 세션 보다 토큰 기반 인증 방식(JWT)를 이용하면 장점이 많아 현대 웹, 앱은 대부분 JWT를 쓴다.
쿠키와 세션은 세션 아이디를 쿠키에 담고, 별도 세션을 저장하는 방식이다. 요청시 세션 아이디를 이용해 저장소의 세션을 확인하여 인증한다. 그렇기에 세션 저장소를 유지하는 비용이 발생하고, 요청이 stateful 한 상태가 되며, 매번 요청시 세션을 조회해야하는 단점이 있다.
반면에 JWT는 토큰 자체로 인증 여부를 판단하기에 별도 저장소가 필수적이지 않으며 매번 조회 요청을 보내지 않아도 된다. 또한 stateful 하지 않아 확장성이 좋다.
          
          
        
      </description>
    </item>
    
    <item>
      <title>JWT</title>
      <link>https://chankoo.github.io/posts/jwt/</link>
      <pubDate>Sat, 19 Nov 2022 21:38:05 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/jwt/</guid>
      <description>
        
          
            content JSON Web Token. 사용자의 정보를 Json에 담아 보내는 형식의 웹 토큰이다.
Header / Payload / Signature 로 나뉘며, base64 인코딩을 통해 url-safe한 xxx.yyy.zzz 형태로 표현한다. Header에는 Signature 에 서명한 알고리즘 정보를 담는다. Payload에는 실제 사용자 정보를 Json 형태로 담으며 추가에 열려있다. Signature는 비대칭키 방식을 사용하여 header와 payload가 변경 안되었음을 보증한다.
주로 인증을 위해 사용하는데, JWT의 유효성(위조 여부)만 확인하면 인증은 완료된다. 이미 JWT 발급 시점에 (id, pwd로) 사용자를 인증했고 그 결과로 JWT를 생성했기에, (Signature를 이용하여) JWT 가 위조되지 않았다는 것만 확인하면 JWT 발급 시점과 같은 사용자라는 것을 알게되는 원리이다.
          
          
        
      </description>
    </item>
    
    <item>
      <title>Python heapq</title>
      <link>https://chankoo.github.io/posts/python-heapq/</link>
      <pubDate>Fri, 18 Nov 2022 15:42:48 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/python-heapq/</guid>
      <description>
        
          
            content heap을 이용하는 q의 구현을 제공하는 모듈
heap = [] heapq.heappush(heap, item) heapq.heappop(heap) heappush 와 heappop 을 통해 힙 큐를 구현할 수 있다.
주의할 것은
heap 은 heap 자료구조가 아님. 선형 자료구조(ex. 리스트) 를 받아 힙의 구현을 도와주는 모듈임 최소 힙을 구현함 0을 제외한 인덱스로 읽지 말자 - heap[0] 을 제외한 값은 정렬된 형태가 아님 refs heapq — 힙 큐 알고리즘 — Python 3.12.0 문서 파이썬의 heapq 모듈로 힙 자료구조 사용하기 | Engineering Blog by Dale Seo links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>bfcache</title>
      <link>https://chankoo.github.io/posts/bfcache/</link>
      <pubDate>Wed, 09 Nov 2022 22:21:33 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/bfcache/</guid>
      <description>
        
          
            content Back/Forward Cache 는 브라우저가 제공하는 페이지 전체(js 포함) 스냅샷으로, 페이지 전환 이벤트(pageshow, pagehide)가 발생할때 캐시한다.
refs Back/forward cache | Articles | web.dev links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>Etag</title>
      <link>https://chankoo.github.io/posts/etag/</link>
      <pubDate>Fri, 04 Nov 2022 11:32:20 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/etag/</guid>
      <description>
        
          
            content 클라이언트의 http 요청의 갱신 여부를 파악하기 위해 설정하는 응답 헤더.
요청 -&amp;gt; 서버가 요청을 Etag 변환(해시 사용) -&amp;gt; 응답 헤더에 Etag 포함 -&amp;gt; 클라이언트가 사용(If-None-Match에 담아)해 요청 -&amp;gt; 동일한 Etag 라면 http 304 Not Modified 반환
refs Etag를 이용하여 더 나은 Restful API 만들기 | 요즘IT Conditional View Processing | Django documentation | Django ETag - HTTP | MDN links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>ISP</title>
      <link>https://chankoo.github.io/posts/isp/</link>
      <pubDate>Sun, 30 Oct 2022 19:08:11 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/isp/</guid>
      <description>
        
          
            content 인터페이스 분리 원칙; Interface Separation Principle 인터페이스를 분리하여, 요소가 사용하는 인터페이스에만 의존하도록 설계해야한다.
refs 클린 아키텍처 links SOLID 
          
          
        
      </description>
    </item>
    
    <item>
      <title>LSP</title>
      <link>https://chankoo.github.io/posts/lsp/</link>
      <pubDate>Sun, 30 Oct 2022 17:51:17 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/lsp/</guid>
      <description>
        
          
            content 리스코프 치환 원칙; Liskov Subsitution Principle 상위 타입 객체는 하위 타입 객체로 별도 조작 없이 치환 가능해야한다.
객체 지향 언어는 다형성을 제공하기에, LSP를 지킨 설계를 활용하기 유리하다. 사용할 하위 타입을 런타임에 선택하여 상위 타입을 대체하기 용이하다.
LSP를 위반하면 OCP를 위반하는 것이다. 하위 타입을 추가(확장)하여 상위 타입을 바로 대체할 수 없기 때문이다. LSP를 위반한다면 보통 해당 객체를 사용하는 클라이언트 코드를 수정해야한다. 그리고 이 수정은 끔찍한 형태로 의존을 낳는다. 흔히 드는 예시가 직사각형을 상속한 정사각형 인데, 정사각형은 반드시 너비와 높이가 일치해야하므로 직사각형 객체를 대체할 수 없다.
          
          
        
      </description>
    </item>
    
    <item>
      <title>OCP</title>
      <link>https://chankoo.github.io/posts/ocp/</link>
      <pubDate>Fri, 28 Oct 2022 00:36:16 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/ocp/</guid>
      <description>
        
          
            content 개방-폐쇄 원칙; Open Close Principle 소프트웨어 요소는 확장에는 open, 수정에는 close여야 한다. 수정 보다 비용이 적은 확장으로 소프트웨어를 수정해야한다.
OCP를 지키기 위해서는 의존 관계를 잘 설계해야한다. 의존 관계가 확장 가능한 요소와 수정해야하는 요소를 결정짓기 때문인데, A -&amp;gt; B (A가 B에 의존)이라면 A는 확장 가능한 요소이고 B는 수정해야하는 요소가 되는 것이다.
이를 위해 DIP를 지켜야한다. 추상 보다 구현의 변화가 많은데, 구현이 추상에 의존해야 구현을 확장할 수 있기 때문이다.
모듈 레벨(OOP 클래스)에만 적용되는 원칙이 아니다.
          
          
        
      </description>
    </item>
    
    <item>
      <title>모듈</title>
      <link>https://chankoo.github.io/posts/%EB%AA%A8%EB%93%88/</link>
      <pubDate>Thu, 27 Oct 2022 22:23:08 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%EB%AA%A8%EB%93%88/</guid>
      <description>
        
          
            content 설계 시점에 다루는 코드 덩어리. 시점상 가장 먼저 구현하는 단위
refs 개발자에서 아키텍트로 클린 아키텍처 links 컴포넌트 
          
          
        
      </description>
    </item>
    
    <item>
      <title>SOLID</title>
      <link>https://chankoo.github.io/posts/solid/</link>
      <pubDate>Thu, 27 Oct 2022 22:13:29 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/solid/</guid>
      <description>
        
          
            content 모듈 수준의 소프트웨어 설계 원칙.
SRP OCP LSP ISP DIP
refs 클린 아키텍처 links 모듈 
          
          
        
      </description>
    </item>
    
    <item>
      <title>SRP</title>
      <link>https://chankoo.github.io/posts/srp/</link>
      <pubDate>Thu, 27 Oct 2022 22:10:27 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/srp/</guid>
      <description>
        
          
            content 단일 책임 원칙 - Single Responsibility Principle 모듈은 한 액터(사용자, 이해관계자)만 책임진다. 모듈을 변경한다면 그 이유는 반드시 한 액터 때문이어야 한다.
SRP를 따르면, 여러 액터의 요구를 책임지는 모듈은 책임을 찢어야 한다.
예를 들어 클래스 Employee가 재무팀을 위한 급여 계산 / 인사팀을 위한 업무 시간 계산을 책임지고 있다면, 이는 SRP를 위반한다. 그래서 -&amp;gt; 급여 계산을 위한 클래스와 업무 시간 계산을 위한 클래스로 책임을 분리하고, EmployeeFacade 클래스를 두어 인터페이스를 정리할 수 있다.
          
          
        
      </description>
    </item>
    
    <item>
      <title>Event Loop</title>
      <link>https://chankoo.github.io/posts/event-loop/</link>
      <pubDate>Tue, 25 Oct 2022 23:23:22 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/event-loop/</guid>
      <description>
        
          
            content 싱글 스레드에서 요청을 비동기로 처리하기 위해 사용하는 루프.
(gevent에서) I/O 요청시 커널에 요청을 주고 커널로 부터 응답 받은 이벤트를 처리하기 위해 돌고있는 루프 유저 영역 요청 -&amp;gt; 이벤트 루프 -&amp;gt; 이벤트 루프 응답 -&amp;gt; 대기하며 진행 커널 영역 블락 -&amp;gt; 이벤트 발생 -&amp;gt; 이벤트 루프에 노티 -&amp;gt; 대기 중인 것을 실현 (javascript에서) 콜백 큐에서 콜백 함수를 꺼내 콜 스택에 넣어 주는 루프 refs DEVIEW 2014 [JS] 도대체 이벤트 루프가 뭔가요?
          
          
        
      </description>
    </item>
    
    <item>
      <title>Big-O</title>
      <link>https://chankoo.github.io/posts/big-o/</link>
      <pubDate>Tue, 18 Oct 2022 22:29:11 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/big-o/</guid>
      <description>
        
          
            content 연산을 수행하는 비용(시간, 공간)의 상한을 대략적으로 표기하는 방법
비용이 어떤 비율로 증가하는지(상수, 선형, 로그, 지수 등)에만 관심있어서 지배적이지 않은 항은 무시한다 O(2N) == O(N) O(log_2(N)) == O(log_10(N)) refs links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>amortized analysis</title>
      <link>https://chankoo.github.io/posts/amortized-analysis/</link>
      <pubDate>Mon, 17 Oct 2022 00:01:04 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/amortized-analysis/</guid>
      <description>
        
          
            content 알고리즘을 수행 과정 별로 분할하여 비용(시간 복잡도)을 구하는 분석 방법. 일련의 연산들을 구분하여 평균적인 비용을 낸다는 측면에서 worst-case approach 보다 현실적일 수 있다.
refs https://ko.wikipedia.org/wiki/%EB%B6%84%ED%95%A0%EC%83%81%ED%99%98%EB%B6%84%EC%84%9D links Big-O 
          
          
        
      </description>
    </item>
    
    <item>
      <title>분할 상환 분석</title>
      <link>https://chankoo.github.io/posts/%EB%B6%84%ED%95%A0-%EC%83%81%ED%99%98-%EB%B6%84%EC%84%9D/</link>
      <pubDate>Mon, 17 Oct 2022 00:01:04 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%EB%B6%84%ED%95%A0-%EC%83%81%ED%99%98-%EB%B6%84%EC%84%9D/</guid>
      <description>
        
          
            content 알고리즘을 수행 과정 별로 분할하여 비용(시간 복잡도)을 구하는 분석 방법. 일련의 연산들을 구분하여 평균적인 비용을 낸다는 측면에서 worst-case approach 보다 현실적일 수 있다.
refs 분할상환분석 - 위키백과, 우리 모두의 백과사전 links Big-O 
          
          
        
      </description>
    </item>
    
    <item>
      <title>cache line</title>
      <link>https://chankoo.github.io/posts/cache-line/</link>
      <pubDate>Sun, 16 Oct 2022 23:15:14 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/cache-line/</guid>
      <description>
        
          
            content 캐시 라인(or cache block)은 프로세서의 캐시가 메모리로 부터 읽어오는 데이터 chunk.
보통 32, 64, 128 바이트 사이즈이다. 예를 들어 캐시 라인 사이즈가 64B이고 64kB 크기의 캐시를 쓴다면, 캐시는 1024개(= 64kB / 64B) 라인으로 구성된다.
refs 3.2. Cache Lines and Cache Size links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>locality</title>
      <link>https://chankoo.github.io/posts/locality/</link>
      <pubDate>Sun, 16 Oct 2022 22:54:01 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/locality/</guid>
      <description>
        
          
            content (프로세서의 메모리)참조는 랜덤이 아니고 비슷한 지역에서 빈번하게 일어난다는 특성(Locality of reference)
Spatial Locality 와 2) Temporal Locality로 크게 나뉘는데 1)은 비슷한 공간의 영역을 반복적으로, 2)는 최근에 참조한 영역을 반복적으로 참조하는 현상을 말한다. 프로세서의 캐시는 locality를 고려하여 동작하기에 프로그램을 짤 때 locality를 활용한다면 더 캐시 효율적이다.
refs Locality of reference - Wikipedia links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>해시 충돌</title>
      <link>https://chankoo.github.io/posts/%ED%95%B4%EC%8B%9C-%EC%B6%A9%EB%8F%8C/</link>
      <pubDate>Sun, 16 Oct 2022 22:04:24 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%ED%95%B4%EC%8B%9C-%EC%B6%A9%EB%8F%8C/</guid>
      <description>
        
          
            content (해시) 충돌은 1) 서로 다른 값이 동일한 해시를 뱉거나(해시 충돌) 2) 서로 다른 해시가 동일한 인덱스를 뱉는 경우를 말한다.
해시 자료구조를 구성할때 모든 key가 충돌한다면, 탐색에 O(n)이 걸린다.
모든 데이터가 하나의 인덱스에 저장(Separate Chaning)되거나 다른 인덱스에 순차적으로 저장(Open Addressing)될 것이기 때문이다. 저장할 값의 배열이 크지 않다면, Open Addressing 이 캐시 효율적이다. 연속된 공간에 저장한 데이터는 함께 캐싱될 것이고(cache line), spatial locality 에 따라 hit ratio가 높을 것이기 때문이다. 파이썬이 오픈 어드레싱 방식을 쓴다.
          
          
        
      </description>
    </item>
    
    <item>
      <title>해시</title>
      <link>https://chankoo.github.io/posts/%ED%95%B4%EC%8B%9C/</link>
      <pubDate>Sat, 15 Oct 2022 23:46:35 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%ED%95%B4%EC%8B%9C/</guid>
      <description>
        
          
            content 임의 길이 데이터를 해시 함수를 통해 변환한 값으로, 1) 길이가 고정이고 2) 변환 전 값을 구하는 역함수가 없다.
refs links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>해시 테이블</title>
      <link>https://chankoo.github.io/posts/%ED%95%B4%EC%8B%9C-%ED%85%8C%EC%9D%B4%EB%B8%94/</link>
      <pubDate>Sat, 15 Oct 2022 23:46:05 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%ED%95%B4%EC%8B%9C-%ED%85%8C%EC%9D%B4%EB%B8%94/</guid>
      <description>
        
          
            content 해시를 이용해서 key: value 쌍을 저장하고 O(1) 에 value를 찾는 자료구조이다.
해시 함수를 통해 immutable 한 key에서 해시를 얻는다 크기를 고정한(n) 배열을 생성하고 해시를 인덱스(0~n-1)로 변환하여(보통 modulo 연산. 해시 % n) 배열의 인덱스에 키 밸류를 저장한다 리스트, 그래프 형태로(Separate Channing)로 저장하거나 인접한 다른 인덱스에 삽입(Open Addressing)한다. (해시) 충돌이 발생하면 최악의 경우 탐색에 O(n)이 걸린다.
refs links 해시 해시 충돌 
          
          
        
      </description>
    </item>
    
    <item>
      <title>마운트</title>
      <link>https://chankoo.github.io/posts/%EB%A7%88%EC%9A%B4%ED%8A%B8/</link>
      <pubDate>Fri, 14 Oct 2022 00:23:47 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%EB%A7%88%EC%9A%B4%ED%8A%B8/</guid>
      <description>
        
          
            content 저장 장치에 접근할 수 있는 경로를 특정 디렉토리에 연결하여, 디렉토리 구조에 편입하는 일
refs links 디렉토리 
          
          
        
      </description>
    </item>
    
    <item>
      <title>블록 디바이스</title>
      <link>https://chankoo.github.io/posts/%EB%B8%94%EB%A1%9D-%EB%94%94%EB%B0%94%EC%9D%B4%EC%8A%A4/</link>
      <pubDate>Fri, 14 Oct 2022 00:03:26 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%EB%B8%94%EB%A1%9D-%EB%94%94%EB%B0%94%EC%9D%B4%EC%8A%A4/</guid>
      <description>
        
          
            content 블록 단위로 데이터 전송하는 기억장치. 캐릭터 디바이스에 비해 전송 속도가 빠르다.
refs links 블록 캐릭터 디바이스 
          
          
        
      </description>
    </item>
    
    <item>
      <title>캐릭터 디바이스</title>
      <link>https://chankoo.github.io/posts/%E1%84%8F%E1%85%A2%E1%84%85%E1%85%B5%E1%86%A8%E1%84%90%E1%85%A5-%E1%84%83%E1%85%B5%E1%84%87%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3/</link>
      <pubDate>Fri, 14 Oct 2022 00:02:36 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%E1%84%8F%E1%85%A2%E1%84%85%E1%85%B5%E1%86%A8%E1%84%90%E1%85%A5-%E1%84%83%E1%85%B5%E1%84%87%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3/</guid>
      <description>
        
          
            content 바이트 단위로 데이터 전송하는 문자 기반 기억장치. 키보드, 마우스, 모니터 등
refs links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>EBS</title>
      <link>https://chankoo.github.io/posts/ebs/</link>
      <pubDate>Fri, 14 Oct 2022 00:02:11 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/ebs/</guid>
      <description>
        
          
            content AWS Elastic Block Store AWS가 제공하는 기본 블록 디바이스. 네트워크 통신하는 논리 드라이브(볼륨)이다.
refs links 블록 디바이스 볼륨 
          
          
        
      </description>
    </item>
    
    <item>
      <title>PCB</title>
      <link>https://chankoo.github.io/posts/pcb/</link>
      <pubDate>Thu, 13 Oct 2022 23:31:07 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/pcb/</guid>
      <description>
        
          
            content Process Control Block. 프로세스 관리를 위한 정보를 담은 OS 커널의 자료구조이다. 프로세스 실행과 스케줄링 등에 필요한 정보를 포함하여 OS 입장에서 프로세스를 표현한다.
refs links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>블록</title>
      <link>https://chankoo.github.io/posts/%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A9%E1%86%A8/</link>
      <pubDate>Thu, 13 Oct 2022 23:01:33 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A9%E1%86%A8/</guid>
      <description>
        
          
            content OS가 저장 매체의 정보를 관리하는 단위. 저장할(디스크에 쓸) 때 블록(보통 4kb) 단위로 정보를 묶어서 쓰고, 그 참조를 관리한다.
윈도우에선 &amp;lsquo;클러스터&amp;rsquo;라는 용어도 쓴다.
refs links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>볼륨</title>
      <link>https://chankoo.github.io/posts/%EB%B3%BC%EB%A5%A8/</link>
      <pubDate>Thu, 13 Oct 2022 22:29:51 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%EB%B3%BC%EB%A5%A8/</guid>
      <description>
        
          
            content 파일시스템을 갖춘 논리적 스토리지 영역. 보통 마운트하여 접근한다.
refs links 마운트 파일 시스템 
          
          
        
      </description>
    </item>
    
    <item>
      <title>구글 태그 매니저</title>
      <link>https://chankoo.github.io/posts/%EA%B5%AC%EA%B8%80-%ED%83%9C%EA%B7%B8-%EB%A7%A4%EB%8B%88%EC%A0%80/</link>
      <pubDate>Thu, 13 Oct 2022 17:03:36 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%EA%B5%AC%EA%B8%80-%ED%83%9C%EA%B7%B8-%EB%A7%A4%EB%8B%88%EC%A0%80/</guid>
      <description>
        
          
            content GTM 태그(어플리케이션에 삽입하여 이벤트를 전송하는 코드)를 관리하는 역할을 한다. 태그가 전송한 데이터를 분석하는 툴과는 별개이다.
refs links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>Generator</title>
      <link>https://chankoo.github.io/posts/generator/</link>
      <pubDate>Wed, 12 Oct 2022 00:08:35 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/generator/</guid>
      <description>
        
          
            content 제너레이터는 제어 흐름을 양보할 수 있는 Iterator이다. 루프를 순회하는 도중 의도적으로 순회를 멈추고, 자신을 호출한 루틴으로 제어 흐름을 양보할 수 있다. 때문에 semicoroutine 이라고도 불리는데, 제어 흐름을 넘겨줄 routine을 지정할 수 있는 coroutine 의 특수한 형태이기 때문이다.
이러한 제너레이터의 동작은 1) 메모리 효율 2) 동시성 의 관점에서 살펴볼만하다. 루프 내 요소의 평가가 필요할때 메모리에 요소를 올리는 lazy evaluation 이고, 원하는 시점에 제어흐름을 넘겨가며 동시성 프로그래밍을 가능케하는 pseudo thread 이기 때문이다.
          
          
        
      </description>
    </item>
    
    <item>
      <title>coroutine</title>
      <link>https://chankoo.github.io/posts/coroutine/</link>
      <pubDate>Tue, 11 Oct 2022 20:39:15 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/coroutine/</guid>
      <description>
        
          
            content Co-Routine. 다른 루틴과 동등한 레벨에서 상호 협력하는 루틴. routine - subroutine 으로 종속되는 개념과 대비된다.
프로그래머는 코루틴 간 제어 흐름을 의도에 따라 통제하는데, 실행 중인 코루틴이 자신의 흐름을 멈추고 다른 코루틴에 양보(yield) 하도록 하는 방식이다.
코루틴 간의 스위칭을 통해 (스레드 스위칭과 유사하게) 동시성 프로그래밍할 수 있다. 코루틴이 &amp;ldquo;lightweight&amp;rdquo; 스레드라고도 불리는 이유이다.
스레드와의 주된 차이는, 별도의 스택 메모리를 갖지 않는다(stackless coroutine)는 점, 병렬 실행이 불가하다는 점 등이 있다.
+) 작업 후 다른 루틴에게 명시적으로 제어권을 넘겨줄 경우, CPS를 따라 구현했다고 볼 수 있다.
          
          
        
      </description>
    </item>
    
    <item>
      <title>Transaction</title>
      <link>https://chankoo.github.io/posts/transaction/</link>
      <pubDate>Mon, 10 Oct 2022 16:37:09 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/transaction/</guid>
      <description>
        
          
            content DB에서 데이터를 조작하는 논리적 작업 단위. 이론적으로 Transaction은 ACID해야한다.
예로 들면, 송금은 한 Transaction 이어야 하는데, 송금을 구성하는 1) 본인 계좌에서 출금 2) 상대 계좌에 입금이
Atomic - 발생하거나, 발생하지 않거나하여 그 중간 상태가 없어야하며 Correct(Consistant) - 송금 실행 전 후 모두 관련된 제약을 지키는 상태여야하며 Isolated - 송금 실행 중 다른 Transaction과는 격리(read x, write x)되어야 하며 Durable - 송금 성공의 시점 데이터를 지속적으로 보관해야한다. refs links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>Bytecode</title>
      <link>https://chankoo.github.io/posts/bytecode/</link>
      <pubDate>Sun, 09 Oct 2022 22:50:37 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/bytecode/</guid>
      <description>
        
          
            content 가상 컴퓨터의 실행 프로그램을 위한 이진 표현법. 하드웨어가 아니라 소프트웨어에서 해석되기에 기계어보다 더 추상적이다.
refs 바이트코드 - 위키백과, 우리 모두의 백과사전 links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>Microarchitecture</title>
      <link>https://chankoo.github.io/posts/microarchitecture/</link>
      <pubDate>Sun, 09 Oct 2022 22:34:57 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/microarchitecture/</guid>
      <description>
        
          
            content ISA를 구현하는 방법을 말한다.
예를들어, Intel 과 AMD는 동일한 x86 ISA를 쓰지만 Microarchitecture가 다르기에 성능이 다르다.
refs links ISA 
          
          
        
      </description>
    </item>
    
    <item>
      <title>ISA</title>
      <link>https://chankoo.github.io/posts/isa/</link>
      <pubDate>Sun, 09 Oct 2022 22:22:35 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/isa/</guid>
      <description>
        
          
            content 명령어 집합 구조(Instruction Set Architecture) CPU가 이해할 수 있는 기계어 명령어 집합을 의미한다. CPU 마다 비트 길이와 코드가 다르다.
각 비트를 기능적으로 분할하여 의미를 부여했고, 이 기계어 명렁어와 일대일 매핑하여 문자화 한 것이 어셈블리어(Assembly Language)다.
이는 소프트웨어와 하드웨어간 인터페이스를 규정한 것이다.
프로세서 칩을 만드는 회사마다 ISA가 다른데, 익숙한 예로 Intel의 칩은 x86을, ARM의 칩은 ARM 을 쓰는 식이다.
refs 명령어 집합 - 위키백과, 우리 모두의 백과사전 [ 컴퓨터구조 ] ISA (Instruction Set Architecture) links Assembly Language 
          
          
        
      </description>
    </item>
    
    <item>
      <title>Assembly Language</title>
      <link>https://chankoo.github.io/posts/assembly-language/</link>
      <pubDate>Sun, 09 Oct 2022 22:15:44 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/assembly-language/</guid>
      <description>
        
          
            content ISA의 명령어를 문자화 시킨 저급 언어이다. 프로그래머가 기계어를 다룰 수 있도록 고안되었고, 기계어 명령어와 일대일 대응한다. 그래서 ISA 의존적이고, 하드웨어 이식성이 낮다.
refs [Chapter 7] Assembly Language - 어셈블리어, 어셈블러 links ISA 
          
          
        
      </description>
    </item>
    
    <item>
      <title>Assembler</title>
      <link>https://chankoo.github.io/posts/assembler/</link>
      <pubDate>Sun, 09 Oct 2022 22:04:11 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/assembler/</guid>
      <description>
        
          
            content 어셈블리 언어(Assembly Language)를 기계어로 어셈블(assemble)하는 프로그램. 어셈블은 CPU의 ISA에 맞게 이루어진다.
하나의 프로그램을 어셈블하면 여러 개의 소스 파일로 나뉠 수 있다. 이러한 파일(기계어 조각)을 합쳐서 하나의 실행 가능한 파일로 만드는 프로그램을 링커(Linker)라 하며, 그 파일의 코드와 데이터를 메모리에 올리고, 해당 프로그램의 시작 주소로 CPU를 제어하도록 하는 프로그램이 로더(Loader)이다.
refs [Chapter 7] Assembly Language - 어셈블리어, 어셈블러 links Assembly Language ISA 
          
          
        
      </description>
    </item>
    
    <item>
      <title>dis</title>
      <link>https://chankoo.github.io/posts/dis/</link>
      <pubDate>Sun, 09 Oct 2022 22:02:55 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/dis/</guid>
      <description>
        
          
            content 파이썬 바이트코드 역 어셈블러. CPython의 바이트 코드를 역 어셈블하여 바이트 코드 레벨의 분석을 돕는 모듈이다.
ex)
def hi(x): x += 1 print(x) return x 위 정의에 따르면, 추상화한 바이트코드를 바이트코드로 바꾸는 것도 어셈블이라 볼 수 있다.
refs dis &amp;mdash; 파이썬 바이트 코드 역 어셈블러 — 파이썬 설명서 주석판 links Bytecode Assembler 
          
          
        
      </description>
    </item>
    
    <item>
      <title>Isolation Levels</title>
      <link>https://chankoo.github.io/posts/isolation-levels/</link>
      <pubDate>Sun, 09 Oct 2022 12:37:01 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/isolation-levels/</guid>
      <description>
        
          
            content Transaction 간 격리 수준. DBMS는 다양한 수준의 Isolation Level을 제공하여 ACID의 Isolation 관점에서 엄격히 제한된 Transaction의 병행성 제약을 완화한다. 이상적으로 Transaction은 엄격히 격리해야 하지만, 실무적으로 걸림돌이 되기에, 격리 수준을 단계적으로 완화하는 Isolation Levels 를 정의하여 상황에 맞게 제공한다.
Serializable - Isolation 제약을 지키는 수준으로 트랜잭션을 serial schedule 로 수행하여 다른 트랜잭션의 수행과 겹치는 시간이 없다. Repetable Reads - 반복해서 읽어도 같은 결과를 보여주는 수준으로, 반복 read 도중 커밋이 발생하여 값이 변해도 커밋 전 값을 읽어간다.
          
          
        
      </description>
    </item>
    
    <item>
      <title>Starvation</title>
      <link>https://chankoo.github.io/posts/starvation/</link>
      <pubDate>Sun, 09 Oct 2022 00:15:32 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/starvation/</guid>
      <description>
        
          
            content 기아 상태 여러 스레드나 프로세스가 자원을 점유하는 상황에서, 특정 스레드나 프로세스가 자원을 할당 받지 못하여 진행할 수 없는 상태
refs links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>DeadLock</title>
      <link>https://chankoo.github.io/posts/deadlock/</link>
      <pubDate>Sun, 09 Oct 2022 00:11:12 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/deadlock/</guid>
      <description>
        
          
            content 교착 상태 한정된 자원을 공유하는 작업들이 서로의 종료를 기다리며 끝없이 대치하는 상태
데드락의 필요 조건. 아래 4가지를 모두 만족시켜야 데드락이 발생한다.
상호 배제(Mutual Exclusion) 점유 대기 비선점 순환 대기 refs links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>Race Condition</title>
      <link>https://chankoo.github.io/posts/race-condition/</link>
      <pubDate>Sat, 08 Oct 2022 21:56:55 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/race-condition/</guid>
      <description>
        
          
            content 경쟁 상태 여러 스레드나 프로세스가 한 자원에 동시에 접근하고 조작하여 예상치 못한 결과(non deterministic)을 도출할 수 있는 상태. 즉, 스레드가 자원에 접근하는 타이밍에 결과가 영향 받는 상태를 의미한다
Thread 1 Thread 2 Integer value 0 read value ← 0 read value ← 0 increase value 0 increase value 0 write back → 1 write back → 1 refs Race condition - Wikipedia links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>POSIX</title>
      <link>https://chankoo.github.io/posts/posix/</link>
      <pubDate>Sat, 08 Oct 2022 21:49:21 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/posix/</guid>
      <description>
        
          
            content Portable Operation System Interface X UNIX OS 들이 공통적으로 제공해야할 API 규격이다. OS 간 이식성 높은 유닉스 응용프로그램을 만들기 위한 목적이다.
C 언어 인터페이스인 시스템콜과 프로세스 환경, 파일 시스템, 압축 포맷 등 다양한 규격을 정의한다.
refs POSIX - 위키백과, 우리 모두의 백과사전 links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>POSIX threads</title>
      <link>https://chankoo.github.io/posts/posix-threads/</link>
      <pubDate>Sat, 08 Oct 2022 21:33:44 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/posix-threads/</guid>
      <description>
        
          
            content Pthreads. UNIX 기반 운영체제에서 멀티 스레딩을 위해 제공하는 api(Windows 도 제공해준다). C 에서 사용
refs links POSIX 
          
          
        
      </description>
    </item>
    
    <item>
      <title>Thread Safe</title>
      <link>https://chankoo.github.io/posts/thread-safe/</link>
      <pubDate>Sat, 08 Oct 2022 21:07:04 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/thread-safe/</guid>
      <description>
        
          
            content 일반적으로, 여러 스레드가 실행해도 정상적으로 동작(매번 같은 결과를 리턴)하는 코드(변수, 함수 등)를 스레드 안전 하다고 말한다.
동시성을 다룰 땐 &amp;lsquo;스레드 안전&amp;rsquo; 해야하는데, 이를 구현하는 모델로 잠금장치, 함수형 프로그래밍, 클로저 등을 쓸 수 있겠다.
refs 7가지 동시성 모델 links 동시성 
          
          
        
      </description>
    </item>
    
    <item>
      <title>병렬성</title>
      <link>https://chankoo.github.io/posts/%EB%B3%91%EB%A0%AC%EC%84%B1/</link>
      <pubDate>Sat, 08 Oct 2022 21:01:11 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%EB%B3%91%EB%A0%AC%EC%84%B1/</guid>
      <description>
        
          
            content 여러 일을 한꺼번에 실행하는 것. Parallelism. CPU의 영역에서 명세하자면, 여러 CPU가 스레드 하나씩을 동시에 실행하는 것이다.
여러가지 일을 동시에 다루는 요구사항(동시성)을 해결하는 방법이기에 해법의 속성을 내포한다. 실제로 순차적 프로그래밍의 한계를 넘어서는 기술이다.
refs 7가지 동시성 모델 links 동시성 
          
          
        
      </description>
    </item>
    
    <item>
      <title>DIP</title>
      <link>https://chankoo.github.io/posts/dip/</link>
      <pubDate>Thu, 06 Oct 2022 23:42:10 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/dip/</guid>
      <description>
        
          
            content Dependency Inversion Principle(의존성 역전 원칙) 더 구체적인(하위 계층) 모듈에 의존하는 일반적(절차적)인 의존성의 흐름을 역전 시켜 더 추상적인(상위 계층) 모듈에 의존하도록해야한다.
추상 팩토리 패턴이 대표적이다. 객체 생성을 위해 구체 팩토리에 의존(요소 -&amp;gt; 팩토리)하는 것이 아니라, 추상 팩토리에 의존(요소 -&amp;gt; 추상 팩토리 $\Leftarrow$ 구체 팩토리)하는 것이다.
refs 클린 아키텍처 links SOLID 추상 팩토리 패턴 
          
          
        
      </description>
    </item>
    
    <item>
      <title>DI</title>
      <link>https://chankoo.github.io/posts/di/</link>
      <pubDate>Thu, 06 Oct 2022 23:33:48 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/di/</guid>
      <description>
        
          
            content Dependency Injection(의존성 주입) 클라이언트에서 사용할 의존성을 외부에서 넣어주는 일
refs links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>IOC</title>
      <link>https://chankoo.github.io/posts/ioc/</link>
      <pubDate>Thu, 06 Oct 2022 22:45:02 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/ioc/</guid>
      <description>
        
          
            content Inversion Of Control(제어 역전) 클라이언트(프로그래머)가 직접 사용할 의존성을 제어하는 상황(일반적, 절차적) -&amp;gt; 누군가(프레임워크)가 의존성을 정해주는(DI, DIP 등으로) 상황(역전)
refs 학습 페이지 [Study]IoC, DI, DIP 개념 잡기 - 기록은 기억을 지배한다 links DI DIP 
          
          
        
      </description>
    </item>
    
    <item>
      <title>UseEffect</title>
      <link>https://chankoo.github.io/posts/useeffect/</link>
      <pubDate>Thu, 06 Oct 2022 13:18:27 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/useeffect/</guid>
      <description>
        
          
            content 함수형 컴포넌트에서 이펙트를 정의하는 훅. 렌더링 후 리액트가 내부의 함수를 실행한다. 리액트는 각 렌더링 마다 deps 배열을 비교하여 이펙트 내 함수 실행 여부를 따진다.
refs links 함수형 컴포넌트 
          
          
        
      </description>
    </item>
    
    <item>
      <title>함수형 컴포넌트</title>
      <link>https://chankoo.github.io/posts/%ED%95%A8%EC%88%98%ED%98%95-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/</link>
      <pubDate>Thu, 06 Oct 2022 01:40:37 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%ED%95%A8%EC%88%98%ED%98%95-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/</guid>
      <description>
        
          
            content react의 함수형 컴포넌트는 당연하게도 함수형 프로그래밍의 패러다임을 따른다. 컴포넌트 내 state는 불변하며, setState는 새 state로 컴포넌트 함수를 다시 호출한다. 그때마다 다시 렌더링되는 것이고 각 렌더링은 고유의 함수(핸들러, 이펙트)를 가진다.
refs useEffect 완벽 가이드 — Overreacted links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>postback</title>
      <link>https://chankoo.github.io/posts/postback/</link>
      <pubDate>Thu, 06 Oct 2022 00:01:42 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/postback/</guid>
      <description>
        
          
            content 광고 매체를 통해 유입된 어플리케이션 유저의 데이터를 다시 광고 매체로 돌려주는 일. 보통 어플리케이션 제공자 입장에서 postback 기능이 있는 솔루션(MMP)가 필요한데, 1) 유저 데이터를 가지고 이용중인 광고를 최적화 하려는 목적과 2) 광고 매체 마다 API 스펙이 제각각이어서 대응이 어려운 문제 때문이다.
refs links webhook 
          
          
        
      </description>
    </item>
    
    <item>
      <title>동시성</title>
      <link>https://chankoo.github.io/posts/%EB%8F%99%EC%8B%9C%EC%84%B1/</link>
      <pubDate>Tue, 04 Oct 2022 22:32:56 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%EB%8F%99%EC%8B%9C%EC%84%B1/</guid>
      <description>
        
          
            content 여러 일을 한꺼번에 다루는 것. Concurrency. CPU의 영역에서 명세하자면, CPU는 하나인데 여러 스레드에서 각각의 제어흐름을 다루고 있는 상황이다.
순차적 프로그래밍의 한계를 넘어서려는 시도이나, 여러가지 일을 동시에 다루는 척(병렬 착각, 병행성)하는 것이기에 그자체로 문제의 속성을 내포한다.
refs 7가지 동시성 모델 links 병렬성 
          
          
        
      </description>
    </item>
    
    <item>
      <title>why numpy array</title>
      <link>https://chankoo.github.io/posts/why-numpy-array/</link>
      <pubDate>Mon, 03 Oct 2022 16:17:54 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/why-numpy-array/</guid>
      <description>
        
          
            content 파이썬의 list 보다 np array가
더 빠르다 element로 PyObject 대신 value를 들고 있어 직접 접근할 수 있다. 메모리 효율이 좋다. element의 크기가 작다 PyObject - 4 for type pointer, 4 for reference count, 4 for value &amp;ndash; and the memory allocators rounds up to 16 value - single-precision numbers takes 4 bytes each, double-precision ones, 8 bytes 동적배열 아니어서 크기가 고정이며 정적할당하여 element 타입이 고정이다 refs links PyObject Dynamic Array 
          
          
        
      </description>
    </item>
    
    <item>
      <title>Python-GC</title>
      <link>https://chankoo.github.io/posts/python-gc/</link>
      <pubDate>Mon, 03 Oct 2022 16:08:52 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/python-gc/</guid>
      <description>
        
          
            content 파이썬(CPython)에서는 아래 두가지 객체에 대해 가비지 컬렉션을 실행한다.
PyObject의 ref count가 0
순환 참조가 발생했고 그 외의 참조는 없음
예제
l = [] l.append(l) del l refs Python GC가 작동하는 원리 links 가비지 컬렉션 PyObject 
          
          
        
      </description>
    </item>
    
    <item>
      <title>PyObject</title>
      <link>https://chankoo.github.io/posts/pyobject/</link>
      <pubDate>Mon, 03 Oct 2022 15:37:15 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/pyobject/</guid>
      <description>
        
          
            content 일반적인 CPython 구현체를 가정했을때, 파이썬의 메모리 관리 알고리즘은 C로 쓰여졌고, 이해를 위해서는 CPython 의 내부 구현을 알아야한다.
모든 파이썬 객체는 PyObject라는 c struct 를 확장하여 가지고 있다. PyObject는 ob_type 포인터 객체의 타입 오브젝트를 가리키고, ob_refcnt를 통해 레퍼런스 카운팅을 한다.
refs Memory Management in Python – Real Python links CPython 
          
          
        
      </description>
    </item>
    
    <item>
      <title>JIT 컴파일</title>
      <link>https://chankoo.github.io/posts/jit-%EC%BB%B4%ED%8C%8C%EC%9D%BC/</link>
      <pubDate>Mon, 03 Oct 2022 15:07:40 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/jit-%EC%BB%B4%ED%8C%8C%EC%9D%BC/</guid>
      <description>
        
          
            content 런타임에 원시코드를 읽어가며 기계어로 실시간 컴파일하는 기술. 그 결과 JIT 컴파일을 활용하면 정적 컴파일만큼 빠른 속도로 돌면서도, 인터프리터 언어만큼 잦은 인터랙션을 제공할 수 있다.
refs -JIT 컴파일 - 위키백과, 우리 모두의 백과사전
links 인터프리터 
          
          
        
      </description>
    </item>
    
    <item>
      <title>인터프리터</title>
      <link>https://chankoo.github.io/posts/%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0/</link>
      <pubDate>Mon, 03 Oct 2022 14:56:30 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0/</guid>
      <description>
        
          
            content 프로그래밍 언어(일반적으로 고급 언어)를 읽고 바로 실행하는 프로그램 또는 환경.
인터프리터는 아래 세가지 중 적어도 하나의 일을 한다.
소스코드를 직접 실행한다. 소스코드를 더 효율적인 중간 코드(바이트코드)로 변환하고 이를 실행한다. (인터프리터 시스템의 일부인) 컴파일러가 사전에 컴파일한 파일의 실행을 호출한다. 현대의 많은 인터프리터가 JIT 컴파일 과 같은 기술을 지원하여서 컴파일러와의 엄격한 구분은 의미를 잃었다.
refs 인터프리터 - 위키백과, 우리 모두의 백과사전 links 컴파일러 JIT 컴파일 Bytecode 
          
          
        
      </description>
    </item>
    
    <item>
      <title>컴파일러</title>
      <link>https://chankoo.github.io/posts/%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC/</link>
      <pubDate>Mon, 03 Oct 2022 14:51:18 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC/</guid>
      <description>
        
          
            content 고급 프로그래밍 언어를 저급 프로그래밍 언어(어셈블리 언어, 기계어 등)로 바꾸어 출력하는 번역 프로그램.
refs 컴파일러 - 위키백과, 우리 모두의 백과사전 links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>Cython</title>
      <link>https://chankoo.github.io/posts/cython/</link>
      <pubDate>Mon, 03 Oct 2022 13:54:50 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/cython/</guid>
      <description>
        
          
            content Cython: C-Extension for Python C로 파이썬의 확장 모듈을 구현하기 위해 설계한 컴파일 언어. C와 파이썬의 superset이며 표준 C/C++ 컴파일러를 이용한다. 이러한 특성은 파이썬 언어의 높은 생산성을 활용하면서 실행 속도의 향상을 가져온다.
refs 사이썬 - 위키백과, 우리 모두의 백과사전 links CPython 컴파일러 
          
          
        
      </description>
    </item>
    
    <item>
      <title>CPython</title>
      <link>https://chankoo.github.io/posts/cpython/</link>
      <pubDate>Mon, 03 Oct 2022 13:40:56 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/cpython/</guid>
      <description>
        
          
            content C로 구현한 파이썬 인터프리터 시스템. 파이썬 언어로 쓰인 스크립트를 바이트코드(.pyc, pycache)로 컴파일한 후, 인터프리터로 실행한다.
refs CPython 파헤치기: 따라 하면서 이해하는 파이썬 내부의 동작 원리 – 도서출판 인사이트 links 인터프리터 Bytecode 
          
          
        
      </description>
    </item>
    
    <item>
      <title>MVVM</title>
      <link>https://chankoo.github.io/posts/mvvm/</link>
      <pubDate>Mon, 03 Oct 2022 13:02:32 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/mvvm/</guid>
      <description>
        
          
            content View -&amp;gt; ViewModel -&amp;gt; Model 의 구조. View 를 그리기 위한 데이터와 비즈니스 로직을 ViewModel에 모두 담아 View와 Model 결합을 끊는다. MVC(UIKit) 를 이용하던 iOS 개발의 대세 흐름이 MVVM(SwiftUI)을 이용하는 것으로 변했는데, MVC에 비해 각 계층이 더 잘 분리되어 유지보수와 테스트가 더 용이하다. MVVM은 View가 ViewModel을, ViewModel이 Model을 소유하는 방식인데, MVC의 ViewController가 Model과 View를 모두 떠맡아 비대해지는 이슈를 해결하는 구조이다. 화면을 VC 단위로 구성하는 것이 아니라, View가 필요한 비즈니스 로직(ViewModel)을 가져와 사용하는 것이다.
          
          
        
      </description>
    </item>
    
    <item>
      <title>Container-Presenter 패턴</title>
      <link>https://chankoo.github.io/posts/container-presenter-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Mon, 03 Oct 2022 12:37:15 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/container-presenter-%ED%8C%A8%ED%84%B4/</guid>
      <description>
        
          
            content 리액트에서 로직과 뷰 컴포넌트를 분리하는 패턴. 데이터를 가져오고 가공하는 컨테이너 컴포넌트와, 데이터를 렌더링하는 프레젠터 컴포넌트로 나눈다.
aka Smart &amp;amp; Dumb conponents 대개 컨테이너는 렌더링하는 컴포넌트 외에 다른 ui는 렌더링하지 않으며, 프레젠터는 컨테이너로 부터 데이터를 받아 단순히 렌더링 한다.
관심사 분리를 통해 재사용성 높은 순수한 프레젠터 컴포넌트를 만드는 이점이 있으며, 테스트가 쉬워서 험블 객체 패턴을 따랐다고도 볼 수 있겠다.
반면 데이터 가져오는 역할을 hook이 점차 대체하며, 굳이 컨테이너 컴포넌트를 두는게 불필요하다는 의견도 늘고있다.
          
          
        
      </description>
    </item>
    
    <item>
      <title>Dynamic Array</title>
      <link>https://chankoo.github.io/posts/dynamic-array/</link>
      <pubDate>Mon, 03 Oct 2022 00:11:36 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/dynamic-array/</guid>
      <description>
        
          
            content python 의 list 는 dynamic array이다. 런타임에 element를 추가할때, 리스트에 할당된 메모리 공간이 모자라면 리스트 크기를 늘린다. 그런데 dynamic array도 엄연한 array 이기에 &amp;rsquo;element 가 연속된 메모리 공간을 점유한다&amp;rsquo;는 제약을 따라야한다. 그래서 python(cpython)은 요소가 추가되어 리스트 크기가 변해야할 때, 전체 list를 복사하여 더 큰(2의 거듭제곱) 공간에 통째로 재할당 한다.
이는 시간 복잡도 계산에 영향을 준다. list 에 요소를 더하는 append 나 insert 연산의 시간 복잡도를 계산할 때 메모리 재할당 시간까지 고려해야 한다는 의미다.
          
          
        
      </description>
    </item>
    
    <item>
      <title>제텔카스텐</title>
      <link>https://chankoo.github.io/posts/%EC%A0%9C%ED%85%94%EC%B9%B4%EC%8A%A4%ED%85%90/</link>
      <pubDate>Sun, 02 Oct 2022 22:59:24 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%EC%A0%9C%ED%85%94%EC%B9%B4%EC%8A%A4%ED%85%90/</guid>
      <description>
        
          
            content 생각 정리를 위한 제텔카스텐 cherry-pick
가억과 생각을 탐색하는 자료구조
노트 작성 원칙
atomic한 아이디어를 노트로 작성한다. 임시 노트를 작성하고 영구 노트로 옮긴다. 노트 간 연결은 많을수록 좋다. 영구 노트 작성 원칙
내 글로 다시 쓴다. 출판을 전제로 쓴다. 분량을 제한한다. 페이지 작성법
영구 노트의 글감을 정리하여 한 편의 글을 쓴다. Cmd + Shift + E 단축키로 로컬 디렉토리(pages)에 내보낸다. pages/deploy.sh 로 publish 한다. refs 4. 옵시디안은 제텔카스텐을 위해 태어났다. 제텔카스텐 개념과 기본 세팅[한글 자막] - YouTube links 노트 템플릿 
          
          
        
      </description>
    </item>
    
  </channel>
</rss>
