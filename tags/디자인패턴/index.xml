<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>디자인패턴 on chankoo</title>
    <link>https://chankoo.github.io/tags/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/</link>
    <description>Recent content in 디자인패턴 on chankoo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 02 Dec 2023 13:52:08 +0900</lastBuildDate><atom:link href="https://chankoo.github.io/tags/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>추상 팩토리 패턴</title>
      <link>https://chankoo.github.io/posts/%EC%B6%94%EC%83%81-%ED%8C%A9%ED%86%A0%EB%A6%AC-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Sat, 02 Dec 2023 13:52:08 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%EC%B6%94%EC%83%81-%ED%8C%A9%ED%86%A0%EB%A6%AC-%ED%8C%A8%ED%84%B4/</guid>
      <description>
        
          
            content 객체 생성을 위해 구체 팩토리에 의존(요소 -&amp;gt; 팩토리)하는 것이 아니라, 추상 팩토리에 의존(요소 -&amp;gt; 추상 팩토리 $\Leftarrow$ 구체 팩토리)하는 패턴이다.
DIP의 전형적인 예시이다.
refs links DIP 
          
          
        
      </description>
    </item>
    
    <item>
      <title>험블 객체 패턴</title>
      <link>https://chankoo.github.io/posts/%ED%97%98%EB%B8%94-%EA%B0%9D%EC%B2%B4-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Thu, 03 Nov 2022 22:53:56 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%ED%97%98%EB%B8%94-%EA%B0%9D%EC%B2%B4-%ED%8C%A8%ED%84%B4/</guid>
      <description>
        
          
            content 테스트를 더 잘하기 위한 패턴으로, 테스트하기 어려운 행위는 &amp;lsquo;험블 객체&amp;rsquo;로 추출해 객체의 역할을 최소화 시키는 방식이다.
흔한 예로, 험블 객체 패턴으로 프레젠터와 뷰를 나누게 되는데, UI 와 엮인 행위는 테스트가 어려우므로 뷰에 UI 관련 행위만 남겨놓는 것이다. 데이터를 처리하는 행위는 프레젠터가 책임지고 테스트를 완수하며, 뷰는 데이터를 넘겨 받아 뿌려주는 역할만 하는 보잘 것 없는(humble) 모듈이 된다.
refs 클린 아키텍처 links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>GoF의 디자인 패턴</title>
      <link>https://chankoo.github.io/posts/gof%EC%9D%98-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Thu, 27 Oct 2022 22:09:42 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/gof%EC%9D%98-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/</guid>
      <description>
        
          
            content refs links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>퍼사드 패턴</title>
      <link>https://chankoo.github.io/posts/%ED%8D%BC%EC%82%AC%EB%93%9C-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Thu, 27 Oct 2022 22:01:57 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%ED%8D%BC%EC%82%AC%EB%93%9C-%ED%8C%A8%ED%84%B4/</guid>
      <description>
        
          
            content 서브 시스템(클래스들)을 숨기고 대표 인터페이스 하나(퍼사드)만 공개하는 디자인패턴. 퍼사드는 서브시스템 내 모든 인터페이스 집합을 상위 수준에서 제공한다.
객체 캡슐화와 유사한데, 캡슐화는 객체의 구현을 감추는 것이고 퍼사드는 서브 시스템의 구현을 감춘다.
refs GoF의 디자인 패턴 links 캡슐화 
          
          
        
      </description>
    </item>
    
    <item>
      <title>Iterator</title>
      <link>https://chankoo.github.io/posts/iterator/</link>
      <pubDate>Tue, 11 Oct 2022 23:36:52 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/iterator/</guid>
      <description>
        
          
            content 특정 집합 객체 요소에 순차적으로 접근 가능하도록 구현해놓은 객체. Iterator 패턴을 따라서 내부를 노출하지 않고 집합 객체의 구현에 종속되지 않아야한다.
Iterator 를 제공하는 객체는 Iterator Protocol 을 따랐다고 표현하는데, 이는 언어마다 상이하다. 에를 들어 javascript 에선 Iteration Protocol 하위에 Iteration Protocol 과 Iterator Protocol이 존재한다.
구현은 프로그래밍 언어마다 다양할 수 있다. 보통 Iterable 객체와 묶여서 구현한다. python과 java 모두 Iterable 객체로 부터 Iterator를 얻으며(iter, iterator()), 다음 요소를 가져오는 메소드를 제공한다(next, next()).
          
          
        
      </description>
    </item>
    
    <item>
      <title>IOC</title>
      <link>https://chankoo.github.io/posts/ioc/</link>
      <pubDate>Thu, 06 Oct 2022 22:45:02 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/ioc/</guid>
      <description>
        
          
            content Inversion Of Control(제어 역전) 클라이언트(프로그래머)가 직접 사용할 의존성을 제어하는 상황(일반적, 절차적) -&amp;gt; 누군가(프레임워크)가 의존성을 정해주는(DI, DIP 등으로) 상황(역전)
refs 학습 페이지 [Study]IoC, DI, DIP 개념 잡기 - 기록은 기억을 지배한다 links DI DIP 
          
          
        
      </description>
    </item>
    
    <item>
      <title>MVVM</title>
      <link>https://chankoo.github.io/posts/mvvm/</link>
      <pubDate>Mon, 03 Oct 2022 13:02:32 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/mvvm/</guid>
      <description>
        
          
            content View -&amp;gt; ViewModel -&amp;gt; Model 의 구조. View 를 그리기 위한 데이터와 비즈니스 로직을 ViewModel에 모두 담아 View와 Model 결합을 끊는다. MVC(UIKit) 를 이용하던 iOS 개발의 대세 흐름이 MVVM(SwiftUI)을 이용하는 것으로 변했는데, MVC에 비해 각 계층이 더 잘 분리되어 유지보수와 테스트가 더 용이하다. MVVM은 View가 ViewModel을, ViewModel이 Model을 소유하는 방식인데, MVC의 ViewController가 Model과 View를 모두 떠맡아 비대해지는 이슈를 해결하는 구조이다. 화면을 VC 단위로 구성하는 것이 아니라, View가 필요한 비즈니스 로직(ViewModel)을 가져와 사용하는 것이다.
          
          
        
      </description>
    </item>
    
    <item>
      <title>Container-Presenter 패턴</title>
      <link>https://chankoo.github.io/posts/container-presenter-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Mon, 03 Oct 2022 12:37:15 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/container-presenter-%ED%8C%A8%ED%84%B4/</guid>
      <description>
        
          
            content 리액트에서 로직과 뷰 컴포넌트를 분리하는 패턴. 데이터를 가져오고 가공하는 컨테이너 컴포넌트와, 데이터를 렌더링하는 프레젠터 컴포넌트로 나눈다.
aka Smart &amp;amp; Dumb conponents 대개 컨테이너는 렌더링하는 컴포넌트 외에 다른 ui는 렌더링하지 않으며, 프레젠터는 컨테이너로 부터 데이터를 받아 단순히 렌더링 한다.
관심사 분리를 통해 재사용성 높은 순수한 프레젠터 컴포넌트를 만드는 이점이 있으며, 테스트가 쉬워서 험블 객체 패턴을 따랐다고도 볼 수 있겠다.
반면 데이터 가져오는 역할을 hook이 점차 대체하며, 굳이 컨테이너 컴포넌트를 두는게 불필요하다는 의견도 늘고있다.
          
          
        
      </description>
    </item>
    
  </channel>
</rss>
