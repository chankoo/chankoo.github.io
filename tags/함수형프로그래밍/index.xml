<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>함수형프로그래밍 on chankoo</title>
    <link>https://chankoo.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/</link>
    <description>Recent content in 함수형프로그래밍 on chankoo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 30 Nov 2023 15:43:19 +0900</lastBuildDate><atom:link href="https://chankoo.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CPS</title>
      <link>https://chankoo.github.io/posts/cps/</link>
      <pubDate>Thu, 30 Nov 2023 15:43:19 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/cps/</guid>
      <description>
        
          
            content Continuation Passing Style. 말그대로 Continuation을 전달하는 방식으로 프로그래밍하는 것을 말한다.
이는 CPS 함수를 정의할 때 특정한 작업(ex. 콜백 함수) 을 명시적 인자로 받게되는데, CPS 함수는 해당 함수의 작업이 끝난 후 인자로 받은 작업을 수행하게 된다. Continuation이 CPS 함수에 있다가 인자로 받은 작업으로 넘어가는 것이다.
CPS가 아니라면 함수가 그냥(암묵적으로) 작업을 수행하며, Continuation은 해당 함수에 머무른다.
refs Continuation-passing style - Wikipedia 백엔드 개발자들이 알아야할 동시성 5 — Continuation Passing Style | by Choi Geonu | Medium Continuation-Passing Style.
          
          
        
      </description>
    </item>
    
    <item>
      <title>리액티브 프로그래밍</title>
      <link>https://chankoo.github.io/posts/%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/</link>
      <pubDate>Thu, 01 Jun 2023 16:39:03 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/</guid>
      <description>
        
          
            content 데이터 스트림에 영향을 미치는 모든 변경 사항을 observer 들에게 전파하는 프로그래밍
리액티브 매니페스토
반응성(responsive) : 리액티브 시스템은 빠를 뿐 아니라 + 일정하고 예상가능한 반응 시간을 제공한다. 회복성(resilient) : 장애가 발생해도 시스템은 반응해야한다. 여러 컴포넌트의 시간과 공간 분리 (즉, 컴포넌트가 각각 독립적인 생명주기를 갖고 다른 프로세스에서 실행), 작업 위임시 비동기적으로 위임하는 등의 기법이 있다. 탄력성(elastic) : 애플리케이션의 생명주기 동안 다양한 부하를 받는데 이때 리액티브 시스템에서는 자동으로 관련 컴포넌트에 할당된 자원 수를 늘린다.
          
          
        
      </description>
    </item>
    
    <item>
      <title>Thread Safe</title>
      <link>https://chankoo.github.io/posts/thread-safe/</link>
      <pubDate>Sat, 08 Oct 2022 21:07:04 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/thread-safe/</guid>
      <description>
        
          
            content 일반적으로, 여러 스레드가 실행해도 정상적으로 동작(매번 같은 결과를 리턴)하는 코드(변수, 함수 등)를 스레드 안전 하다고 말한다.
동시성을 다룰 땐 &amp;lsquo;스레드 안전&amp;rsquo; 해야하는데, 이를 구현하는 모델로 잠금장치, 함수형 프로그래밍, 클로저 등을 쓸 수 있겠다.
refs 7가지 동시성 모델 links 동시성 
          
          
        
      </description>
    </item>
    
    <item>
      <title>함수형 컴포넌트</title>
      <link>https://chankoo.github.io/posts/%ED%95%A8%EC%88%98%ED%98%95-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/</link>
      <pubDate>Thu, 06 Oct 2022 01:40:37 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%ED%95%A8%EC%88%98%ED%98%95-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/</guid>
      <description>
        
          
            content react의 함수형 컴포넌트는 당연하게도 함수형 프로그래밍의 패러다임을 따른다. 컴포넌트 내 state는 불변하며, setState는 새 state로 컴포넌트 함수를 다시 호출한다. 그때마다 다시 렌더링되는 것이고 각 렌더링은 고유의 함수(핸들러, 이펙트)를 가진다.
refs useEffect 완벽 가이드 — Overreacted links 
          
          
        
      </description>
    </item>
    
  </channel>
</rss>
