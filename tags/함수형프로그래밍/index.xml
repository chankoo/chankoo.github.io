<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>함수형프로그래밍 on chankoo</title>
    <link>https://chankoo.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/</link>
    <description>Recent content in 함수형프로그래밍 on chankoo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 30 Nov 2023 15:43:19 +0900</lastBuildDate><atom:link href="https://chankoo.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CPS</title>
      <link>https://chankoo.github.io/posts/cps/</link>
      <pubDate>Thu, 30 Nov 2023 15:43:19 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/cps/</guid>
      <description>
        
          
            Continuation Passing Style. 말그대로 Continuation을 전달하는 방식으로 프로그래밍하는 것을 말한다.
이는 CPS 함수를 정의할 때 특정한 작업(ex. 콜백 함수) 을 명시적 인자로 받게되는데, CPS 함수는 해당 함수의 작업이 끝난 후 인자로 받은 작업을 수행하게 된다. Continuation이 CPS 함수에 있다가 인자로 받은 작업으로 넘어가는 것이다.
CPS가 아니라면 함수가 그냥(암묵적으로) 작업을 수행하며, Continuation은 해당 함수에 머무른다.
refs Continuation-passing style - Wikipedia 백엔드 개발자들이 알아야할 동시성 5 — Continuation Passing Style | by Choi Geonu | Medium Continuation-Passing Style.
          
          
        
      </description>
    </item>
    
    <item>
      <title>리액티브 프로그래밍</title>
      <link>https://chankoo.github.io/posts/%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/</link>
      <pubDate>Thu, 01 Jun 2023 16:39:03 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/</guid>
      <description>
        
          
            content 데이터 스트림에 영향을 미치는 모든 변경 사항을 observer 들에게 전파하는 프로그래밍
리액티브 매니페스토
반응성(responsive) : 리액티브 시스템은 빠를 뿐 아니라 + 일정하고 예상가능한 반응 시간을 제공한다. 회복성(resilient) : 장애가 발생해도 시스템은 반응해야한다. 여러 컴포넌트의 시간과 공간 분리 (즉, 컴포넌트가 각각 독립적인 생명주기를 갖고 다른 프로세스에서 실행), 작업 위임시 비동기적으로 위임하는 등의 기법이 있다. 탄력성(elastic) : 애플리케이션의 생명주기 동안 다양한 부하를 받는데 이때 리액티브 시스템에서는 자동으로 관련 컴포넌트에 할당된 자원 수를 늘린다.
          
          
        
      </description>
    </item>
    
    <item>
      <title>Thread Safe</title>
      <link>https://chankoo.github.io/posts/thread-safe/</link>
      <pubDate>Sat, 08 Oct 2022 21:07:04 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/thread-safe/</guid>
      <description>
        
          
            일반적으로, 여러 스레드가 실행해도 정상적으로 동작(매번 같은 결과를 리턴)하는 코드(변수, 함수 등)를 스레드 안전 하다고 말한다.
동시성을 다룰 땐 &amp;lsquo;스레드 안전&amp;rsquo; 해야하는데, 이를 구현하는 모델로 잠금장치, 함수형 프로그래밍, 클로저 등을 쓸 수 있겠다.
refs 7가지 동시성 모델 links 동시성 
          
          
        
      </description>
    </item>
    
    <item>
      <title>함수형 컴포넌트</title>
      <link>https://chankoo.github.io/posts/%ED%95%A8%EC%88%98%ED%98%95-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/</link>
      <pubDate>Thu, 06 Oct 2022 01:40:37 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%ED%95%A8%EC%88%98%ED%98%95-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/</guid>
      <description>
        
          
            react의 함수형 컴포넌트는 당연하게도 함수형 프로그래밍의 패러다임을 따른다. 컴포넌트 내 state는 불변하며, setState는 새 state로 컴포넌트 함수를 다시 호출한다. 그때마다 다시 렌더링되는 것이고 각 렌더링은 고유의 함수(핸들러, 이펙트)를 가진다.
refs useEffect 완벽 가이드 — Overreacted links 
          
          
        
      </description>
    </item>
    
    <item>
      <title>프로그래밍 패러다임</title>
      <link>https://chankoo.github.io/posts/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84/</link>
      <pubDate>Tue, 04 Oct 2022 21:42:24 +0900</pubDate>
      
      <guid>https://chankoo.github.io/posts/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84/</guid>
      <description>
        
          
            content 클린 아키텍처 에 따르면, 프로그래밍 패러다임은 아래 세가지 뿐이다.
패러다임은 패러다임에 맞게 구현된 도구를 사용하거나, 그렇지 않은 도구를 사용하지 않음으로써, 프로그래머의 권한을 제한한다.
구조적 프로그래밍(structured programming) 프로그래머가 직접적으로 흐름을 통제하는 일을 제한한다. goto 문을 없애는 것 객체 지향 프로그래밍(OOP, object oriented programming) 프로그래머가 간접적으로 흐름을 통제하는 일을 제한한다. 함수 포인터를 사용해 런타임에 실행 함수를 결정하는 일 -&amp;gt; 다형성 문법을 따르게 함 함수형 프로그래밍(functional programming) 변수 할당을 제한한다. 가변 변수를 없애고 CR만 이용한다.
          
          
        
      </description>
    </item>
    
  </channel>
</rss>
